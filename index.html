<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <link rel="manifest" href="/images/manifest.json">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.2.1/css/all.min.css" integrity="sha256-Z1K5uhUaJXA7Ll0XrZ/0JhX4lAtZFpT6jkKrEDT0drU=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"alanhou.github.io","root":"/","images":"/images","scheme":"Gemini","darkmode":true,"version":"8.14.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}}</script><script src="/js/config.js"></script>

    <meta property="og:type" content="blog">
<meta property="og:title" content="Alan Hou的个人博客">
<meta property="og:url" content="https://alanhou.github.io/index.html">
<meta property="og:site_name" content="Alan Hou的个人博客">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Alan Hou">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://alanhou.github.io/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"en","comments":"","permalink":"","path":"index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Alan Hou的个人博客</title>
  
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-53450398-1"></script>
  <script class="next-config" data-name="google_analytics" type="application/json">{"tracking_id":"UA-53450398-1","only_pageview":false}</script>
  <script src="/js/third-party/analytics/google-analytics.js"></script>

  <script src="/js/third-party/analytics/baidu-analytics.js"></script>
  <script async src="https://hm.baidu.com/hm.js?c6d32d47881743b193f462b65f69d37f"></script>







  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Alan Hou的个人博客</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">用行动赢得尊重</p>
      <img class="custom-logo-image" src="/images/logo.png" alt="Alan Hou的个人博客">
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="Search" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a></li><li class="menu-item menu-item-odoo"><a href="/tags/Odoo/" rel="section"><i class="fa-solid fa-o fa-fw"></i>Odoo</a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Alan Hou</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">19</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://alanhou.github.io/2023/02/08/http-load-balancing-with-ingress/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Alan Hou">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Alan Hou的个人博客">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Alan Hou的个人博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/02/08/http-load-balancing-with-ingress/" class="post-title-link" itemprop="url">云原生系列Kubernetes篇 使用 Ingress 做 HTTP 负载均衡</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2023-02-08 00:00:00 / Modified: 18:49:34" itemprop="dateCreated datePublished" datetime="2023-02-08T00:00:00+08:00">2023-02-08</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>本文来自正在规划的<a target="_blank" rel="noopener" href="https://alanhou.org/go-cloudnative/">Go语言&amp;云原生自我提升系列</a>，欢迎关注后续文章。</p>
<p>一个应用很重要的部分是网络流量的来来回回。<a target="_blank" rel="noopener" href="https://alanhou.org/service-discovery/">服务发现</a>一章中提到，Kubernetes拥有一些能力可让服务暴露到集群之外。对于很多用户的简单用例，这种能力足够用了。</p>
<p>但服务对象在OSI模型的第4层操作。也就是说它只转发TCP和UDP连接，不会深入到连接内部。因此，在集群上托管多个应用使用多个不同的对外暴露的服务。在服务为<code>NodePort</code>类型时，需要让客户端连接到各个服务的具体端口。而在服务类型为<code>LoadBalancer</code>时，要为每个服务分配云资源（通常昂贵或稀少）。但对HTTP（7层）服务，则有更好的方案。</p>
<p>在非Kubernetes场景下解决这类问题，人们常常会想到“虚拟主机”。通过这种机制可以在单IP上托管多个HTTP站点。通常会使用到负载均衡或反射代理在HTTP (80) 和 HTTPS (443)端口上接收进入的网络连接。然后程序会解析HTTP连接，根据请求的<code>Host</code>头和URL路径，将HTTP调用代理至其它程序。这样，负载均衡或反向代理将流量转发去解码或将进入的连接转发到正确upstream服务端。</p>
<p>Kubernetes将其HTTP负载均衡系统称为<em>Ingress</em>。Ingress是Kubernetes中刚刚讨论到的“虚拟主机”的原生实现方式。这种方式更复杂的方面是用户需要管理负载均衡配置文件。对于动态环境，随机虚拟主机的扩充，就会变得很复杂。Kubernetes Ingress系统对其简化的方式有：(a)标准化配置，(b) 将其迁移至Kubernetes对象中，(c) 将多个Ingress对象合并至单个负载均衡配置中。</p>
<p>典型的软件实现如图8-1所示。Ingress控制器是一个由两部分组成的软件系统。第一部分是Ingress代理，使用<code>LoadBalancer</code>类型服务对集群外暴露。这一代码将请求发送给上游服务端。另一个组件是Ingress协调器（reconciler）或operator。Ingress operator负责读取和监控Kubernetes API中的Ingress对象，以及重新配置Ingress代理按Ingress资源所指定的方式路由流量。有多种不同的Ingress实现。其中一些这两个组件位于单个容器中，另一些不同的组件单独部署在Kubernetes集群中。图8-1为Ingress控制器的一个示例。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8774710ace9c48208bf2b7aaa0775a5f~tplv-k3u1fbpfcp-zoom-1.image" alt="图8-1 典型软件的Ingress控制器配置"></p>
<p>图8-1 典型软件的Ingress控制器配置</p>
<h2 id="Ingress规范与Ingress控制器"><a href="#Ingress规范与Ingress控制器" class="headerlink" title="Ingress规范与Ingress控制器"></a>Ingress规范与Ingress控制器</h2><p>虽然概念上不复杂，但在实现层面Ingress与Kubernetes中的其它常规资源对象均不同。尤其是它拆分为了普通资源规范和控制器实现。Kubernetes中没有内置“标准”的Ingress控制器，因而用户需要从多种可选实现中选择一种。</p>
<p>用户可以像其它对象一样创建和修改Ingress对象。但默认没有运行的代码在实际作用于这些对象。由用户（或他们使用的发行版）安装、管理外部控制器。这样控制器才是可插拔的。</p>
<p>Ingress最终这样实现是有一些原因的。首先，没存在可以到处使用的某一个HTTP负载均衡。除了大量的软件负载均衡（开源与自主研发的），还有一些由云厂商提供的负载均衡服务（如AWS的ELB），以及硬件负载均衡。另一个原因是Ingress对象在Kubernetes中添加其它通用扩展能力（参见<a target="_blank" rel="noopener" href="https://alanhou.org/extending-kubernetes/">扩展Kubernetes</a>一章）之前就已经存在了。随着Ingress的发展，很可能会演进到使用这些机制。</p>
<h2 id="安装Contour"><a href="#安装Contour" class="headerlink" title="安装Contour"></a>安装Contour</h2><p>存在很多种Ingress控制器，比如这里我们使用的Ingress控制器为Contour。它是一个用于配置开源负载均衡Envoy（CNCF项目）的控制器。Envoy用于动态通过API进行配置。Contour Ingress控制器将Ingress对象翻译成Envoy可以理解的内容。</p>
<p>注：<a target="_blank" rel="noopener" href="https://github.com/projectcontour/contour">Contour项目</a>由Heptio与真实客户共同创建，已在生产中进行使用，但它现在是一个独立开源项目。</p>
<p>可通过一行命令安装Contour：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl apply -f https://projectcontour.io/quickstart/contour.yaml</span><br></pre></td></tr></table></figure>

<p>注意这条命令要求执行的用户具有<code>cluster-admin</code>权限。</p>
<p>对于大部分配置都可以使用这条命令。它会创建一个名为<code>projectcontour</code>的命名空间。在命名空间内创建一个部署（两个副本）以及一个对外的<code>LoadBalancer</code>服务。此外它会通过服务配置正确的权限并为一些在<strong>Ingress展望</strong>一节中讨论的扩展能力安装CustomResourceDefinition（参见<a target="_blank" rel="noopener" href="https://alanhou.org/extending-kubernetes/">扩展Kubernetes</a>一章）。</p>
<p>因其是全局安装，需要保证在所安装的集群上具备管理员权限。安装完成后，可通过如下命令获取Contour的外部地址：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$  kubectl get -n projectcontour service envoy -o wide</span><br><span class="line">NAME      CLUSTER-IP     EXTERNAL-IP          PORT(S)      ...</span><br><span class="line">contour   10.106.53.14   a477...amazonaws.com 80:30274/TCP ...</span><br></pre></td></tr></table></figure>

<p>查看<code>EXTERNAL-IP</code>一列。它可能是IP地址（GCP和Azure）或主机名（AWS）。其它云或环境可能会不同。如果你的Kubernetes集群不支持<code>LoadBalancer</code>类型服务，则需要在安装Contour时修改YAML为<code>type: NodePort</code>，将流量通过你的配置所接受的机制路由到集群上的机器。</p>
<p>如果使用的是<code>minikube</code>，在<code>EXTERNAL-IP</code>一列可能不会显示内容。要解决这一问题，需要单独打开一个终端窗口，运行<code>minikube tunnel</code>。这会配置网络路由，为每个<code>type: LoadBalancer</code>的服务分配一个独立 IP。</p>
<h3 id="配置DNS"><a href="#配置DNS" class="headerlink" title="配置DNS"></a>配置DNS</h3><p>要让Ingress很好地运行，需要为负载均衡配置指向外部地址的DNS。可以将多个主机名映射到单个外部端点，Ingress控制器会将进入的请求根据主机名转发到相应在的上游服务。</p>
<p>本章中我们假设你有一个域名<code>example.com</code>，需要配置两条DNS：<code>alpaca.example.com</code>和<code>bandicoot.example.com</code>。如果对外负载均衡有IP地址，应创建A记录。如果所持有的是主机名，应配置CNAME记录。</p>
<p><a target="_blank" rel="noopener" href="https://github.com/kubernetes-sigs/external-dns">ExternalDNS项目</a>是一个用于代你管理DNS记录的集群插件。ExternalDNS监控Kubernetes集群并将Kubernetes服务资源的IP地址同步给外部DNS服务商。ExternalDNS支持很多种DNS服务商，包含传统的域名提供商和公有云服务商。</p>
<h3 id="配置本地host文件"><a href="#配置本地host文件" class="headerlink" title="配置本地host文件"></a>配置本地host文件</h3><p>如果没有域名或者是使用的本地解决方案，如<code>minikube</code>，可以通过编辑 <em>&#x2F;etc&#x2F;hosts</em>文件添加IP地址来完成本地配置。这需要具备主机的admin&#x2F;root权限。不同平台文件位置也不同，使用修改生效可能也需要做额外操作。例如，Windows上通常位于<em>C:\Windows\System32\drivers\etc\hosts</em>，而在最近版本的macOS上，需要运行<code>sudo killall -HUP mDNSResponder</code>来使修改生效。</p>
<p>编辑该文件添加如下内容：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;ip-address&gt; alpaca.example.com bandicoot.example.com</span><br></pre></td></tr></table></figure>

<p>有关<code>&lt;ip-address&gt;</code>，请使用Contour的对外IP地址。如果只有主机名（如AWS），可通过执行<code>host -t a &lt;address&gt; </code>来获取IP地址（未来可能会发生改变）。</p>
<p>在完成测试后别忘了取消这些修改。</p>
<h2 id="使用Ingress"><a href="#使用Ingress" class="headerlink" title="使用Ingress"></a>使用Ingress</h2><p>现在我们已经配置好了Ingress控制器，我们就开始使用它吧。首先，通过如下命令创建一些上游（有时也称为后端）服务以供使用：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl create deployment be-default \</span><br><span class="line">  --image=gcr.io/kuar-demo/kuard-amd64:blue \</span><br><span class="line">  --replicas=3 \</span><br><span class="line">  --port=8080</span><br><span class="line">$ kubectl expose deployment be-default</span><br><span class="line">$ kubectl create deployment alpaca \</span><br><span class="line">  --image=gcr.io/kuar-demo/kuard-amd64:green \</span><br><span class="line">  --replicas=3 \</span><br><span class="line">  --port=8080</span><br><span class="line">$ kubectl expose deployment alpaca</span><br><span class="line">$ kubectl create deployment bandicoot \</span><br><span class="line">  --image=gcr.io/kuar-demo/kuard-amd64:purple \</span><br><span class="line">  --replicas=3 \</span><br><span class="line">  --port=8080</span><br><span class="line">$ kubectl expose deployment bandicoot</span><br><span class="line">$ kubectl get services -o wide</span><br><span class="line"></span><br><span class="line">NAME             CLUSTER-IP    ... PORT(S)  ... SELECTOR</span><br><span class="line">alpaca           10.115.245.13 ... 8080/TCP ... run=alpaca</span><br><span class="line">bandicoot        10.115.242.3  ... 8080/TCP ... run=bandicoot</span><br><span class="line">be-default       10.115.246.6  ... 8080/TCP ... run=be-default</span><br><span class="line">kubernetes       10.115.240.1  ... 443/TCP  ... &lt;none&gt;</span><br></pre></td></tr></table></figure>

<h3 id="最简单的用法"><a href="#最简单的用法" class="headerlink" title="最简单的用法"></a>最简单的用法</h3><p>使用Ingress最简单的用法是将其获得的所有内容盲传给上游服务。<code>kubectl</code>中对Ingress的操作命令支持有限，所以我们使用YAML文件（见例8-1）。</p>
<p>例8-1 simple-ingress.yaml</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: networking.k8s.io/v1</span><br><span class="line">kind: Ingress</span><br><span class="line">metadata:</span><br><span class="line">  name: simple-ingress</span><br><span class="line">spec:</span><br><span class="line">  defaultBackend:</span><br><span class="line">    service:</span><br><span class="line">      name: alpaca</span><br><span class="line">      port:</span><br><span class="line">        number: 8080</span><br></pre></td></tr></table></figure>

<p>通过<code>kubectl apply</code>创建这个Ingress：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl apply -f simple-ingress.yaml</span><br><span class="line">ingress.extensions/simple-ingress created</span><br></pre></td></tr></table></figure>

<p>可通过<code>kubectl get</code>和<code>kubectl describe</code>验证配置是否正确：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get ingress</span><br><span class="line">NAME             HOSTS   ADDRESS   PORTS   AGE</span><br><span class="line">simple-ingress   *                 80      13m</span><br><span class="line"></span><br><span class="line">$ kubectl describe ingress simple-ingress</span><br><span class="line">Name:             simple-ingress</span><br><span class="line">Namespace:        default</span><br><span class="line">Address:</span><br><span class="line">Default backend:  alpaca:8080</span><br><span class="line">(172.17.0.6:8080,172.17.0.7:8080,172.17.0.8:8080)</span><br><span class="line">Rules:</span><br><span class="line">  Host  Path  Backends</span><br><span class="line">  ----  ----  --------</span><br><span class="line">  *     *     alpaca:8080 (172.17.0.6:8080,172.17.0.7:8080,172.17.0.8:8080)</span><br><span class="line">Annotations:</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">Events:  &lt;none&gt;</span><br></pre></td></tr></table></figure>

<p>这样配置后任何发往Ingress控制器的HTTP请求都会被转发给<code>alpaca</code>服务。现在可以通过服务的任何一个IP&#x2F;CNAME访问<code>kuard</code>的<code>alpaca</code>实例，在本例中即为<code>alpaca.example.com</code>或<code>bandicoot.example.com</code>。现在<code>type: LoadBalancer</code>服务还没体现出多少价值。下一节中会探索更复杂的配置。</p>
<h3 id="使用主机名"><a href="#使用主机名" class="headerlink" title="使用主机名"></a>使用主机名</h3><p>将流量根据请求的属性进行转发时就开始变得有趣了。最常见的例子是让Ingress系统查看HTTP主机头（在原URL中设置为DNS域名），将流量根据头进行转发。我们再添加一个Ingress对象用于将指向<code>alpaca.example.com</code>的流量转发给<code>alpaca</code>服务（见例8-2）。</p>
<p>例8-2 host-ingress.yaml</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: networking.k8s.io/v1</span><br><span class="line">kind: Ingress</span><br><span class="line">metadata:</span><br><span class="line">  name: host-ingress</span><br><span class="line">spec:</span><br><span class="line">  defaultBackend:</span><br><span class="line">    service:</span><br><span class="line">      name: be-default</span><br><span class="line">      port:</span><br><span class="line">        number: 8080</span><br><span class="line">  rules:</span><br><span class="line">  - host: alpaca.example.com</span><br><span class="line">    http:</span><br><span class="line">      paths:</span><br><span class="line">      - pathType: Prefix</span><br><span class="line">        path: /</span><br><span class="line">        backend:</span><br><span class="line">          service:</span><br><span class="line">            name: alpaca</span><br><span class="line">            port:</span><br><span class="line">              number: 8080</span><br></pre></td></tr></table></figure>

<p>通过<code>kubectl apply</code>创建这一Ingress：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl apply -f host-ingress.yaml</span><br><span class="line">ingress.extensions/host-ingress created</span><br></pre></td></tr></table></figure>

<p>通过如下命令验证配置是否正确：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get ingress</span><br><span class="line">NAME             HOSTS               ADDRESS   PORTS   AGE</span><br><span class="line">host-ingress     alpaca.example.com            80      54s</span><br><span class="line">simple-ingress   *                             80      13m</span><br><span class="line"></span><br><span class="line">$ kubectl describe ingress host-ingress</span><br><span class="line">Name:             host-ingress</span><br><span class="line">Namespace:        default</span><br><span class="line">Address:</span><br><span class="line">Default backend:  be-default:8080 (&lt;none&gt;)</span><br><span class="line">Rules:</span><br><span class="line">  Host                Path  Backends</span><br><span class="line">  ----                ----  --------</span><br><span class="line">  alpaca.example.com</span><br><span class="line">                      /   alpaca:8080 (&lt;none&gt;)</span><br><span class="line">Annotations:</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">Events:  &lt;none&gt;</span><br></pre></td></tr></table></figure>

<p>有一些会产生困扰的事。首先，涉及到了<code>default-http-backend</code>。这是一种部分Ingress控制器在没有其它方式时用于处理请求的惯例。这些控制器将请求发送给<code>kube-system</code>命名空间中名为<code>default-http-backend</code>的服务。这一惯例见于<code>kubectl</code>的客户端。其次是<code>alpaca</code>后端服务没有列出端点。这个<code>kubectl</code>的bug 在Kubernetes v1.14中得以修复。</p>
<p>不管怎么说，现在可以通过<a target="_blank" rel="noopener" href="http://alpaca.example.com/">http://alpaca.example.com</a> 来访问<code>alpaca</code>服务了。如果通过其它访问访问服务端点，会获取到默认服务。</p>
<h3 id="使用路径"><a href="#使用路径" class="headerlink" title="使用路径"></a>使用路径</h3><p>另一个有趣的场景是流量转发不仅依赖于主机名，也可取决于HTTP请求的路径。我们可以在<code>paths</code>中指定路径来轻松实现（见例8-3）。本例中，我们将所有来自<a target="_blank" rel="noopener" href="http://bandicoot.example.com/">http://bandicoot.example.com</a> 的流量转发给<code>bandicoot</code>服务，但将<a target="_blank" rel="noopener" href="http://bandicoot.example.com/a">http://bandicoot.example.com/a</a> 的服务发送给<code>alpaca</code>服务。这一场景可用于在同一域名的不路径上托管多个服务。</p>
<p>例8-3 path-ingress.yaml</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: networking.k8s.io/v1</span><br><span class="line">kind: Ingress</span><br><span class="line">metadata:</span><br><span class="line">  name: path-ingress</span><br><span class="line">spec:</span><br><span class="line">  rules:</span><br><span class="line">  - host: bandicoot.example.com</span><br><span class="line">    http:</span><br><span class="line">      paths:</span><br><span class="line">      - pathType: Prefix</span><br><span class="line">        path: &quot;/&quot;</span><br><span class="line">        backend:</span><br><span class="line">          service:</span><br><span class="line">            name: bandicoot</span><br><span class="line">            port:</span><br><span class="line">              number: 8080</span><br><span class="line">      - pathType: Prefix</span><br><span class="line">        path: &quot;/a/&quot;</span><br><span class="line">        backend:</span><br><span class="line">          service:</span><br><span class="line">            name: alpaca</span><br><span class="line">            port:</span><br><span class="line">              number: 8080</span><br></pre></td></tr></table></figure>

<p>在同一主机有多个路径位于Ingress系统中时，匹配最长前缀。因此，本例中，以<code>/a/</code>开头的流量会被转发给<code>alpaca</code>服务，而其它的所有流量（以<code>/</code>开头）都会转发到<code>bandicoot</code>服务。</p>
<p>在请求被代理到上游服务时，路径保持不变。也就是<code>bandicoot.example.com/a/</code>请求显示所配置请求主机名和路径的上游服务。上游服务在接收该子路径的流量时要处于就绪状态。<code>kuard</code>有一些特别的测试代码，它使用预定义的子路径(<code>/a/</code>、<code>/b/</code>和<code>/c/</code>)和根路径(<code>/</code>)一起提供响应。</p>
<h3 id="清理"><a href="#清理" class="headerlink" title="清理"></a>清理</h3><p>执行如下命令完成清理：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl delete ingress host-ingress path-ingress simple-ingress</span><br><span class="line">$ kubectl delete service alpaca bandicoot be-default</span><br><span class="line">$ kubectl delete deployment alpaca bandicoot be-default</span><br></pre></td></tr></table></figure>

<h2 id="高级Ingress课题和技巧"><a href="#高级Ingress课题和技巧" class="headerlink" title="高级Ingress课题和技巧"></a>高级Ingress课题和技巧</h2><p>Ingress支持一些高级特性。对这些特性的支持根据Ingress控制器的实现不同而不同，并且不同控制器可能对同一特性的实现存在些许差别。</p>
<p>很多扩展我都通过对Ingress对象添加注解进行暴露。注意这些注解很难验证、容易出错。大部分注解应用于整个Ingress对象，因此可能比想象的更通用。要为这些注解添加作用域，可以将单个Ingress对象拆分为多个Ingress对象。Ingress控制器会进行读取及合并。</p>
<h3 id="运行多个Ingress控制器"><a href="#运行多个Ingress控制器" class="headerlink" title="运行多个Ingress控制器"></a>运行多个Ingress控制器</h3><p>有很多种Ingress控制器实现，你可能会想对单个集群运行多个Ingress控制器。处理这一状况，有IngressClass资源可让Ingress资源请求具体的实现。在创建Ingress资源时，使用<code>spec.ingressClassName</code>字段指定特定的Ingress资源。</p>
<p>注：Kubernetes 1.18版本之前，还不存在<code>IngressClassName</code>字段，使用的是<code>kubernetes.io/ingress.class</code>注解。虽然很多控制器仍支持它，推荐不要再使用这一注解，因未来很有可能会被控制器所弃用。</p>
<p>如不存在<code>spec.ingressClassName</code>注解，会使用默认Ingress控制器。通过对相应的IngressClass资源添加<code>ingressclass.kubernetes.io/is-default-class</code>注解来进行指定。</p>
<h3 id="多个Ingress对象"><a href="#多个Ingress对象" class="headerlink" title="多个Ingress对象"></a>多个Ingress对象</h3><p>如果指定了多个Ingress对象，Ingress控制器应全数读取并将它们合并为一个连续的配置。但如果指定的是重复或冲突的配置，结果就不一定了。不同Ingress控制器处理方式可能不同。即使是单个实现也可能因不易察觉的因素而出现不同。</p>
<h3 id="Ingress和命名空间"><a href="#Ingress和命名空间" class="headerlink" title="Ingress和命名空间"></a>Ingress和命名空间</h3><p>Ingress与命名空间的配合有些方式不那么明显。首先，由于大量的安全问题，Ingress对象仅能指向同一命名空间的一个上游服务。也就是说不能使用Ingress对象指向另一个命名空间的子路径服务。</p>
<p>但不同命名空间中的多个Ingress对象可指向同一主机上的子路径。这些Ingress对象会进行合并，组成Ingress控制器的最终配置。</p>
<p>跨命名空间的操作意味着跨集群全局协调Ingress是有必要的。如果不小心，一个命名空间中的Ingress可能会导致另一个命名空间出现问题（或不确定行为）。</p>
<p>通过Ingress控制器不限制允许哪些命名空间指定哪些主机名或路径。高阶用户可以尝试使用自定义的准许控制器强制实现这种策略。在<strong>Ingress展望</strong>一节中也会讲到处理这问题的一些Ingress演进。</p>
<h3 id="路径重写"><a href="#路径重写" class="headerlink" title="路径重写"></a>路径重写</h3><p>有些Ingress控制器实现可支持路径重写。可使用它来修改所代理的HTTP请求路径。通常用Ingress对象上的注解来指定，应用于所有该对象所指定的请求。例如，如果使用NGINX Ingress控制器，可以指定一个<code>nginx.ingress​.kuber⁠netes.io/rewrite-target: /</code>注解。这有时可让上游服务操作子路径，即使原本它不具备这种功能。</p>
<p>很多实现不仅是支持路径重写，还实现了用正则表达式指定路径。例如NGINX控制器允许使用正则表达式捕获路径的一部分，然后在重写时使用这部分捕获的内容。其实现方式（以使用哪种正则表达式模式）则在各实现中并不相同。</p>
<p>但路径重写并不是银弹，有时可能会产生bug。很多web应用都假定可使用绝对路径在内部进行链接。在这种情况下，托管在<code>/subpath</code>的应用可能会在请求<code>/</code>时出现。而接下来可能会将用户发往<code>/app-path</code>。这时就会存在它是该应用的内部链接（这里本应是<code>/subpath/app-path</code>）还是来自另一个应用。出于这一原因，对复杂应用但凡能避免请不要使用子路径。</p>
<h3 id="TLS-服务"><a href="#TLS-服务" class="headerlink" title="TLS 服务"></a>TLS 服务</h3><p>在为网站提供服务时，使用TLS和HTTPS来提升服务越来越有必要了。Ingress（及大部分Ingress控制器）提供了这一支持。</p>
<p>首先，用户需要指定TLS的证书文件和密钥（参见例8-4）。也可通过<code>kubectl create secret tls &lt;secret-name&gt; --cert &lt;certificate-pem-file&gt; --key &lt;private-key-pem-file&gt;</code>来创建一个密钥。</p>
<p>例8-4 tls-secret.yaml</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Secret</span><br><span class="line">metadata:</span><br><span class="line">  creationTimestamp: null</span><br><span class="line">  name: tls-secret-name</span><br><span class="line">type: kubernetes.io/tls</span><br><span class="line">data:</span><br><span class="line">  tls.crt: &lt;base64 encoded certificate&gt;</span><br><span class="line">  tls.key: &lt;base64 encoded private key&gt;</span><br></pre></td></tr></table></figure>

<p>上传好证书后，可以在Ingress对象中引用它。这会指定一系统证书以及证书所作用的主机名（参见例8-5）。同样如若多个Ingress对象为同一主机名指定证书，结果是不确定的。</p>
<p>例8-5 tls-ingress.yaml</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: networking.k8s.io/v1</span><br><span class="line">kind: Ingress</span><br><span class="line">metadata:</span><br><span class="line">  name: tls-ingress</span><br><span class="line">spec:</span><br><span class="line">  tls:</span><br><span class="line">  - hosts:</span><br><span class="line">    - alpaca.example.com</span><br><span class="line">    secretName: tls-secret-name</span><br><span class="line">  rules:</span><br><span class="line">  - host: alpaca.example.com</span><br><span class="line">    http:</span><br><span class="line">      paths:</span><br><span class="line">      - backend:</span><br><span class="line">          serviceName: alpaca</span><br><span class="line">          servicePort: 8080</span><br></pre></td></tr></table></figure>

<p>上传、管理TLS密钥并不简单。此外，证书有时会产生大量的费用。要解决这一问题，有一个非营利证书机构<a target="_blank" rel="noopener" href="https://letsencrypt.org/">Let’s Encrypt</a>可通过API进行操作。因其是API操作，可配置Kubernetes集群来自动获取并安装TLS证书。配置有些麻烦，但一旦生效，使用会很简单。剩下的部分有一家英国创业公司Jetstack创建了开源项目<a target="_blank" rel="noopener" href="https://cert-manager.io/">cert-manager</a>，已入驻CNCF。官网<em>cert-manager.io</em>或<a target="_blank" rel="noopener" href="https://github.com/cert-manager/cert-manager">GitHub仓库</a>上详细讲解了如何安装和使用cert-manager。</p>
<h2 id="其它Ingress实现"><a href="#其它Ingress实现" class="headerlink" title="其它Ingress实现"></a>其它Ingress实现</h2><p>有很多种Ingress控制器实现，都是基于Ingress基础对象添加了各种功能。这是一个非常活跃的生态。</p>
<p>首先，各云厂商有Ingress实现为其云暴露特定的7层负载均衡。这些控制器不是配置在Pod中运行的软件负载均衡，而是获取Ingress对象，使用它们通过API来配置云端负载均衡。这减少了集群的负载以及实施者的管理负担，但通常是收费的。</p>
<p>最常用的Ingress控制器可能是开源的<a target="_blank" rel="noopener" href="https://github.com/kubernetes/ingress-nginx">NGINX Ingress控制器</a>。也有基于收费的NGINX Plus的商业控制器。开源控制器基本上是读取Ingress对象，将它们合并到一个NGINX配置文件。然后发信号让NGINX进行使用新配置重启。开源的NGINX控制器有大量的特性和通过<a target="_blank" rel="noopener" href="https://kubernetes.github.io/ingress-nginx/user-guide/nginx-configuration/annotations/">注解</a>暴露的选项。</p>
<p><a target="_blank" rel="noopener" href="https://github.com/emissary-ingress/emissary">Emissary</a>和<a target="_blank" rel="noopener" href="https://github.com/solo-io/gloo">Gloo</a>是另外两个基于Envoy的Ingress控制器，主要聚焦于API网关领域。</p>
<p><a target="_blank" rel="noopener" href="https://traefik.io/">Traefik</a>是一个用Go实现的反向代理，也可用作Ingress控制器。它具有很多特性以及对开发者友好的控制面板。</p>
<p>这只是冰山一角。Ingress生态系统非常活跃，有很多基于Ingress对象提供各种功能的新项目和商业方案。</p>
<h2 id="Ingress展望"><a href="#Ingress展望" class="headerlink" title="Ingress展望"></a>Ingress展望</h2><p>我们已经学习到，Ingress对象对配置L7负载均衡提供了非常有用的抽象，但它并没有扩展用户需要的所有功能，各种控制器实现进行的补充。Ingress对很多这种特性定义不足。实现的方式八仙过海，这让在实现之间配置的可迁移性变差。</p>
<p>另一个问题是Ingress的配置很容易出错。多对象合并为不同实现采取不同方式处理冲突打开了大门。此外，跨命名空间的合并也打破了命名空间隔离的想法。</p>
<p>Ingress创建的时候还没出现服务网格（以Istio和Linkerd为代表）。Ingress和服务网格的交集仍在定义中。Service mesh在<a target="_blank" rel="noopener" href="https://alanhou.org/service-meshes/">服务网格</a>一章中会进行详细讲解。</p>
<p>Kubernetes未来的HTTP负载均衡应该是网关API，正由Kubernetes致力于网络的特别兴趣小组(SIG)进行开发。Gateway API项目意在开发一个在Kubernetes中路由的更现代的API。虽然更关注HTTP负载均衡，Gateway也包含了控制4层(TCP)负载均衡的资源。Gateway API的开发还远未成熟，因些强烈推荐大家继续使用Kubernetes中现有的Ingress和Service资源。Gateway API现在的进展请见<a target="_blank" rel="noopener" href="https://gateway-api.sigs.k8s.io/">官网</a>。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>Ingress是Kubernetes的一套特有系统。它只是一种模式，必须要安装这种模式的控制器实现并单独管理。但它是以实用且成本高效地向用户暴露服务的关键系统。Kubernetes还在不断成熟，Ingress也会不断发展。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://alanhou.github.io/2023/02/06/go-pointers/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Alan Hou">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Alan Hou的个人博客">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Alan Hou的个人博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/02/06/go-pointers/" class="post-title-link" itemprop="url">云原生系列Go语言篇-指针</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2023-02-06 00:00:00 / Modified: 18:15:53" itemprop="dateCreated datePublished" datetime="2023-02-06T00:00:00+08:00">2023-02-06</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>本文来自正在规划的<a target="_blank" rel="noopener" href="https://alanhou.org/go-cloudnative/">Go语言&amp;云原生自我提升系列</a>，欢迎关注后续文章。</p>
<p>我们已学习过变量和函数，下面来快速了解下指针的语法。然后我们通过将Go中的指针与其它语言中的类进行对比来讲清指针的原理。我们还会学习如何以及何时使用指针、Go中如何分配内存以及正确使用指针及值是如何使Go程序变得更快速、更高效的。</p>
<h2 id="指针快速入门"><a href="#指针快速入门" class="headerlink" title="指针快速入门"></a>指针快速入门</h2><p>指针其实就一个存储了值所在内存位置的变量。如果读者学过计算机课的话，可能见过表示内存中如何存储变量的图。如下的两个变量可表示为图6-1：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var x int32 = 10</span><br><span class="line">var y bool = true</span><br></pre></td></tr></table></figure>

<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/01375eb4fbf9442787caff68617eebd9~tplv-k3u1fbpfcp-zoom-1.image" alt="图6-1. 在内存中存储两个变量"></p>
<p>图6-1. 在内存中存储两个变量</p>
<p>每个变量都存储在一段或多段连续的内存中，称为内存地址。不同类型的变量所占的内存大小可能是不同的。本例中有两个变量<code>x</code>，它是一个32位的整型，以及布尔类型的<code>y</code>。存储32位的整型需要4个字节，因而<code>x</code>存储于4个字节中，从地址1到地址4。布尔类型只占一个字节（只需用一位来表示true或false，但独立寻址的内存大小是一个字节），因而<code>y</code>存储于地址5位的一个字节中，<code>true</code>通过1进行表示。</p>
<p>指针的内容就是存储了其它变量的地址 。图6-2演示了如何在内存中存储指针：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var x int32 = 10</span><br><span class="line">var y bool = true</span><br><span class="line">pointerX := &amp;x</span><br><span class="line">pointerY := &amp;y</span><br><span class="line">var pointerZ *string</span><br></pre></td></tr></table></figure>

<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9c493454bca24133888e73e1da688ea5~tplv-k3u1fbpfcp-zoom-1.image" alt="图6-2：在内存中存储指针"></p>
<p>图6-2：在内存中存储指针</p>
<p>虽然不同变量类型占用的内存空间不同，但不管是什么类型的指针都占据相同的大小：也即存储数据在内存中空间的字节数相同。<code>x</code>的指针<code>pointerX</code>存储在位置6，值为1，也即<code>x</code>的地址。类似地<code>y</code>的指针<code>pointerY</code>存储于位置10，值为5，即为<code>y</code>的地址。最后一个变量<code>pointerZ</code>，存储于位置14，值为0，因为它没有指向任何变量。</p>
<p>指针的零值为<code>nil</code>。前面的文章中已经多次使用到了<code>nil</code>，用作切片、字典和函数的零值。所有这些类型都通过指针实现。（还有两种类型，通道和接口，也是用接口实现。我们会在<a target="_blank" rel="noopener" href="https://alanhou.org/types-methods-and-interfaces/">类型、方法和接口</a>一章的快速讲解接口以及<a target="_blank" rel="noopener" href="https://alanhou.org/concurrency-in-go/">并发</a>一章中进行讲解）。在<a target="_blank" rel="noopener" href="https://alanhou.org/composite-types/">复合类型</a>一章中，<code>nil</code>是表示缺少值的某种类型的无类型标识符。与C语言中的<code>NULL</code>不同，<code>nil</code>不是0的别名，它与数字间不可互转。</p>
<p>警告：在<a target="_blank" rel="noopener" href="http://alanhou.org/blocks-shadows-and-control-structures">代码块，遮蔽和控制结构</a>一章中提到，<code>nil</code>定义于全局代码块中。因其是在全局代码块中定义，可能会被遮蔽。不要将变量或函数命名为<code>nil</code>，除非你是和同事恶作剧，或是完全不care年终评审。</p>
<p>Go指针的语法部分来自C和C++。因Go自带垃圾回收器，大部分内存管理的痛楚都不存在了。此外，C和C++中一些指针黑活，包括指针运算，在Go语言中都不再允许。</p>
<p>注：Go标准库中有一个<code>unsafe</code>包，可对数据结构执行一些底层运算。虽然在C中操作指针是常见运算，但Go开发者极少使用<code>unsafe</code>。在<a target="_blank" rel="noopener" href="https://alanhou.org/reflect-unsafe-cgo/">恶龙三剑客：反射、Unsafe 和 Cgo</a>一章中会进行讲解。</p>
<p><code>&amp;</code>是地址运算符。放在值类型的前面用于返回所存储值的内存地址：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x := &quot;hello&quot;</span><br><span class="line">pointerToX := &amp;x</span><br></pre></td></tr></table></figure>

<p><code>*</code>为间接运算符。放在指针类型的变量前可返回其所指向的值。这称为解引用：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">x := 10</span><br><span class="line">pointerToX := &amp;x</span><br><span class="line">fmt.Println(pointerToX)  // 打印内存地址</span><br><span class="line">fmt.Println(*pointerToX) // 打印10</span><br><span class="line">z := 5 + *pointerToX</span><br><span class="line">fmt.Println(z)           // 打印15</span><br></pre></td></tr></table></figure>

<p>在对指针解引用之前，必须确保指针不为nil。对<code>nil</code>指针解引用会崩溃（panic）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var x *int</span><br><span class="line">fmt.Println(x == nil) // 打印true</span><br><span class="line">fmt.Println(*x)       // 程序崩溃</span><br></pre></td></tr></table></figure>

<p>指针类型是用于表示指针的类型。写法为在类型名前加<code>*</code>。指针类型可基于任意类型：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x := 10</span><br><span class="line">var pointerToX *int</span><br><span class="line">pointerToX = &amp;x</span><br></pre></td></tr></table></figure>

<p>内置函数<code>new</code>可创建指针变量。它返回指定类型零值实例的指针：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var x = new(int)</span><br><span class="line">fmt.Println(x == nil) // 打印false</span><br><span class="line">fmt.Println(*x)       // 打印0</span><br></pre></td></tr></table></figure>

<p>较少使用<code>new</code>函数。对于结构体，可在结构体字面量前加<code>&amp;</code>创建指针实例。不能在原生类型字面量（数字、布尔值和字符串）或常量前加<code>&amp;</code>，因为它们没有内存地址，仅在编译时存在。要用原生类型的指针时，声明一个变量指向它：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x := &amp;Foo&#123;&#125;</span><br><span class="line">var y string</span><br><span class="line">z := &amp;y</span><br></pre></td></tr></table></figure>

<p>不能获取常的地址有时会带来不便。结构体中包含原生类型指针字段时，就无法直接对字段赋字面量：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">type person struct &#123;</span><br><span class="line">    FirstName  string</span><br><span class="line">    MiddleName *string</span><br><span class="line">    LastName   string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">p := person&#123;</span><br><span class="line">  FirstName:  &quot;Pat&quot;,</span><br><span class="line">  MiddleName: &quot;Perry&quot;, // 该行无法通过编译</span><br><span class="line">  LastName:   &quot;Peterson&quot;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译这段代码返回如下错误：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cannot use &quot;Perry&quot; (type string) as type *string in field value</span><br></pre></td></tr></table></figure>

<p>倘若在<code>&quot;Perry&quot;</code>前添加<code>&amp;</code>，会报如下错误：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cannot take the address of &quot;Perry&quot;</span><br></pre></td></tr></table></figure>

<p>解决这个问题有两种方法。第一种上面讲到了，引入一个存储常量值的变量。第二种是编译一个接收布尔值、数值或字符串并返回该类型指针的帮助函数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func stringp(s string) *string &#123;</span><br><span class="line">    return &amp;s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>借助这个函数，可以改写成这样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">p := person&#123;</span><br><span class="line">  FirstName:  &quot;Pat&quot;,</span><br><span class="line">  MiddleName: stringp(&quot;Perry&quot;), // 正常运行</span><br><span class="line">  LastName:   &quot;Peterson&quot;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为什么这样就正常了呢？对函数传递常量时，会将常量拷贝到参数变量。因其是一个变量，就在内存中有一段地址。然后这个函数会返回变量的内存地址。</p>
<p>小贴士：帮助函数会将常量值转化为指针。</p>
<h2 id="不要畏惧指针"><a href="#不要畏惧指针" class="headerlink" title="不要畏惧指针"></a>不要畏惧指针</h2><p>学习指针的第一条就是不要畏惧。读者如果习惯了使用Java、JavaScript、Python或Ruby，可能会觉得指针很可怕。但指针其实和读者所熟知的类相似。Go语言中非指针结构体才是异类。</p>
<p>在Java和JavaScript中，原生类型和类不同（Python和Ruby中并没有原始值，而是使用不可变实例来进行模拟）。在将原始值赋给另一个变量或传递给函数或方法时，另一个变量对值的修改不会体现在原变量中，见例6-1。</p>
<p>例6-1 Java中原始变量赋值不共享内存</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int x = 10;</span><br><span class="line">int y = x;</span><br><span class="line">y = 20;</span><br><span class="line">System.out.println(x); // 打印10</span><br></pre></td></tr></table></figure>

<p>我们再来看将类实例赋值给另一个变量或传递给函数或方法的情况（例6-2使用Python编写，Java、JavaScript和Ruby中相应的代码参见<a target="_blank" rel="noopener" href="https://github.com/learning-go-book/language_pointer_examples">GitHub</a>）。</p>
<p>例6-2 将类实例传递给函数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class Foo:</span><br><span class="line">    def __init__(self, x):</span><br><span class="line">        self.x = x</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def outer():</span><br><span class="line">    f = Foo(10)</span><br><span class="line">    inner1(f)</span><br><span class="line">    print(f.x)</span><br><span class="line">    inner2(f)</span><br><span class="line">    print(f.x)</span><br><span class="line">    g = None</span><br><span class="line">    inner2(g)</span><br><span class="line">    print(g is None)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def inner1(f):</span><br><span class="line">    f.x = 20</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def inner2(f):</span><br><span class="line">    f = Foo(30)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">outer()</span><br></pre></td></tr></table></figure>

<p>运行这段代码会打印：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">20</span><br><span class="line">20</span><br><span class="line">True</span><br></pre></td></tr></table></figure>

<p>这是由于Java、Python、JavaScript和Ruby具有如下特征：</p>
<ul>
<li>如果对函数传递类的实例且修改其字段值，修改会作用于所传递的变量。</li>
<li>如重新赋值参数，修改不会作用于所传入的变量。</li>
<li>如使用<code>nil/null/None</code>传递参数值，将参数设为其它值不会修改调用函数中的变量。</li>
</ul>
<p>有人在讲解这一行为时，会说这些语言中类实例通过指针传递。这是不对的。如果真是通过指针传递，第二、三种情况会修改调用函数中的变量。这些语言和Go一样都是值传递。</p>
<p>这里看到各种编程语言中的类实例使用指针实现。在将类实例传入函数或方法时，所拷贝的值是实例的指针。因<code>outer</code>和<code>inner1</code>指向相同的内存，<code>inner1</code>中对<code>f</code>的修改会体现在<code>outer</code>的变量中。在<code>inner2</code>对<code>f</code>赋一个新的类实例时，会单独创建一个实例且不会影响到<code>outer</code>中的变量。</p>
<p>在Go语言中使用指针变量效果相同。Go与其它语言的差别是可以选择使用原生类型和结构体的指针或是值。大部分情况下应使用值。这会更容易理解数据是在何时以及如何发行修改的。使用值的另一个好处是用值会减少垃圾回收器的工作量。在<strong>降低垃圾回收器的工作量</strong>一节中会再做讨论。</p>
<h2 id="指针表明参数可变"><a href="#指针表明参数可变" class="headerlink" title="指针表明参数可变"></a>指针表明参数可变</h2><p>我们已经知道，Go常量可对字面量表达式添加名称并在运行时进行计算。语言中没有其它声明不可变量值的机制。现在软件工程包含不可变量性。MIT的<a target="_blank" rel="noopener" href="http://web.mit.edu/6.031/www/fa20/classes/08-immutability/">Software Construction课程</a>总结原因为：“不可变量类型不易产生 bug，更易于掌握，也更能应对变化。可变性会使用理解程序变难，强制合约则更难。”</p>
<p>Go语言中不可变声明的匮乏看起来是个问题，但通过允许选择值和指针参数类型解决了这一问题。在<strong>软件构造</strong>的课程资料中讲到：“如果仅在方法内部使用可变量对象且对向的引用唯一就没有问题。”Go开发者不是将部分变量和参数声明为不可变，而是通过使用指针来表示参数可变。</p>
<p>因Go一种值传递的编程语言，传入函数的值是一份拷贝。对于原生类型、结构体和数组等非指针类型，这意味着调用函数无法修改其原始值。而调用函数中为原始数据的拷贝，进而保障了原始数据的不可变性。</p>
<p>注：我们会在<strong>字典和切片的区别</strong>一节中讨论对函数传递字典和切片。</p>
<p>但如果将指针传递给函数的话，函数会得到指针的拷贝。它仍会指向原数据，也就意味着调用函数可修改原数据。</p>
<p>这里有两种潜在情况。</p>
<p>第一是如果将<code>nil</code>指针传递给函数，无法将值变为非空。只能对已赋值的指针重新赋值。乍一听让人困扰，但是有道理的。因内容空间是通过值传递传给函数的，我们无法改变其内存地址，就像我们不能修改<code>int</code>参数值一样。可通过如下程序进行演示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">func failedUpdate(g *int) &#123;</span><br><span class="line">    x := 10</span><br><span class="line">    g = &amp;x</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    var f *int // f为nil</span><br><span class="line">    failedUpdate(f)</span><br><span class="line">    fmt.Println(f) // 打印nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码运行的流程见图6-3。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/421176f1f1f847998dfd76c455ac1196~tplv-k3u1fbpfcp-zoom-1.image" alt="图6-3 无法更新nil指针"><br>图6-3 无法更新<code>nil</code>指针<br>刚开始<code>main</code>中的<code>f</code>是一个<code>nil</code>变量。调用<code>failedUpdate</code>后，我们将<code>f</code>的值，也就是<code>nil</code>，拷贝到参数<code>g</code>中。也就是说<code>g</code>被设置成了<code>nil</code>。然后在<code>failedUpdate</code>中声明了一个变量<code>x</code>，值为10。接着修改<code>failedUpdate</code>中的<code>g</code>指向<code>x</code>。这不会修改<code>main</code>中的<code>f</code>，在退出<code>failedUpdate</code>并返回<code>main</code>时，<code>f</code>仍为<code>nil</code>。</p>
<p>第二种情况是在退出函数时希望赋值给指针参数的值依然存在，就必须解引用指针并设置值。修改指针改变的是其拷贝而非原始指针。解引用会将新值放入原始指针和拷贝指针共同指向的内存空间。下面是一段简短演示程序：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">func failedUpdate(px *int) &#123;</span><br><span class="line">    x2 := 20</span><br><span class="line">    px = &amp;x2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func update(px *int) &#123;</span><br><span class="line">    *px = 20</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    x := 10</span><br><span class="line">    failedUpdate(&amp;x)</span><br><span class="line">    fmt.Println(x) // 打印10</span><br><span class="line">    update(&amp;x)</span><br><span class="line">    fmt.Println(x) // 打印20</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其流程见图6-4。</p>
<p>在这个例子中，我们先将<code>main</code>中的<code>x</code>设置为10。调用<code>failedUpdate</code>时，我们将<code>x</code>的地址拷入参数<code>px</code>。然后，我们在<code>failedUpdate</code>中声明了<code>x2</code>，设置为20。接着将<code>failedUpdate</code>中的<code>px</code>指向<code>x2</code>的地址。在返回<code>main</code>时，<code>x</code>的值未发生改变。在调用<code>update</code>时，我们再次将<code>x</code>的地址拷入参数<code>px</code>。但这次修改的是<code>update</code>中<code>px</code>所指向的值，也即<code>main</code>中的变量<code>x</code>。返回<code>main</code>时<code>x</code>发生了改变。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0208cd03027e4392a363ab1fe1497ddc~tplv-k3u1fbpfcp-zoom-1.image" alt="图6-4 更新指针的错误方式和正确方式"><br>图6-4 更新指针的错误方式和正确方式</p>
<h2 id="指针非首选"><a href="#指针非首选" class="headerlink" title="指针非首选"></a>指针非首选</h2><p>在Go中使用指针应谨慎。前面也讨论过，那样会更难理解数据流并会给垃圾回收器带来额外的工作。可以将传入函数的结构体指针改成让函数实例化并返回结构体（参见例6-3和例6-4）。</p>
<p>例6-3 别这么干</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">func MakeFoo(f *Foo) error &#123;</span><br><span class="line">  f.Field1 = &quot;val&quot;</span><br><span class="line">  f.Field2 = 20</span><br><span class="line">  return nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>例6-4 应当这么干</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">func MakeFoo() (Foo, error) &#123;</span><br><span class="line">  f := Foo&#123;</span><br><span class="line">    Field1: &quot;val&quot;,</span><br><span class="line">    Field2: 20,</span><br><span class="line">  &#125;</span><br><span class="line">  return f, nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用指针参数修改变量的唯一场景是在函数接收接口时。在操作JSON时会看到这种用法（在讲解Go的<a target="_blank" rel="noopener" href="https://alanhou.org/standard-library/">标准库</a>时会说到encoding&#x2F;json对JSON的支持）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">f := struct &#123;</span><br><span class="line">  Name string `json:&quot;name&quot;`</span><br><span class="line">  Age int `json:&quot;age&quot;`</span><br><span class="line">&#125;&#123;&#125;</span><br><span class="line">err := json.Unmarshal([]byte(`&#123;&quot;name&quot;: &quot;Bob&quot;, &quot;age&quot;: 30&#125;`), &amp;f)</span><br></pre></td></tr></table></figure>

<p><code>Unmarshal</code>函数使用JSON字节对切片变量赋值。该函数接收字节切片和<code>interface&#123;&#125;</code>参数。传给<code>interface&#123;&#125;</code>参数的值必须为指针。如若不是，则会报错。这种用法是因为最早Go中没有泛型。这也就导致了根据传入类型指向反序列化的方式不方便，并且无法动态地按传入函数的类型指定返回类型。</p>
<p>而JSON的集成非常广泛，有时Go开发者便将这一API看作常规操作，而非什么特例。</p>
<p>注：通过使用<code>reflect</code>包中的<code>Type</code>类型可以用变量表示类型。<code>reflect</code>包预留在没有其它方法的场景中使用。在<a target="_blank" rel="noopener" href="https://alanhou.org/reflect-unsafe-cgo/">恶龙三剑客：反射、Unsafe 和 Cgo</a>中会做讲解。</p>
<p>函数返回值应优先值类型。仅在类型中有状态需要做变更时才使用指针作为返回类型。在<a target="_blank" rel="noopener" href="https://alanhou.org/standard-library/">标准库</a>一章的<strong>io及其朋友们</strong>一节会讲到I&#x2F;O，我们会学到读取或写入数据的缓冲。此外，并发所使用数据须以指针传递。这会在<a target="_blank" rel="noopener" href="https://alanhou.org/concurrency-in-go/">并发</a>一章中讨论。</p>
<h2 id="指针提升性能"><a href="#指针提升性能" class="headerlink" title="指针提升性能"></a>指针提升性能</h2><p>如果结构体过大，使用结构体指针作为入参或返回值可改善性能。向函数传递任意大小数据的指针耗时是恒定的。这很容易理解，因为所有数据类型的指针大小相同。对函数传值时数据越大耗时越久。在数据达到10 MB时耗时约一毫秒。</p>
<p>返回指针和返回值的效果更有趣。对于小于1 MB 的数据结构，返回指针类型实际上要慢于值类型。例如，返回一个100字节的数据耗费约10纳秒，而返回该数据结构的指针耗时约30纳秒。一旦数据结构大于1 MB，则出现反转。返回10 MB 的数据约耗时2微秒，而返回其指针仅半微秒多点。</p>
<p>这是非常小的时间维度。对于大部分情况，使用指针和值的这点不同并不会影响到程序的性能。但如果在函数间传递数MB 的数据时，即使数据不可变也请考虑使用指针。</p>
<p>以上数据均使用32GB内存i7-8700电脑进行采样。读者可使用<a target="_blank" rel="noopener" href="https://github.com/learning-go-book/pointer_performance">GitHub</a>上的代码自行进行性能测试。</p>
<h2 id="零值和无值"><a href="#零值和无值" class="headerlink" title="零值和无值"></a>零值和无值</h2><p>Go中另一种指针的常见用途是区分赋零值和未赋值的变量或字段。如果在你的程序中这点很重要，使用<code>nil</code>指针表示未赋值的变量或结构体字段。</p>
<p>因指针同时表示可变，使用时应注意。一般将指针设置为<code>nil</code>供函数返回，而时使用字典所用的逗号ok语法来返回一个值类型和一个布尔值。</p>
<p>记信如果通过参数或参数中的字段向函数传递<code>nil</code>指针，则无法在函数中对其设置值，因为没有存储该值的空间。如果传入的是非nil值，仅在清楚后果时进行修改。</p>
<p>同样的JSON转化是印证这一规则的特例。在数据与JSON进行互转时（在讲解Go的<a target="_blank" rel="noopener" href="https://alanhou.org/standard-library/">标准库</a>时会说到encoding&#x2F;json对JSON的支持），经常需要区别零值和未赋值的情况。这时对结构体中可为空的字段使用指针。</p>
<p>在不操作JSON（或其它外部协议）时，抑制信使用指针字段表示无值的诱惑。虽然指针用于表示无值很方便，但在需要修改值时，应当使用值类型配合布尔值。</p>
<h2 id="字典和切片的区别"><a href="#字典和切片的区别" class="headerlink" title="字典和切片的区别"></a>字典和切片的区别</h2><p>在前一章我们了解到，对传入函数的字典做任意修改都会体现在原始变量中。既然我们已经学习了指针，就来讲下原理：在Go运行时中，字典通过结构体的指针实现。传入字典也即向函数拷贝指针。</p>
<p>因此，应避免使用字节作为入参或返回值，对外的API尤其如此。在API设计层面，字典是糟糕的选择，因其没有说明其中包含的是什么值，并没有显式定义字典中的键名，因此知晓的唯一方式是追踪代码。从不可变性的角度来看，字典很糟的原因是只要在追踪了所有与其交互过的函数后才知道其结果。这就达不到API自描述的效果了。如果读者习惯了动态语言，请不要因其它语言缺乏结构而使用字典来替代。Go是一种强类型语言，请使用结构体来替代字典传给函数。（在<strong>降低垃圾回收器的工作量</strong>一节中讨论内存布局时会讲到推荐使用结构体的另一个原因。）</p>
<p>同时，将切片传递给函数情况更为复杂，对切片内容的任何修改都会体现在原变量中，但使用<code>append</code>修改切片的长度不会体现在原变量中，即使切片的容量本身大于这一长度。这是因为切片由三个字段实现：表示长度的<code>int</code>字段，表示容量的<code>int</code>字段以及一段内存块的指针。图6-5演示了其关系。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a1c8fa1c83a74b9dbe67000af8eda16d~tplv-k3u1fbpfcp-zoom-1.image" alt="图6-5 切片的内存布局"></p>
<p>图6-5 切片的内存布局</p>
<p>将切片拷贝给其它变量或是传入函数时，拷贝由长度、容量和指针组成。图6-6展示了两个切片变量指向同一块内存。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0aa0dc1276364e1a943466aaf73c7d5d~tplv-k3u1fbpfcp-zoom-1.image" alt="图6-6 切片及其拷贝的内存布局"></p>
<p>图6-6 切片及其拷贝的内存布局</p>
<p>修改切片中的值改变的是指针所指向的内存，因而变化对拷贝和原切片均可见。图6-7中为内存中的状况。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/653fb40c8d7f41368860205bceac84f4~tplv-k3u1fbpfcp-zoom-1.image" alt="图6-7 修改切片的内容"></p>
<p>图6-7 修改切片的内容</p>
<p>对长度和容量的修改不会体现在原切片中，因为这只发生在拷贝上。修改容量表示指针指向了一段新的更大的内存块。图6-8展示了这两个切片变量分别指向了不同的内存块。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9d0d0497c8a745c09683feb293ad29a5~tplv-k3u1fbpfcp-zoom-1.image" alt="图6-8 修改容量改变了存储"></p>
<p>图6-8 修改容量改变了存储</p>
<p>如果对切片进行追加时容量足以放下新切片，拷贝的长度发生变化，新值存储于拷贝和原切片共享的内存块中。但原切片不发生改变。也就是说Go运行时不会让原切片看到这些值，因为它们在原切片的长度之外。图6-9表示了这些值在一个切片变量中可见，而在另一个中不可见。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5cd021727deb44f0ae55eed9579e129f~tplv-k3u1fbpfcp-zoom-1.image" alt="图6-9 修改切片长度对原切片不可见"></p>
<p>图6-9 修改切片长度对原切片不可见</p>
<p>结果就是传入函数的切片内容可修改，但无法重置大小。切片是Go中唯一适用的线性数据结构，经常在程序间进行传递。默认应假定切片未由函数修改。应在函数的文档中说明是否修改了切片的内容。</p>
<p>注：可对函数传递任意大小的切片，原因在于传入函数的数据对于任意大小的切片都相同：两个<code>int</code>值和一个指针。而不能编写接收任意大小数组的函数，原因大于传递的是整个数组，而不是数据的指针。</p>
<p>切片作为入参还有另一个用途：它们是可复用缓冲的理想载体。</p>
<h2 id="将切片用作缓冲"><a href="#将切片用作缓冲" class="headerlink" title="将切片用作缓冲"></a>将切片用作缓冲</h2><p>在从外部（比如文件或网络连接）读取数据时，很多编程语言的代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">r = open_resource()</span><br><span class="line">while r.has_data() &#123;</span><br><span class="line">  data_chunk = r.next_chunk()</span><br><span class="line">  process(data_chunk)</span><br><span class="line">&#125;</span><br><span class="line">close(r)</span><br></pre></td></tr></table></figure>

<p>这种方式的问题在于每次进行<code>while</code>循环的迭代时，虽然每一个只用了一次也要重新分配<code>data_chunk</code>。这会产生大量不必要的内存分配。带内存回收的语言会自动处理这些分配，但在完成操作后还是要进行清理。</p>
<p>虽然Go是带垃圾回收的语言，编写地产的Go代码要求避免不必要的内存分配。我们不是在每次从数据源读取时返回新的分配，而是一次性创建一个切片，将其用作读取数据的缓冲：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">file, err := os.Open(fileName)</span><br><span class="line">if err != nil &#123;</span><br><span class="line">    return err</span><br><span class="line">&#125;</span><br><span class="line">defer file.Close()</span><br><span class="line">data := make([]byte, 100)</span><br><span class="line">for &#123;</span><br><span class="line">    count, err := file.Read(data)</span><br><span class="line">    if err != nil &#123;</span><br><span class="line">        return err</span><br><span class="line">    &#125;</span><br><span class="line">    if count == 0 &#123;</span><br><span class="line">        return nil</span><br><span class="line">    &#125;</span><br><span class="line">    process(data[:count])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在将切片传递给函数时无法修改其长度或容量，但我们可以修改到当前升度的内容。在以上代码中，我们创建了一个100字节的缓冲，每次循环时，我们将下个字节块（最多100）拷贝入切片。然后将传入的缓冲交给<code>process</code>。在<a target="_blank" rel="noopener" href="https://alanhou.org/standard-library/">标准库</a>一章的<strong>io及其朋友们</strong>一节会讲到I&#x2F;O。</p>
<h2 id="降低垃圾回收器的工作量"><a href="#降低垃圾回收器的工作量" class="headerlink" title="降低垃圾回收器的工作量"></a>降低垃圾回收器的工作量</h2><p>使用缓冲只是减少垃圾回收器工作量的一个例子。程序员眼中的“垃圾”是“不再有指针指向的数据”。一旦某一数据不再有指针指向它，数据所占用的内存即可被复用。如果不回收内存，程序的内存占用量会膨胀到内存溢出。内存回收器的任务是自动监测未使用的内存并进行回收以供复用。Go贴心地为我们提供了垃圾回收器，因为几十年的经验表明很难妥善地手动管理内存。但有了垃圾回收器并不表示可以随意制造垃圾。</p>
<p>如果读者花时间研究过编程语言是如何实现的，就会知道堆和栈。对于不熟悉的读者，栈是一段连续的内存块，执行线程的每次函数调用共享相同的栈。栈上分配内存简单快速。栈指针追踪内存分配的最后位置，通过移动栈指针可分配额外的内存。在调用函数时，会为函数数据创建新的栈桢。本地变量以及传入函数的参数存储在栈上。每个新变量会导致栈指针移动该值的大小。函数退出时，返回值会通过栈拷贝回调用函数，栈指针则会移至退出函数的起始栈帧，回收函数本地变量和参数使用的所有栈内存。</p>
<p>注：Go的不寻常在于它可以在程序运行期间增加栈的大小。这是因为每个协助有自己的栈，而协程由Go运行时而非底层操作系统管理（我们会在<a target="_blank" rel="noopener" href="https://alanhou.org/concurrency-in-go/">并发</a>一章中讨论协程）。这有其优势（Go的初始栈很小、占用更少内存）及劣势（栈需要扩容时，所有数据都会被拷贝，这是缓慢的）。这也使得可能会写出栈反复扩容和收缩的糟糕代码。</p>
<p>要在栈上存储内容，需要知道其在编译时的具体大小。在学习Go中的值类型（原生类型、数组和结构体）时，会发现一个共同点：在编译时都能知道占用的具体内存大小。这也是为什么大小是成为了数组的一部分。因为其大小已知，可分配到栈上，不必放到堆上。指针类型的大小也是固定的，同样存储在栈上。</p>
<p>对于指针指向的数据，规则就更为复杂。要在Go中将指针指向的数据分配到栈上，必须满足一些条件。必须为编译时大小已知的本地变量。不能是函数返回的指针。如果是传入函数的指针，必须要保证这些条件仍能满足。如果大小不固定，无法通过移动栈指针来获取空间。如果返回指针变量，指针指向的内存会在函数返回时失效。在编译器决定数据无法存储于栈上时，可以称为指针指向的数据<strong>逃逸</strong>出了栈，编译器将数据存储于堆上。</p>
<p>堆是由垃圾回收器管理的内存（在C和C++等编程语言中手动管理）。我们不会讨论垃圾回收器算法的实现细节，但远比移动栈帧要复杂。只要能回溯到栈上的指针类型变量，堆所存储的数据就有效。一旦没有指针指向该数据（或指向该数据的数据），这段数据就会成为垃圾，将由垃圾回收器进行清理。</p>
<p>注：C程序中常见的bug是返回本地变量指针。在C中，这会导致指针指向无效内存。Go编译器更为智能。在发现已返回本地变量的指针时，本地变量的值会存储到堆上。</p>
<p>Go编译器的逃逸分配并不完美。有时可存储在栈上的数据逃逸到了堆上。但编译器要要保守些，不能冒需放到堆上的数据存储到栈上的风险，否则对无效数据的引用会导致内存崩溃。Go的新发行版中改良了逃逸分配。</p>
<p>读者可能会想在堆上存储内容有什么坏处呢？有两个性能相关的问题。第一是垃圾回收器执行操作会耗费时间。追踪堆中所有空闲内存的可用块或哪些已用内存堆还持有有效指针消耗并不算小。这会占用程序执行本可使用的宝贵时间。编写了很多种内存回收算法，粗略分为两类：设计用于高吞吐（在单次扫描中发现尽可能多的垃圾）或低延时（尽快完成垃圾扫描）。<a target="_blank" rel="noopener" href="https://research.google/people/jeff/">Jeff Dean</a>，Google工程化成功的幕后大神，作为联合作者于2013年发表了名为<a target="_blank" rel="noopener" href="https://research.google/pubs/pub40801/">The Tail at Scale</a>的论文。其中论述到系统应优化延时，保持低响应时间。Go运行所使用的垃圾回收器更倾向低延时。每次垃圾回收周期被设计为小于500毫秒。但如果你的Go程序创建了大量的垃圾，那么在一个周期中就无法发现发现的垃圾，这会拖慢回收器并增加内存占用。</p>
<p>注：如果读者对实现细节感兴趣，可以听一听Rick Hudson在2018内存管理国际研讨会上的演讲，讲到了Go垃圾回收器的<a target="_blank" rel="noopener" href="https://go.dev/blog/ismmkeynote">历史和实现</a>。</p>
<p>第二个问题与计算机硬件性质有关。RAM虽然是“随机读取内存”，便读取内存最快速的方式是序列化读取。Go中的结构体切片将数据按序放于内存中。这样加载和处理数据都很快。结构体指针（或字段为指针的结构体）的切片的数据RAM中分散存储，读取和处理就会更慢。Forrest Smith写了一篇深入的<a target="_blank" rel="noopener" href="https://www.forrestthewoods.com/blog/memory-bandwidth-napkin-math/">博文</a>探讨了这会在多大程度上影响性能。他的数据表明通过指针访问随机存储在内存的数据会慢两个数量级。</p>
<p>这种在写软件时考虑其所运行的硬件的方式称为机械同理（mechanical sympathy）。这个词来赛车界，意思是驾驶员熟知赛车可以压榨出其性能极限。2011年，Martin Thompson将这一词用于软件开发。遵守Go的最佳实践可以自动实现机械同理。</p>
<p>比较下Go与Java的方式。Java中，本地变量和参数和Go一样存储于栈中。但前面也提到过，Java中的对象按指针实现。这表示对每个对象变量实例，仅会将指针分配到栈中，对象中的数据位于堆中。仅原生类型值（数字、布尔值、字符）存储于栈上。这就意味着Java的垃圾回收器要完成大量的工作。同时也表示Java中的列表实际上是一个指针数组的指针。虽然它看起来像是线性数据结构，读取时实际也在内存中横跳，效率打折。Python、Ruby和JavaScript中类似。为解决这一低效问题，Java虚拟机内置了一个智能的垃圾回收器，完成大量的工作，有些是优化吞量，有些优化延时，都具有配置项来完成最佳性能调优。Python、Ruby和JavaScript的虚拟机优化则不足，因而性能受到很大影响。</p>
<p>现在读者已经明白Go为什么很少鼓励使用指针。我们尽可能将内容存放在栈上来减轻垃圾回收器的负载。结构体或原生类型切片的数据在内存按序排列以达到快速访问。在垃圾回收器运行时，对快速返回的优化要多于收集更多垃圾。这种方法的核心是一开始就创建尽量少的垃圾。虽然聚焦于优化内存分配可能看上去是不成熟的优化，Go中地道的方式也是最高效的。</p>
<p>如果想学习堆栈以及Go中逃逸分析的更多知识，有一些很好的博客文章，比如<a target="_blank" rel="noopener" href="https://www.ardanlabs.com/blog/2017/05/language-mechanics-on-stacks-and-pointers.html">Arden Labs上</a><a target="_blank" rel="noopener" href="https://www.ardanlabs.com/blog/2017/05/language-mechanics-on-stacks-and-pointers.html">Bill Kennedy</a>和<a target="_blank" rel="noopener" href="https://segment.com/blog/allocation-efficiency-in-high-performance-go-services/">Segment上Achille Roussel和Rick Branson</a>的文章。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本章稍微深入了一下底层来辅助我们理解指针，指针是什么、如何使用指针，以及最重要的，何时使用指针。下一章中，我们会学习Go语言中方法、接口和类型的实现，与其它语言的差别，以及所具备的能力。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://alanhou.github.io/2022/11/25/setting-up-go-environment/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Alan Hou">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Alan Hou的个人博客">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Alan Hou的个人博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/11/25/setting-up-go-environment/" class="post-title-link" itemprop="url">云原生系列Go语言篇-Go环境配置</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2022-11-25 00:00:00" itemprop="dateCreated datePublished" datetime="2022-11-25T00:00:00+08:00">2022-11-25</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2023-02-03 14:25:27" itemprop="dateModified" datetime="2023-02-03T14:25:27+08:00">2023-02-03</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>本文来自正在规划的<a target="_blank" rel="noopener" href="https://alanhou.org/go-cloudnative/">Go语言&amp;云原生自我提升系列</a>，欢迎关注后续文章。</p>
<p>每种编程语言都需要有开发环境，Go自然也不例外。如果读者之前已经写过Go程序，那么一定已经有环境了，但可能会漏掉一些最新技术和工具。如果是第一次在电脑上配置Go，也不必担心，Go及其支持工具非常简单。在配置好环境并验证后，我们会构建一个简单程序，学习几种构建和运行Go的方式，然后涉足一些简化Go开发的工具和技巧。</p>
<h2 id="安装Go工具"><a href="#安装Go工具" class="headerlink" title="安装Go工具"></a>安装Go工具</h2><p>要编写Go代码，首先要下载、安装Go开发工具。工具的最新版请见<a target="_blank" rel="noopener" href="https://go.dev/dl/">Go官方网站</a>的下载页面。选择所用平台的下载文件并执行安装。Mac的安装包 <em>.pkg</em>及Windows的安装包 <em>.msi</em>可自动在相应的位置安装Go、移除旧的安装版本，并将Go二进制文件放到默认的执行路径下。</p>
<p>小贴士：如果读者是Mac开发者，可以通过<code>brew install go</code>命令来使用<a target="_blank" rel="noopener" href="https://brew.sh/">Homebrew</a>安装Go。使用<a target="_blank" rel="noopener" href="https://chocolatey.org/">Chocolatey</a>的Windows开发者可以通过<code>choco install golang</code>命令安装Go。</p>
<p>各类Linux和FreeBSD安装包是gzip压缩的tar文件，解压为名为<em>go</em>的目录。将该目录拷贝到 <em>&#x2F;usr&#x2F;local</em> ，再将 <em>&#x2F;usr&#x2F;local&#x2F;go&#x2F;bin</em>添加到<code>$PATH</code>，这样就可以访问<code>go</code>命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ tar -C /usr/local -xzf go1.18.4.linux-amd64.tar.gz</span><br><span class="line">$ echo &#x27;export PATH=$PATH:/usr/local/go/bin&#x27; &gt;&gt; $HOME/.profile</span><br><span class="line">$ source $HOME/.profile</span><br></pre></td></tr></table></figure>

<p>注：Go程序编译为单个原生二进制，无需安装其它软件即可直接运行。这与Java、Python和JavaScript这样要求安装虚拟机才能运行程序的语言不同。使用单原生二进制利于Go编写语言的分发。</p>
<p>可以打开命令行输入如下命令验证环境配置是否正确：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ go version</span><br></pre></td></tr></table></figure>

<p>如果配置正确应该会打印出如下内容：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go version go1.18.4 darwin/arm64</span><br></pre></td></tr></table></figure>

<p>这表明它是在macOS上Go版本为1.18.4。（Darwin是macOS内部的操作系统，arm64是基于ARM的64位芯片。）</p>
<h2 id="排查-Go-安装的问题"><a href="#排查-Go-安装的问题" class="headerlink" title="排查 Go 安装的问题"></a>排查 Go 安装的问题</h2><p>如果显示的不是版本信息而是报错了，很可能是<code>go</code>不在执行路径下，或者是路径中有另一个名为<code>go</code>的程序。在macOS或其它类Unix系统中，可使用<code>which go</code>来查看所执行的<code>go</code>命令。如果未返回任何内容，则需要处理执行路径。</p>
<p>如果使用Linux或FreeBSD，则可能是在32位系统中安装了64位开发工具，或者是使用了错误的芯片架构的开发工具。</p>
<h3 id="Go的工具"><a href="#Go的工具" class="headerlink" title="Go的工具"></a>Go的工具</h3><p>所有的Go开发工具都可使用<code>go</code>命令来访问。除了<code>go version</code>，还有编译器(<code>go build</code>)、代码格式化工具(<code>go fmt</code>)、依赖管理工具(<code>go mod</code>)、测试运行工具(<code>go test</code>)以及扫描常见代码错误的工具(<code>go vet</code>)等。在后面的文章中会进行详细讲解。现在我们通过第一个程序Hello World来快速查看最常用的一些工具。</p>
<p>注：自Go语言2009年发布以来，代码组织和依赖管理的方式发生过多次变化。因此读者可能在网上看到一些过时的建议，请注意甄别。</p>
<p>对于现在而言，Go语言开发的规则很简单：读者可以自由组织项目并放在任何位置。</p>
<p>注：在中国大陆通常在安装Go之后还应配置代理进行加速，比如使用七牛云的代理：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ go env -w GO111MODULE=on</span><br><span class="line">$ go env -w GOPROXY=https://goproxy.cn,direct</span><br></pre></td></tr></table></figure>

<h2 id="第一个Go程序"><a href="#第一个Go程序" class="headerlink" title="第一个Go程序"></a>第一个Go程序</h2><p>我们学习一些使用Go编写程序的基础。在编写的过程中会不断了解Go程序的基本组成。读者可能还不能掌握所有知识，但不必担心，后续的文章会有进一步的讲解。</p>
<h3 id="创建Go模块"><a href="#创建Go模块" class="headerlink" title="创建Go模块"></a>创建Go模块</h3><p>首先需要创建放程序的目录。命名为<em>ch1</em>。在命令行中进行创建：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir ch1 </span><br><span class="line">$ cd ch1</span><br></pre></td></tr></table></figure>

<p>在该目录中，运行<code>go mod init</code>命令将该目录标记为一个Go模块：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ go mod init hello_world</span><br><span class="line">go: creating new go.mod: module hello_world</span><br></pre></td></tr></table></figure>

<p>在第10章中会更深入地讨论模块，但现在读者只需知道Go项目被称为模块，每个模块在根目录下都有一个<code>go.mod</code>文件。运行<code>go mod init</code>会为我们创建该文件。<code>go.mod</code>中内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">module hello_world</span><br><span class="line"></span><br><span class="line">go 1.19</span><br></pre></td></tr></table></figure>

<p><code>go.mod</code>文件声明了模块的名称以及该模块所支持的最小Go版本，还有模块依赖的其它模块。可将其类比Python中的<code>requirements.txt</code>或Ruby中的<code>Gemfile</code>。</p>
<p>不应直接编辑<code>go.mod</code>文件。而是使用<code>go get</code>和<code>go mod tidy</code>命令来管理对该文件的修改。</p>
<h3 id="go-build"><a href="#go-build" class="headerlink" title="go build"></a>go build</h3><p>下面开始打码！打开文本编辑器，键入如下内容，保存到<em>ch1</em>目录的<em>hello.go</em>文件中：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">fmt.Println(&quot;Hello, world!&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注：这里的缩进存在问题，但稍后读者就会明白为什么会这样了。</p>
<p>我们来快速看下创建的Go文件中的各部分。第一行是包声明。在Go模块中，代码由一个或多个包组成。模块中的<code>main</code>包含启动Go程序的代码。</p>
<p>接下来的是导入语句。<code>import</code>语句列出文件中所引用的包。我们这里使用的是标准库中的<code>fmt</code>（读作fumpt）包。不同于其它语言，Go中只导入整包。不能限定包中的具体类型、函数、常量或变量。</p>
<p>所有的Go程序由<code>main</code>包中的<code>main</code>函数启动。我们使用<code>func main() &#123;</code>声明该函数。和Java、JavaScript及C一样，Go使用花括号标记代码块的起始和结束。<br>函数体由一行代码组成。表明调用<code>fmt</code>包中的<code>Println</code>函数，参数为<code>&quot;Hello, world!&quot;</code>。有过编程经验的读者应该能猜到该函数的作用。</p>
<p>保存好文件后，回到命令行输入如下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ go build</span><br></pre></td></tr></table></figure>

<p>它会在当前目录创建一个名为<code>hello_world</code>的可执行文件（Windows下为<em>hello_world.exe</em>）。运行该命令，会在屏幕中输出<code>Hello, world!</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ./hello_world</span><br><span class="line">Hello, world!</span><br></pre></td></tr></table></figure>

<p>二进制文件的名称与模块中声明一致。若想使用其它名称或是存储在其它位置，使用<code>-o</code>参数。例如，我们希望将代码编译为二进制文件hello，可使用：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ go build -o hello</span><br></pre></td></tr></table></figure>

<h3 id="格式化代码"><a href="#格式化代码" class="headerlink" title="格式化代码"></a>格式化代码</h3><p>Go的一大主要设计目录是创建一种高效编写代码的语言。这表示语法要简洁、编译要快速。同时也导致Go的作者们重新考虑了代码格式化。大部分语言在代码的格式上留有巨大的灵活性。但Go不是。强制标准的格式让编写规范源代码的工具相当容易。它简化了编译器并允许创建有一些生成代码的智能工具。</p>
<p>还有另一个好处。开发人员过去在格式之争上浪费了大量的时间。因为Go语言定义了代码格式化的标准方式。Go开发者就无需争论<a target="_blank" rel="noopener" href="https://wiki.c2.com/?WhereDoTheBracesGo">花括号样式</a>和<a target="_blank" rel="noopener" href="https://www.jwz.org/doc/tabs-vs-spaces.html">Tab还是空格</a>。例如，Go使用tab进行缩进，并在起始花括号与声明或代码块起始命令不在同一行时会报语法错误。</p>
<p>注：很多Go开发人员觉得Go团队定义了一套标准格式，是为了避免争论后来才发现了工具的优势。但Go语言开发负责人Russ Cox曾公开说过更好的工具化才是最初的动机。</p>
<p>Go开发工具包含有一个命令<code>go fmt</code>，它会自动修复代码空白匹配标准格式。但是，它无法修复错误行中的花括号。运行命令如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ go fmt ./...</span><br><span class="line">hello.go</span><br></pre></td></tr></table></figure>

<p>使用<code>./…</code>告诉Go工具对当前目录及其子目录下的所有文件应用该命令。我们在进一步学习Go的工具时它还会出现。</p>
<p>此时如果打开<code>hello.go</code>，会看到<code>fmt.Println</code>已经采用单制表符进行了缩进。</p>
<p>小贴士：在编译代码前请记得运行<code>go fmt</code>，至少在将修改的代码提交到仓库前要运行该命令。如果忘记，单独提交一次只运行了**<code>go fmt ./…</code>**的修改。对使用 IDE 的读者更简单的方法是对 VSCode 和 GoLand 这些编辑器提前做好配置，这样在每次保存代码时都会自动执行该命令。</p>
<h4 id="分号插入规则"><a href="#分号插入规则" class="headerlink" title="分号插入规则"></a>分号插入规则</h4><p><code>go fmt</code>命令不会修复错误行的花括号问题，这背后的原因是分号插入规则。类似C或Java，Go需要在每条语句后添加分号。但Go开发者不需要自己添加这一分号。Go编译器按照一套极简单的规则自动插入，参见《<a target="_blank" rel="noopener" href="https://go.dev/doc/effective_go#semicolons">Effective Go</a>》中的描述：</p>
<p>如果新行之前最后的符号(token )是以下中的一个，词法分析器(lexer)会在其后添加一个分号：</p>
<ul>
<li>标识符（包含int和float64这样的保留字）</li>
<li>基本字面量，如数字或字符串常量</li>
<li>以下符号之一：break、continue、fallthrough、return、++、–、)或}</li>
</ul>
<p>有了这一简单规则，可以了解到为会花括号放到错误的位置时会出错。如果这样写代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">func main()</span><br><span class="line">&#123;</span><br><span class="line">    fmt.Println(&quot;Hello, world!&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>分号插入规则发现在<code>func main()</code>中以“)”结尾，会将其变成：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">func main();</span><br><span class="line">&#123;</span><br><span class="line">    fmt.Println(&quot;Hello, world!&quot;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这样就不是有效的Go代码了。</p>
<p>分号插入规则及其对花括号的限制让Go编译器变得更简单、快速，同时也限制定了代码风格。这是睿智的做法。</p>
<h2 id="go-vet"><a href="#go-vet" class="headerlink" title="go vet"></a>go vet</h2><p>有一批bug在代码语法上没有问题，但却很可能是错误的。<code>go</code>工具含有一个<code>go vet</code>命令来检测这类错误。我们修改程序来看它是如何检测到的。修改<code>hello.go</code>中的<code>fmt.Println</code>代码行如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fmt.Printf(&quot;Hello, %s!\n&quot;)</span><br></pre></td></tr></table></figure>

<p><code>fmt.Printf</code>非常类似于C、Java、Ruby及其它语言中的<code>printf</code> 。如果之前没见过<code>printf</code> ，这个函数的第一个参数是一个模板，剩余的参数是模板中占位符的值。</p>
<p><code>go vet</code>可以检测到的是格式化模板中的每个占位符是否有对应的值。对修改后的代码运行<code>go vet</code>，它会发现其中的错误：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ go vet ./...</span><br><span class="line"># hello_world</span><br><span class="line">./hello.go:6:2: fmt.Printf format %s reads arg #1, but call has 0 args</span><br></pre></td></tr></table></figure>

<p>这里<code>go vet</code>发现了我们的bug，可以很简单地进行修复。修改<code>hello.go</code>中的第6行如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fmt.Printf(&quot;Hello, %s!\n&quot;, &quot;world&quot;)</span><br></pre></td></tr></table></figure>

<p>虽然<code>go vet</code>可以捕获一些觉的编程错误，但有些问题无法监测到。所幸有一些第三方的Go代码智能工具弥补了这一缺陷。其中一些知名的质量工具会在第11章中进行讲解。</p>
<p>小贴士：就像我们应该运行<code>go fmt</code>来确保代码的格式正确，运行<code>go vet</code>可扫描到有效代码中的一些bug。它是只是保障高质量代码的第一步。除了本系列文章中的建议，所有的Go开发人员都应当读读<a target="_blank" rel="noopener" href="https://go.dev/doc/effective_go">Effective Go</a>和<a target="_blank" rel="noopener" href="https://github.com/golang/go/wiki/CodeReviewComments">Go语言文档中的代码审核评论</a>来理解地道的Go代码应该是什么样的。</p>
<h2 id="工具选择"><a href="#工具选择" class="headerlink" title="工具选择"></a>工具选择</h2><p>虽然我们在这个小程序时只用到了普通的文本编辑器和<code>go</code>命令，但在写更大的项目时最好使用更高级的工具。大部分编辑器和IDE都有优秀的<a target="_blank" rel="noopener" href="https://github.com/golang/go/wiki/IDEsAndTextEditorPlugins">Go开发工具</a>。如果读者没有个人偏好的工具，最主流的两个Go开发环境是VS Code和GoLand。</p>
<h3 id="Visual-Studio-Code"><a href="#Visual-Studio-Code" class="headerlink" title="Visual Studio Code"></a>Visual Studio Code</h3><p>如果希望使用免费的开发环境，微软所出的<a target="_blank" rel="noopener" href="https://code.visualstudio.com/">Visual Studio Code</a> 是最佳的选择。自2015年发布以来， VS Code已成为最流行开源代码编辑器。它并没有自带对Go的支持，但可以通过在插件库中下载Go插件来变成Go开发环境。</p>
<p>VS Code对Go的支持依赖于第三方工具。包含Go开发工具、<a target="_blank" rel="noopener" href="https://github.com/go-delve/delve">Delve调试器</a>和<a target="_blank" rel="noopener" href="https://github.com/golang/tools/blob/master/gopls/README.md">gopls</a>，后者是由Go团队开发的Go语言服务端。在安装Go开发工具包时，Go插件会安装Delve和gopls。</p>
<p>注：什么是语言的服务端？这是一种API标准规范，用于实现智能编辑行为，如代码补全、质量检查或查找代码中所有使用变量或函数之处。可以阅读<a target="_blank" rel="noopener" href="https://microsoft.github.io/language-server-protocol/">语言服务端协议</a>来了解语言服务端及其能力的详细知识。</p>
<p>一旦配置好的工具，就可以打开项目使用了。图1-1中展示了项目窗口的外观。<a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=1MXIGYrMk80">Getting started with VS Code Go</a>视频中演示了 VS Code的Go插件。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0470bea202f642dbaf5ba2b97e11ff82~tplv-k3u1fbpfcp-zoom-1.image" alt="VS Code"></p>
<p>图1-1 Visual Studio Code</p>
<h3 id="GoLand"><a href="#GoLand" class="headerlink" title="GoLand"></a>GoLand</h3><p><a target="_blank" rel="noopener" href="https://www.jetbrains.com/go/">GoLand</a>是JetBrains专门为Go推出的IDE。虽然JetBrains是出了名的以Java为中心的工具，但丝毫不影响GoLand是一款优秀的Go开发环境。参见图1-2中的GoLand用户界面，它和 IntelliJ、PyCharm、RubyMine、WebStorm、Android Studio或其它JetBrains IDE都很像。它对Go的支持有重合名、语法高亮、代码补全、代码导航、文档弹窗、调试器、代码覆盖率等。除了支持Go，GoLand还包含JavaScript&#x2F;HTML&#x2F;CSS和SQL数据库工具。不同于VS Code，GoLand不需要用户下载其它工具就可正常使用。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/da28747ee01b4d9c8447f5392e62c7e4~tplv-k3u1fbpfcp-zoom-1.image" alt="GoLand窗口"></p>
<p>图1-2 GoLand<br>如果已订阅了IntelliJ Ultimate（或是符合免费证书申请），可通过插件来添加对Go的支持。不然的话就需要付费使用GoLand，并没有免费版。</p>
<h3 id="The-Go-Playground"><a href="#The-Go-Playground" class="headerlink" title="The Go Playground"></a>The Go Playground</h3><p>Go开发还有一个重要的工具，但无需安装。访问<a target="_blank" rel="noopener" href="http://go.dev/play">The Go Playground</a> 就可以看到类似图1-3中的界面。如果使用过<code>irb</code>、<code>node</code>或<code>python</code>这些命令行环境，会发现The Go Playground的使用体验非常类似。它可用于测试和分享简单程序。在窗口中输入代码，点击Run按钮运行代码。Format按钮对程序运行<code>go fmt</code>同时更新导入包。Share按钮创建一个唯一URL，可发送给其他人查看该程序或是你自己在未来回来查看代码（这些URL验证下来可保存很长时间，但不要把它用成代码仓库）。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e209e4d75b304d3597ddd4f4f026356c~tplv-k3u1fbpfcp-zoom-1.image" alt="Go Playground"></p>
<p>图1-3 The Go Playground</p>
<p>在图1-4中可以看到，可以通过在每个文件之间添加<code>-- filename.go --</code>这样的代码来模拟多文件。甚至可以通过在文件名中添加<code>/</code>来模拟子目录，如<code>-- subdir/my_code.go --</code>。</p>
<p>注意The Go Playground实际上是别人的电脑（具体来说是Google的电脑），所有自由度受限。它提供了几种Go版本（通常是当前发行版、上一版和最新的开发版）。只能发起对<code>localhost</code>的网络连接，运行太长或占用过多内存时会停止掉进程。如果程序中用到时间的话，需要考虑到时钟设置为November 10, 2009, 23:00:00 UTC（Go首次发布的日期）。虽然有这些限制，Go Playground对于测试新想法很有用，而且不需要在本地新建项目。在本系列文章中，读者会看到很多The Go Playground的链接，可直接运行代码，无需拷贝到本地。</p>
<p>警告：不要在其中使用敏感信息（如个人身份信息、密码或私钥）！如果点击Share按钮，这些信息会保存到Google的服务器，其他有分享链接的人都可以访问到。如果不慎这么干了，写一封邮件把URL和需要删除的原因发送给<a href="mailto:&#x73;&#x65;&#99;&#117;&#x72;&#105;&#x74;&#121;&#x40;&#x67;&#111;&#108;&#x61;&#110;&#103;&#46;&#x6f;&#114;&#x67;">&#x73;&#x65;&#99;&#117;&#x72;&#105;&#x74;&#121;&#x40;&#x67;&#111;&#108;&#x61;&#110;&#103;&#46;&#x6f;&#114;&#x67;</a>。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8c8f68596c184455a77c6af1726c2acd~tplv-k3u1fbpfcp-zoom-1.image" alt="Go Playground多文件"></p>
<p>图1-4 The Go Playground支持多文件</p>
<h2 id="Makefile"><a href="#Makefile" class="headerlink" title="Makefile"></a>Makefile</h2><p>IDE很好使用，不易于自动化。现代软件开发依赖于反复的自动化构建，可在任何地方、任意时间由任何运行。这类工具是很好的软件工程化实践。它避免了一个历史问题，开发者不对构建问题负责并抛出那句经典台词：“在我的电脑上是好的!”实现的方式是通过脚本指定构建步骤。Go开发者使用<code>make</code> 进行解决。开发者通过它指定一系列构建程序所需要的操作以及它们执行的顺序。读者可能不熟悉<code>make</code> ，它1976年就在Unix系统上用于构建程序了。</p>
<p>在<em>ch1</em>目录下创建一个文件<code>Makefile</code> ，添加如下内容：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">.DEFAULT_GOAL := build</span><br><span class="line"></span><br><span class="line">.PHONY:fmt vet build</span><br><span class="line">fmt:</span><br><span class="line">        go fmt ./...</span><br><span class="line"></span><br><span class="line">vet: fmt</span><br><span class="line">        go vet ./...</span><br><span class="line"></span><br><span class="line">build: vet</span><br><span class="line">        go build</span><br></pre></td></tr></table></figure>

<p>即使读者之前没用过Makefile ，也不难get到其作用。每个操作被称为一个<em>target</em>。<code>.DEFAULT_GOAL</code>定义了在没有运行目标时所运行的操作。上例中运行的是<code>build</code>目标命令。接下来就是目标命令的定义，每个冒号(<code>:</code>)前为目标名。目标名后的单词 (<code>build: vet</code>中的<code>vet</code> ) 是在运行该目标之前所需要运行的目标命令。该目标所执行的任务放在之后的缩进行。<code>.PHONY</code>让<code>make</code> 命令在项目中有同名目录时不至于混淆。</p>
<p>运行<code>make</code> 命令后会输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ make</span><br><span class="line">go fmt ./...</span><br><span class="line">go vet ./...</span><br><span class="line">go build</span><br></pre></td></tr></table></figure>

<p>通过这条命令，我们格式化了代码、检查了隐藏的错误并执行了编译。我们可以通过<code>make vet</code>来检查代码，或是只运行<code>make fmt</code>来完成格式化。看起来并没有多大改进 ，但构建前代码及检查代码（或是执行持续集成构建服务中的脚本）可以保障不丢失任何步骤。</p>
<p>Makefile的一个缺点是要求有些严格。必须使用制表符来缩进这些步骤。并且在Windows系统中没有原生支持。如果在Windows电脑上进行Go开发，需要先安装<code>make</code>。最简单的安装方式是先安装包管理工具如 <a target="_blank" rel="noopener" href="https://chocolatey.org/">Chocolatey</a>，然后使用它来安装<code>make</code> （对于Chocolatey，命令为<code>choco install make</code>）。</p>
<p>如果想要学习更多有关Makefile的知识，<a target="_blank" rel="noopener" href="https://makefiletutorial.com/">Chase Lambert</a>有一个很好的教程，但使用了一小部分C讲解了相关概念。</p>
<h2 id="保持更新"><a href="#保持更新" class="headerlink" title="保持更新"></a>保持更新</h2><p>像其它编程语言一样，Go开发工具会做定期更新。Go程序编译为单独的原生二进制文件，无需担心开发环境的升级引起已部署程序的崩溃。可以在同一台电脑或虚拟机上同时运行多个Go版本编译的程序。</p>
<p>从Go 1.2开始，大约每6个月会发布一个大版本。还有一些按需发布的bug和安全问题修复的小版本。因快速的开发周期以及Go团队对于向后兼容的承诺，Go的发行版倾向于递增而不是扩散的做法。<a target="_blank" rel="noopener" href="https://go.dev/doc/go1compat">Go兼容性承诺</a>详细描述了Go团队如何规划避免引起崩溃的Go代码。其中说到不会从1开始Go版本不会出现任何语言和标准库层面的向后不兼容，除非涉及到bug或安全问题修复。这一承诺不适用于<code>go</code>命令。<code>go</code>命令的参数和功能有过向后不兼容的修改，且很有可能同样在未来出现。</p>
<p>准备好在电脑上更新Go开发工具时，Mac和Windows用户拥有快速的方法。安装了<code>brew</code>和<code>chocolatey</code>的用户可以使用该工具升级。使用安装包安装的用户可在<a target="_blank" rel="noopener" href="https://go.dev/dl/">https://go.dev/dl/</a>下载最新版本，它会删除掉老版本并安装新版本。</p>
<p>Linux和BSD用户需要下载最新版本，将老版本移至备份目录，解压新版本，然后再删除老版本：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ mv /usr/local/go /usr/local/old-go</span><br><span class="line">$ tar -C /usr/local -xzf go1.18.4.linux-amd64.tar.gz</span><br><span class="line">$ rm -rf /usr/local/old-go</span><br></pre></td></tr></table></figure>

<p>注：从技术上来说，无需移动已有安装，只需要删除它再安装新版本即可。但这不能保证“万无一失”。如果在安装新版本时出现问题，最好还有旧版本可以使用。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本文中，我们学习了如何安装、配置Go开发环境。同时讨论了构建Go程序及保障代码质量的一些工具。至此我们已准备好了环境，下一篇文章中我们就开始探讨Go语言的内置类型以及如何声明变量。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://alanhou.github.io/2020/12/26/odoo-cookbook-14-chapter2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Alan Hou">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Alan Hou的个人博客">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Alan Hou的个人博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/12/26/odoo-cookbook-14-chapter2/" class="post-title-link" itemprop="url">Odoo 14开发者指南第二章 管理Odoo服务端实例</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2020-12-26 00:00:00" itemprop="dateCreated datePublished" datetime="2020-12-26T00:00:00+08:00">2020-12-26</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2023-02-21 08:50:14" itemprop="dateModified" datetime="2023-02-21T08:50:14+08:00">2023-02-21</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>在<a target="_blank" rel="noopener" href="https://alanhou.org/odoo-14-installing-the-odoo-development-environment/">第一章 安装Odoo开发环境</a>中，我们学习了如何使用源码中所带的标准核心插件配置Odoo实例。本章主要讲解如何对Odoo实例添加非核心或自定义插件。在Odoo中，可以通过多个目录加载插件。此外，推荐使用单独的目录加载第三方插件或自定义的插件，以避免与Odoo核心模块产生冲突。甚至Odoo企业版也是一种类型的插件目录，需要像加载普通插件目录那样对其进行加载。</p>
<p>本章中，我们将讲解如下内容：</p>
<ul>
<li>配置插件路径</li>
<li>标准化你的实例目录布局</li>
<li>安装及升级本地插件模块</li>
<li>通过GitHub安装插件模块</li>
<li>对插件应用修改</li>
<li>应用及尝试建议的拉取请求</li>
</ul>
<blockquote>
<p>📝<strong>有关用语</strong></p>
<p>本书中，我们会交叉使用插件(<strong>add-on</strong>)、模块(<strong>module</strong>)、应用(<strong>app</strong>)或插件模块(<strong>add-on module</strong>)。它们都是指可通过用户界面在Odoo中安装的Odoo应用或扩展应用。</p>
</blockquote>
<h2 id="配置插件路径"><a href="#配置插件路径" class="headerlink" title="配置插件路径"></a>配置插件路径</h2><p>通过addons_path参数的配置，可以在 Odoo 中加载自己的插件模块。在Odoo初始化一个新数据库时，它会在addons_path配置参数中给定的这些目录中搜索插件模块。addons_path会在这些目录中搜索潜在的插件模块。</p>
<p>addons_path中所列出的目录预期应包含子目录，每个子目录是一个插件模块。在数据库初始化完成后，将能够安装这些目录中所给出的模块。</p>
<h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><p>这一部分假定你已经准备好了实例并生成了配置文件，如在<a target="_blank" rel="noopener" href="https://alanhou.org/odoo-14-installing-the-odoo-development-environment/">第一章 安装Odoo开发环境</a><em>在一个文件中存储实例配置</em>一节所描述。Odoo的源码存放在<del>&#x2F;odoo-dev&#x2F;odoo中，而配置文件存放在</del>&#x2F;odoo-dev&#x2F;myodoo.cfg中。</p>
<h3 id="如何配置…"><a href="#如何配置…" class="headerlink" title="如何配置…"></a>如何配置…</h3><p>按如下步骤在实例的addons_path中添加~&#x2F;odoo-dev&#x2F;local-addons目录：</p>
<ol>
<li><p>编辑你的实例配置文件，即 ~&#x2F;odoo-dev&#x2F;myodoo.cfg。</p>
</li>
<li><p>定位到以addons_path &#x3D;开头的一行，默认应该会看到如下内容：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">addons_path = ~/odoo-dev/odoo/addons</span><br></pre></td></tr></table></figure>

<p><strong>译者注：</strong> 当前默认生成的配置文件中为绝对路径</p>
</li>
<li><p>修改该行，添加一个逗号（英文半角），并接你想要添加为addons_path的目录名称，如以下代码所示：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">addons_path = ~/odoo-dev/odoo/addons,~/odoo-dev/local-addons</span><br></pre></td></tr></table></figure>
</li>
<li><p>在终端中重启实例  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ~/odoo-dev/odoo/odoo-bin -c my-instance.cfg</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="运行原理…"><a href="#运行原理…" class="headerlink" title="运行原理…"></a>运行原理…</h3><p>在重启 Odoo 时，会读取配置文件。addons_path变量的值应为一个逗号分隔的目录列表。可接受相对路径，但它们是相对于当前工作目录的，因此应在配置文件中尽量避免。</p>
<p>至此，我们仅在Odoo中列出了插件目录，但~&#x2F;odoo-dev&#x2F;local-addons中尚不存在插件模块。即使在该目录中新增了插件模块，Odoo也不会在用户界面中显示这一模块。为此，你需要执行一个额外的操作，在下一部分<em>更新插件模块列表</em>中会进行讲解。</p>
<blockquote>
<p>📝这背后的原因是在初始化新数据库时，Odoo在可用模块中自动列举了自定义模块，但如若在数据库初始化之后新增模块，就需要像<em>更新插件模块列表</em>一节中那样手动更新可用模块列表。</p>
</blockquote>
<h3 id="扩展知识…"><a href="#扩展知识…" class="headerlink" title="扩展知识…"></a>扩展知识…</h3><p>在首次调用 odoo-bin脚本来初始化新数据库时，可以传递一个带逗号分隔目录列表的–addons-path命令行参数。这会以所提供插件路径中所找到的所有插件来初始化可用插件模块列表。这么做时，要显式地包含基础插件目录（odoo&#x2F;odoo&#x2F;addons）以及核心插件目录（odoo&#x2F;addons）。与前面稍有不同的是本地插件目录不能为空（<strong>译者注：</strong> 请先阅读下面的小贴士），它必须要至少包含一个子目录，并包含插件模块的最小化结构。</p>
<p>在<a target="_blank" rel="noopener" href="https://alanhou.org/odoo-14-creating-odoo-add-on-modules/">第三章 创建Odoo插件模块</a>中，我们会来看如何编写你自己的模块。同时，这里有一个生成内容来满足Odoo要求的快捷版黑科技：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir -p ~/odoo-dev/local-addons/dummy</span><br><span class="line">$ touch ~/odoo-dev/local-addons/dummy/__init__.py</span><br><span class="line">$ echo &#x27;&#123;&quot;name&quot;: &quot;dummy&quot;, &quot;installable&quot;: False&#125;&#x27; &gt; \</span><br><span class="line">~/odoo-dev/local-addons/dummy/__manifest__.py</span><br></pre></td></tr></table></figure>

<p>你可以使用–save选项来保存路径至配置文件中：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ odoo/odoo-bin -d mydatabase \</span><br><span class="line">--addons-path=&quot;odoo/odoo/addons,odoo/addons,~/odoo-dev/local-addons&quot; \</span><br><span class="line">--save -c ~/odoo-dev/my-instance.cfg --stop-after-init</span><br></pre></td></tr></table></figure>

<p>本例中，使用相对路径不会有问题，因为它们会在配置文件中转化为绝对路径。</p>
<blockquote>
<p><strong>📝注：</strong> 因为Odoo仅当从命令行中设置路径时在插件路径的目录中查看插件，而不是在从配置文件中加载路径的时候，dummy已不再必要。因此，你可以删除它（或保留到你确定不需要新建一个配置文件时）。</p>
</blockquote>
<h2 id="标准化你的实例目录布局"><a href="#标准化你的实例目录布局" class="headerlink" title="标准化你的实例目录布局"></a>标准化你的实例目录布局</h2><p>我们推荐你在开发和生产环境都使用相似的目录布局。这一标准化会在你要执行运维时体现出用处，它也会缓解你日常工作的压力。</p>
<p>这一部分创建将相似生命周期或相似用途的文件分组放在标准化子目录中的目录结构。</p>
<blockquote>
<p>📝仅在希望以相似的文件结构管理开发和生产环境时才需要学习本节。如果不需要，可以跳过本节。</p>
</blockquote>
<p>此外，不必严格按照本节中相同的目录结构。请自由按照自己的需求来调整这一结构。</p>
<h3 id="如何标准化…"><a href="#如何标准化…" class="headerlink" title="如何标准化…"></a>如何标准化…</h3><p>创建所推荐实例布局，需要执行如下步骤：</p>
<ol>
<li><p>为每个实例创建一个目录：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir ~/odoo-dev/projectname</span><br><span class="line">$ cd ~/odoo-dev/projectname</span><br></pre></td></tr></table></figure>
</li>
<li><p>在名为env&#x2F;的子目录中创建一个Python虚拟环境对象：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ python3 -m venv env</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建一些子目录，如下：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir src local bin filestore logs</span><br></pre></td></tr></table></figure>

<p>这些子目录的功能如下：</p>
<ul>
<li>src&#x2F;：包含Odoo本身的一个拷贝，以及一些第三方插件项目（我们在下一步中添加了Odoo源码）</li>
<li>local&#x2F;：用于保存你针对具体实例的插件</li>
<li>bin&#x2F;：包含各类帮助可执行shell脚本</li>
<li>filestore&#x2F;：用于文件存储</li>
<li>logs&#x2F;（可选）：用于存储服务日志文件</li>
</ul>
</li>
<li><p>克隆Odoo并安装所需依赖包（参见<a target="_blank" rel="noopener" href="https://alanhou.org/odoo-14-installing-the-odoo-development-environment/">第一章 安装Odoo开发环境</a>获取更多内容）：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git clone -b 14.0 --single-branch --depth 1 https://github.com/odoo/odoo.git src/odoo</span><br><span class="line">$ env/bin/pip3 install -r src/odoo/requirements.txt</span><br></pre></td></tr></table></figure>
</li>
<li><p>以bin&#x2F;odoo保存如下shell脚本：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/sh</span><br><span class="line">ROOT=$(dirname $0)/..</span><br><span class="line">PYTHON=$ROOT/env/bin/python3</span><br><span class="line">ODOO=$ROOT/src/odoo/odoo-bin</span><br><span class="line">$PYTHON $ODOO -c $ROOT/projectname.cfg &quot;$@&quot;</span><br><span class="line">exit $?</span><br></pre></td></tr></table></figure>
</li>
<li><p>让该脚本可执行：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ chmod +x bin/odoo</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建一个空的本地模块dummy：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir -p local/dummy</span><br><span class="line">$ touch local/dummy/__init__.py</span><br><span class="line">$ echo &#x27;&#123;&quot;name&quot;: &quot;dummy&quot;, &quot;installable&quot;: False&#125;&#x27; &gt;\</span><br><span class="line">local/dummy/__manifest__.py</span><br></pre></td></tr></table></figure>
</li>
<li><p>为你的实例生成配置文件：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ bin/odoo --stop-after-init --save \</span><br><span class="line"> --addons-path src/odoo/odoo/addons,src/odoo/addons,local \</span><br><span class="line"> --data-dir filestore</span><br></pre></td></tr></table></figure>
</li>
<li><p>添加一个.gitignore文件，用于告诉GitHub排除这些给定目录，这样Git在提交代码时就会忽略掉这些目录，例如 filestore&#x2F;, env&#x2F;, logs&#x2F;和src&#x2F;：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># dotfiles, with exceptions:</span><br><span class="line">.*</span><br><span class="line">!.gitignore</span><br><span class="line"># python compiled files</span><br><span class="line">*.py[co]</span><br><span class="line"># emacs backup files</span><br><span class="line">*~</span><br><span class="line"># not tracked subdirectories</span><br><span class="line">/env/</span><br><span class="line">/src/</span><br><span class="line">/filestore/</span><br><span class="line">/logs/</span><br></pre></td></tr></table></figure>
</li>
<li><p>为这个实例创建一个Git仓库并将已添加的文件添加到Git中：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git init</span><br><span class="line">$ git add .</span><br><span class="line">$ git commit -m &quot;initial version of projectname&quot;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="运行原理…-1"><a href="#运行原理…-1" class="headerlink" title="运行原理…"></a>运行原理…</h3><p>我们生成了一个有明确标签目录和独立角色的干净目录结构。我们使用了不同的目录来存储如下内容：</p>
<ul>
<li>由其它人所维护的代码（src&#x2F;中）</li>
<li>本地相关的具体代码</li>
<li>实例的文件存储(filestore)</li>
</ul>
<p>通过为每个项目建一个virtualenv环境，我们可以确保该项目的依赖文件不会与其它项目的依赖产生冲突，这些项目你可能运行着不同的Odoo版本或使用了不同的第三方插件模块，这将需要不同版本的Python依赖。当然也会带来一部分磁盘空间的开销。</p>
<p>以类似的方式，通过为我们不同的项目使用不同的Odoo拷贝以及第三方插件模块，我们可以让每个项目单独的进行演化并仅在需要时在这些实例上安装更新，因此也减少了引入回退的风险。</p>
<p>bin&#x2F;odoo允许我们不用记住各个路径或激活虚拟环境就可以运行服务。这还为我们设置了配置文件。你可以在其中添加其它脚本来协助日常工作。例如，可以添加一个脚本来检查运行实例所需的第三方项目。</p>
<p>有关配置文件，我们仅展示了这里需要设置的最小化选项，但很明显可以做更多设置，例如数据库名、数据库过滤器或项目所监听的端口。有关这一话题的更多信息，请参见<a target="_blank" rel="noopener" href="https://alanhou.org/odoo-14-installing-the-odoo-development-environment/">第一章 安装Odoo开发环境</a>。</p>
<p>最后，通过在Git仓库中管理所有这些，在不同的电脑上复制这一设置及在团队中分享开发内容变得相当容易。</p>
<blockquote>
<p><strong>📝</strong>加速贴士</p>
<p>要加速项目的创建，可以创建一个包含空结构的模板仓库，并为每个新项目复制（fork）该仓库。这会省却你重新输入bin&#x2F;odoo脚本、.gitignore及其它所需模板文件（持续集成配置、README.md、ChangeLog等等）所花费的时间。</p>
</blockquote>
<h3 id="参见内容"><a href="#参见内容" class="headerlink" title="参见内容"></a>参见内容</h3><p>如果你喜欢这种方法，我们建议你尝试<a target="_blank" rel="noopener" href="https://alanhou.org/server-deployment/">第三章 服务器部署</a>中的使用 Docker 运行 Odoo 一部分的内容。</p>
<h3 id="扩展知识…-1"><a href="#扩展知识…-1" class="headerlink" title="扩展知识…"></a>扩展知识…</h3><p>复杂模块的开发要求有各类配置选项，在想要尝试任何配置选项时都会要更新配置文件。更新配置文件常常是一件头痛的事，避免它的一种方式是通过命令行传递所有配置选项，如下：</p>
<ol>
<li><p>手动激活虚拟环境：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ source env/bin/activate</span><br></pre></td></tr></table></figure>
</li>
<li><p>进入Odoo源代码目录：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cd src/odoo</span><br></pre></td></tr></table></figure>
</li>
<li><p>运行服务：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./odoo-bin --addons-path=addons,../../local -d test-14 -i account,sale,purchase --log-level=debug</span><br></pre></td></tr></table></figure></li>
</ol>
<p>第3步中，我们直接通过命令行传递了一些参数。第一个是–addons-path，它加载Odoo的核心插件目录addons，以及你自己的插件目录local，在其中你可以放自己的插件模块。选项-d会使用test-14数据库或者在该数据库不存在时新建一个数据库。选项-i 会安装会计、销售和采购模块。接着，我们传递了log-level选项来将日志级别提升为debug，这样日志中会显示更多的信息。</p>
<blockquote>
<p>📝通过使用命令行，你可以快速地修改配置选项。也可以在Terminal中查看实时日志。所有可用选项可参见<a target="_blank" rel="noopener" href="https://alanhou.org/odoo-14-installing-the-odoo-development-environment/">第一章 安装Odoo开发环境</a>，或使用-help命令来查看所有的选项及各个选项的描述。</p>
</blockquote>
<h2 id="安装并升级本地插件模块"><a href="#安装并升级本地插件模块" class="headerlink" title="安装并升级本地插件模块"></a>安装并升级本地插件模块</h2><p>Odoo 功能的核心来自于它的插件模块。Odoo自带的插件是你所拥有的财富，同时你也可以从应用商店下载一些插件模块或者自己写插件。</p>
<p>这一节中，我们将展示如何通过网页界面及命令行来安装和升级插件模块。</p>
<p>对这些操作使用命令行的主要好处有可以同时作用于一个以上的插件以及在安装或升级的过程中可以清晰地浏览到服务端日志，对于开发模式或编写脚本安装实例时都非常有用。</p>
<h3 id="准备工作-1"><a href="#准备工作-1" class="headerlink" title="准备工作"></a>准备工作</h3><p>确保你有一个运行中的 Odoo 实例，且数据库已初始化、插件路径已进行恰当地设置。在这一部分中，我们将安装&#x2F;升级一些插件模块。</p>
<h3 id="如何安装升级…"><a href="#如何安装升级…" class="headerlink" title="如何安装升级…"></a>如何安装升级…</h3><p>安装或升级插件有两种方法-可以使用网页界面或命令行。</p>
<h4 id="通过网页界面"><a href="#通过网页界面" class="headerlink" title="通过网页界面"></a>通过网页界面</h4><p>可按照如下步骤来使用网页界面安装新的插件模块到数据库中：</p>
<ol>
<li><p>使用管理员账户连接实例并打开Apps菜单<br><a target="_blank" rel="noopener" href="https://alanhou.org/homepage/wp-content/uploads/2019/05/2019050906002399.jpg"><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1c66575a6d24401c97735ac64bffe373~tplv-k3u1fbpfcp-zoom-1.image" alt="Apps 页面"></a>图2.1 – Odoo应用列表</p>
</li>
<li><p>使用搜索框来定位你想要安装的插件。这里有一些帮助你完成该任务的操作指南：</p>
<ul>
<li>激活Not Installed过滤器</li>
<li>如果你要查找一个具体的功能插件而不是广泛的功能插件，删除Apps过滤器</li>
<li>在搜索框中输入模块名的一部分并使用它来作为模块过滤器</li>
<li>你会发现使用列表视图可以阅读到更多的信息</li>
</ul>
</li>
<li><p>点击卡片中模块名下的Install按钮。</p>
</li>
</ol>
<p>注意有些Odoo插件模块具有外部Python依赖，如果你的系统中未安装该Python依赖，那么 Odoo 会中止安装并显示如下的对话框：</p>
<p><a target="_blank" rel="noopener" href="https://alanhou.org/homepage/wp-content/uploads/2019/05/2019050906125210.jpg"><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dca7688da2b7421d82702eca72530b1a~tplv-k3u1fbpfcp-zoom-1.image" alt="pyldap 安装依赖"></a>图2.2 – 外部库依赖的警告<br><strong>译者注：</strong> 按正常安装不会出现一错误，需通过 pip uninstall pyldap 才能复现这一错误</p>
<p>修复这一问题，仅需在你的系统中安装相关的Python依赖即可。</p>
<p>要升级已安装到数据库的模块，使用如下步骤：</p>
<ol>
<li><p>使用管理员账户连接到实例</p>
</li>
<li><p>打开Apps菜单</p>
</li>
<li><p>点击Apps:<br><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cdc90ff9a2264b2dadabea6da6a23a40~tplv-k3u1fbpfcp-zoom-1.image" alt="图2.3 – Odoo应用列表"><br>图2.3 – Odoo应用列表</p>
</li>
<li><p>使用搜索框来定位你所安装的插件。有如下的小贴士：</p>
<ul>
<li>激活Installed过滤器</li>
<li>如果你要查找一个具体的功能插件而不是广义的功能插件，删除Apps过滤器</li>
<li>在搜索框中输入部分插件模块的名称并按下 Enter 来使用它作为模块过滤器。例如，输入CRM并按下 Enter 来搜索CRM应用</li>
<li>你会发现使用列表视图可以阅读到更多的信息</li>
</ul>
</li>
<li><p>点击卡片右上角的的三个点，然后点击Upgrade选项：</p>
</li>
</ol>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/490ce5d0c0434150b5d54a540fbfc539~tplv-k3u1fbpfcp-zoom-1.image" alt="图2.4 – 升级模块的下拉链接 "></p>
<p>图2.4 – 升级模块的下拉链接</p>
<p>激活开发者模式来查看模块的技术名称。如果你不知道如何激活开发者模式，请参见<a target="_blank" rel="noopener" href="https://alanhou.org/odoo-14-installing-the-odoo-development-environment/">第一章 安装Odoo开发环境</a>：</p>
<p><a target="_blank" rel="noopener" href="https://alanhou.org/homepage/wp-content/uploads/2019/05/2019050906302261.jpg"><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fcd6301aab3247159081111c07297b5f~tplv-k3u1fbpfcp-zoom-1.image" alt="查看模块技术名称"></a></p>
<p>图2.5 – 应用的技术名称</p>
<p>在激活开发者模式之后，它会以红色显示模块的技术名称。如果你使用的是Odoo社区版，会看到一些带有Upgrade按钮的应用。这些是Odoo企业版的应用，要想安装&#x2F;使用它们，需要购买一个证书。</p>
<h4 id="通过命令行"><a href="#通过命令行" class="headerlink" title="通过命令行"></a>通过命令行</h4><p>在数据库中安装新插件，可执行如下步骤：</p>
<ol>
<li><p>查找插件的名称。这是包含__manifest__.py文件的目录名，不带前面的路径。</p>
</li>
<li><p>停止实例。如果你在操作生产数据库，请进行备份。</p>
</li>
<li><p>运行如下命令：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ odoo/odoo-bin -c instance.cfg -d dbname -i addon1,addon2 --stop-after-init</span><br></pre></td></tr></table></figure>

<p>如果在配置文件中进行过设置可以省略掉-d dbname。<br><strong>译者注：</strong> 请将addon1,addon2替换为你所要安装的插件名</p>
</li>
<li><p>重启实例</p>
</li>
</ol>
<p>升级数据库中已安装的插件，可执行如下步骤：</p>
<ol>
<li><p>查找待更新的插件模块名称。这是包含__manifest__.py文件的目录名，不带前面的路径。</p>
</li>
<li><p>停止实例。如果你在操作生产数据库，请进行备份。</p>
</li>
<li><p>运行如下命令：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ odoo/odoo-bin -c instance.cfg -d dbname - u addon1 --stop-after-init</span><br></pre></td></tr></table></figure>

<p>如果在配置文件中进行过设置可以省略掉-d dbname。</p>
</li>
<li><p>重启实例</p>
</li>
</ol>
<h3 id="运行原理…-2"><a href="#运行原理…-2" class="headerlink" title="运行原理…"></a>运行原理…</h3><p>插件模块的安装和升级是两个紧密关联的操作，但有一些重要的区别，在下面两部分中进行了强调：</p>
<h4 id="插件安装"><a href="#插件安装" class="headerlink" title="插件安装"></a>插件安装</h4><p>在安装插件时，Odoo以提供的名称检查它的可用插件列表中未安装插件。它还会检查该插件的依赖，并且如果有依赖的话，它会在安装插件前递归安装这些依赖。</p>
<p>单个模块的安装包含如下步骤：</p>
<ol>
<li>如果存在，运行插件preinit钩子</li>
<li>从Python源代码中加载模型定义并在必要时更新数据库结构（参见<a target="_blank" rel="noopener" href="https://alanhou.org/odoo-14-application-models/">第四章 应用模型</a>了解更多信息）</li>
<li>加载插件的数据文件并在必要时更新数据库内容（参见<a target="_blank" rel="noopener" href="https://alanhou.org/odoo-14-module-data/">第六章 管理模块数据</a>了解更多信息）</li>
<li>如果实例中启用了演示数据则安装插件演示数据</li>
<li>如果存在，运行插件postinit钩子</li>
<li>运行对插件视图定义的验证</li>
<li>如果启用了演示数据及测试，运行该插件的测试（参见<a target="_blank" rel="noopener" href="https://alanhou.org/odoo-14-automated-test-cases/">第十八章 自动化测试用例</a>了解更多信息）</li>
<li>在数据库中更新模块状态</li>
<li>从插件的翻译文件中更新数据库中的翻译（参见<a target="_blank" rel="noopener" href="https://alanhou.org/odoo-14-internationalization/">第十一章 国际化</a>了解更多信息）</li>
</ol>
<blockquote>
<p>📝preinit和postinit钩子分别使用pre_init_hook和post_init_hook键名在__manifest__.py文件中定义。这些钩子用于在插件模块的安装之前及之后触发Python函数。参见<a target="_blank" rel="noopener" href="https://alanhou.org/odoo-14-creating-odoo-add-on-modules/">第三章 创建Odoo插件模块</a>了解更多有关 init 钩子的知识。</p>
</blockquote>
<h4 id="插件升级"><a href="#插件升级" class="headerlink" title="插件升级"></a>插件升级</h4><p>升级插件时，Odoo以给定的名称在可用的插件模块列表中检查已安装插件。它还会检查该插件的反向依赖（即依赖于所升级插件的那些插件）。如果存在，则也会对它们进行递归升级。</p>
<p>单个插件模块的升级过程包含如下步骤：</p>
<ol>
<li>如果存在，先运行插件模块的预迁移步骤（参见<a target="_blank" rel="noopener" href="https://alanhou.org/odoo-14-module-data/">第六章 管理模块数据</a>了解更多信息）</li>
<li>从Python源码中加载模型定义并在必要时更新数据库结构（参见<a target="_blank" rel="noopener" href="https://alanhou.org/odoo-14-application-models/">第四章 应用模型</a>了解更多信息）</li>
<li>加载插件的数据文件并在必要时更新数据库内容（参见<a target="_blank" rel="noopener" href="https://alanhou.org/odoo-14-module-data/">第六章 管理模块数据</a>了解更多信息）</li>
<li>如果实例中启用了演示数据更新插件演示数据</li>
<li>如果模块有任何迁移方法的话，运行插件模块的后置迁移步骤（参见<a target="_blank" rel="noopener" href="https://alanhou.org/odoo-14-module-data/">第六章 管理模块数据</a>了解更多信息）</li>
<li>运行对插件视图定义的验证</li>
<li>如果启用了演示数据并启用了测试，运行该插件的测试（参见<a target="_blank" rel="noopener" href="https://alanhou.org/odoo-14-automated-test-cases/">第十八章 自动化测试用例</a>了解更多信息）</li>
<li>在数据库中更新模块状态</li>
<li>从插件的翻译文件中更新数据库中的翻译（参见<a target="_blank" rel="noopener" href="https://alanhou.org/odoo-14-internationalization/">第十一章 国际化</a>了解更多信息）</li>
</ol>
<blockquote>
<p>📝注意更新未安装的插件模块时什么也不会做。但是安装已安装的插件模块会重新安装该插件，这会通过一些包含数据的数据文件产生一些预期外的问题，这些文件应由用户进行更新而非在常规的模块升级处理时进行更新（参见<a target="_blank" rel="noopener" href="https://alanhou.org/odoo-14-module-data/">第六章 管理模块数据</a>中使用noupdate和forcecreate标记部分的内容）。通过用户界面不存在错误的风险，但通过命令行时则有可能发生。</p>
</blockquote>
<h3 id="扩展知识…-2"><a href="#扩展知识…-2" class="headerlink" title="扩展知识…"></a>扩展知识…</h3><p>要当心依赖的处理。假定有一个实例你想要对其安装sale、sale_stock和sale_specific插件，sale_specific依赖于sale_stock，而sale_stock依赖于sale。要安装这三者，你只需要安装sale_specific，因为它会递归安装sale_stock和sale这两个依赖。要升级这三者，需要升级sale，因为这样会递归升级其反向依赖，sale_stock和sale_specific。</p>
<p>管理依赖另一个比较搞的地方是在你向已经安装了一个版本的插件添加依赖的时候。我们继续通过前例来理解这一问题。想像一下在sale_specific中添加了一个对stock_dropshipping的依赖。更新sale_specific插件不会自动安装新的依赖，也不会要求安装sale_specific。在这种情况下，你会收到非常糟糕的错误消息，因为插件的Python代码没有成功加载，而插件的数据和模型表则已存在于数据库中。要解决这一问题，你需要停止该实例并手动安装新的依赖。</p>
<h2 id="从GitHub安装插件模块"><a href="#从GitHub安装插件模块" class="headerlink" title="从GitHub安装插件模块"></a>从GitHub安装插件模块</h2><p>GitHub是第三方插件一个很好的来源。很多Odoo合作伙伴使用GitHub来分享他们内部维护的插件，而Odoo社区联盟（OCA）在GitHub上共同维护着几百个插件。在你开始编写自己的插件之前，确保查看是否已有可直接使用的插件或者作为初始以继续扩展的插件。</p>
<p>这一部分向你展示如何从GitHub上克隆OCA的partner-contact项目并让其中所包含的插件模块在我们实例中可用。</p>
<h3 id="准备工作-2"><a href="#准备工作-2" class="headerlink" title="准备工作"></a>准备工作</h3><p>假设你希望对客户(partner) 表单添加新的字段。默认Odoo客户模型不包含gender字段。如果要添加gender字段，需要新建一个模块。所幸邮件列表中有人告诉你有partner_contact_gender这么一个插件模块，由OCA作为partner-contact项目的一部分进行维护。</p>
<p>本部分中所使用的路径反映了我们在<em>标准化你的实例目录布局</em>一节中所推荐的布局。</p>
<h3 id="如何安装…"><a href="#如何安装…" class="headerlink" title="如何安装…"></a>如何安装…</h3><p>按照如下步骤来安装partner_contact_gender：</p>
<ol>
<li><p>进入项目目录：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cd ~/odoo-dev/my-odoo/src</span><br></pre></td></tr></table></figure>
</li>
<li><p>在src&#x2F;目录中克隆partner-contact项目的14.0分支：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git clone --branch 14.0 \</span><br><span class="line">https://github.com/OCA/partner-contact.git src/partner-contact</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改插件路径来包含该目录并更新你的实例中的插件列表（参见本章中的<em>配置插件路径</em>和<em>更新插件模块列表</em>小节）。instance.cfg中的addons_path一行应该是这样的：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">addons_path = ~/odoo-dev/my-odoo/src/odoo/odoo/addons, \</span><br><span class="line">~/odoo-dev/my-odoo/src/odoo/addons, \</span><br><span class="line">~/odoo-dev/my-odoo/src/, \</span><br><span class="line">~/odoo-dev/local-addons</span><br></pre></td></tr></table></figure>
</li>
<li><p>安装partner_contact_gender插件（如果你不知道如何安装该模块，参见前面的小节，<em>安装并升级本地插件模块</em>）</p>
</li>
</ol>
<h3 id="运行原理…-3"><a href="#运行原理…-3" class="headerlink" title="运行原理…"></a>运行原理…</h3><p>Odoo社区联盟的所有代码仓库都将他们自己的插件放在单独的子目录中，这与Odoo对插件路径中目录的要求是一致的。因此，只需复制某处的仓库并将其添加到插件路径中就够了。</p>
<h3 id="扩展知识…-3"><a href="#扩展知识…-3" class="headerlink" title="扩展知识…"></a>扩展知识…</h3><p>有些维护者遵循不同的方法，每个插件模块一个仓库，放在仓库的根目录下。这种情况下，需要新建一个目录，在这个目录中添加插件路径并克隆所需维护者的插件到该目录中。记住在每次添加一个新仓库克隆时要更新插件模块列表。</p>
<h2 id="对插件应用修改"><a href="#对插件应用修改" class="headerlink" title="对插件应用修改"></a>对插件应用修改</h2><p>GitHub上可用的大部分插件需要进行修改并且不遵循Odoo对其稳定发行版所强制的规则。它们可能进行漏洞修复或改善，包含你提交的问题或功能请求，这些修改可能会带来数据库模式的修改或数据文件和视图中的更新。这一部分讲解如何安装升级后的版本。</p>
<h3 id="准备工作-3"><a href="#准备工作-3" class="headerlink" title="准备工作"></a>准备工作</h3><p>假定你对partner_contact_gender报告了一个问题并收到通知说该问题已在partner-contact项目14.0分支的最近一次修订中得以解决。这种情况下，你可以使用最新版本来更新实例。</p>
<h3 id="如何修改…"><a href="#如何修改…" class="headerlink" title="如何修改…"></a>如何修改…</h3><p>要对来自GitHub的插件进行源的变更，需执行如下步骤：</p>
<ol>
<li><p>停止使用该插件的实例。</p>
</li>
<li><p>如果是生产实例请进行备份（参见<a target="_blank" rel="noopener" href="https://alanhou.org/odoo-14-installing-the-odoo-development-environment/">第一章 安装Odoo开发环境</a>中<em>管理Odoo服务端数据库</em>一节）。</p>
</li>
<li><p>进入克隆了partner-contact的目录：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cd ~/odoo-dev/my-odoo/src/partner-contact</span><br></pre></td></tr></table></figure>
</li>
<li><p>为该项目创建一个本地标签，这样万一出现了崩溃还可以进行回退：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout 14.0</span><br><span class="line">$ git tag 14.0-before-update-$(date --iso)</span><br></pre></td></tr></table></figure>
</li>
<li><p>获取源码的最新版本：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git pull --ff-only</span><br></pre></td></tr></table></figure>
</li>
<li><p>在数据库中更新partner_contact_gender插件（参见<em>安装并升级本地插件模块</em>一节）</p>
</li>
<li><p>重启实例</p>
</li>
</ol>
<h3 id="运行原理…-4"><a href="#运行原理…-4" class="headerlink" title="运行原理…"></a>运行原理…</h3><p>通常，插件模块的开发者不时会发布插件的最新版本。这一更新一般包含漏洞修复及新功能。这里，我们将获取一个插件的新版本并在我们的实例中更新它。</p>
<p>如果git pull –ff-only失败的话，可以使用如下命令回退到前一个版本：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git reset --hard 14.0-before-update-$(date --iso)</span><br></pre></td></tr></table></figure>

<p>然后，可以尝试git pull（不添加–ff-only），它会产生一个合并，但这表示你对插件做了本地修改。</p>
<h3 id="其它内容…"><a href="#其它内容…" class="headerlink" title="其它内容…"></a>其它内容…</h3><p>如果更新这一步崩溃了，参见<a target="_blank" rel="noopener" href="https://alanhou.org/odoo-14-installing-the-odoo-development-environment/">第一章 安装Odoo开发环境</a><em>从源码更新Odoo</em>一节获取恢复的操作指南。记住要保持首先在生产数据库的拷贝上进行测试。</p>
<h2 id="应用及尝试建议的拉取请求"><a href="#应用及尝试建议的拉取请求" class="headerlink" title="应用及尝试建议的拉取请求"></a>应用及尝试建议的拉取请求</h2><p>在GitHub的世界中，拉取请求（PR）是由开发者所提交的请求，这样项目维护人员可以添加一些新的开发。比如一个 PR 可能包含漏洞修复或新功能。这些请求在拉取到主分支之前会进行审核和测试。</p>
<p>这一部分讲解如何对你的 Odoo 项目应用一个PR来测试漏洞修复的改进。</p>
<h3 id="准备工作-4"><a href="#准备工作-4" class="headerlink" title="准备工作"></a>准备工作</h3><p>在前一节中，假定你对partner_contact_gender 报告了一个问题并收到一条通知在拉取请求中问题已修复，尚未合并到项目的14.0分支中。开发人员要求你验证PR #123中的修复状况。你需要使用这一分支更新一个测试实例。</p>
<p>不应在生产数据库直接使用该分支，因此先创建一个带有生产数据库拷贝的测试环境（参见<a target="_blank" rel="noopener" href="https://alanhou.org/odoo-14-installing-the-odoo-development-environment/">第一章 安装Odoo开发环境</a>）。</p>
<h3 id="如何操作…"><a href="#如何操作…" class="headerlink" title="如何操作…"></a>如何操作…</h3><p>应用并测试一个插件的GitHub拉取请求，需要执行如下步骤：</p>
<ol>
<li><p>停止实例</p>
</li>
<li><p>进入partner-contact所被克隆的目录：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cd ~/odoo-dev/my-odoo/src/partner-contact</span><br></pre></td></tr></table></figure>
</li>
<li><p>为该项目创建一个本地标签，这样万一出现崩溃时你可以回退：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout 14.0</span><br><span class="line">$ git tag 14.0-before-update-$(date --iso)</span><br></pre></td></tr></table></figure>
</li>
<li><p>拉取pull请求的分支。这么做最容易的方式是使用PR编号，在开发者与你沟通时你应该可以看到。在本例中，这个拉取请求编号是123：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git pull origin pull/123/head</span><br></pre></td></tr></table></figure>
</li>
<li><p>在你的数据库中更新partner_contact_gender1插件模块并重启该实例（如果你不知道如何更新该模块的话请参见<em>安装并升级本地插件模块</em>一节）</p>
</li>
<li><p>测试该更新 - 尝试重现问题，或测试你想要的功能。</p>
</li>
</ol>
<p>如果这不能运行，在GitHub的PR页面进行评论，说明你做了什么以及什么不能运行，这样开发者可以更新这个拉取请求。</p>
<p>如果它没有问题，也在PR页面说下；这是PR验证流程中非常重要的一部分；这会加速主分支中的合并。</p>
<h3 id="运行原理…-5"><a href="#运行原理…-5" class="headerlink" title="运行原理…"></a>运行原理…</h3><p>我们在使用一个GitHub功能，使用pull&#x2F;nnnn&#x2F;head分支名称来通过编号进行拉取请求的拉取，其中nnnn是PR的编号。Git pull命令会合并远程分支到我们的分支，在我们基础代码中应用修改。在这之后，我们更新插件模块、对其测试并向作者报告修改是成功或是失败。</p>
<h3 id="扩展知识…-4"><a href="#扩展知识…-4" class="headerlink" title="扩展知识…"></a>扩展知识…</h3><p>如果你想要同步测试它们，你可以针对相同仓库的不同拉取请求重复本节中的第4步。如果你对结果很满意，可以创建一个分支来保留对应用了改变的结果的引用：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b 14.0-custom</span><br></pre></td></tr></table></figure>

<p>使用一个不同的分支会有助于记住你没有使用GitHub的版本，而是一个自定义的版本。</p>
<blockquote>
<p>📝git branch命令可用于列出你仓库中的所有本地分支。</p>
</blockquote>
<p>从这开始，如果需要应用来自GitHub中14.0分支的最近一个审核版本，需要在拉取时不使用–ff-only：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git pull origin 14.0</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://alanhou.github.io/2020/12/25/odoo-cookbook-14-chapter1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Alan Hou">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Alan Hou的个人博客">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Alan Hou的个人博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/12/25/odoo-cookbook-14-chapter1/" class="post-title-link" itemprop="url">Odoo 14开发者指南第一章 安装Odoo开发环境</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2020-12-25 00:00:00" itemprop="dateCreated datePublished" datetime="2020-12-25T00:00:00+08:00">2020-12-25</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2023-02-20 22:17:40" itemprop="dateModified" datetime="2023-02-20T22:17:40+08:00">2023-02-20</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>配置Odoo开发环境有很多种方式。本章中提供了其中的一种，你肯定可以在网上找到其它的教程讲解其它方法。请记住本章中所讲解的是开发环境，与生产环境的要求是不同的。</p>
<p>如果你是一个Odoo开发新手，必须要了解Odoo生态的方方面面。第一部分会给出这些方面的简短介绍，然后我们就会进入到Odoo开发所需的安装。</p>
<p>本章中，我们将讲解如下主题：</p>
<ul>
<li>了解Odoo生态系统</li>
<li>源码轻松安装Odoo</li>
<li>管理Odoo服务端数据库</li>
<li>在文件中存储实例配置</li>
<li>启用Odoo开发者工具</li>
<li>更新插件模块列表</li>
</ul>
<p>参考安装脚本：<a target="_blank" rel="noopener" href="https://github.com/alanhou/odoo14-cookbook/tree/main/Chapter01">Github</a></p>
<h2 id="了解Odoo生态系统"><a href="#了解Odoo生态系统" class="headerlink" title="了解Odoo生态系统"></a>了解Odoo生态系统</h2><p>Odoo为开发者提供了开箱即用的模块结构。它强大的框架有助于开发者很快地构建项目。在开启成为成功的Odoo开发者之旅以前，应该要熟悉Odoo生态中的一些特性。</p>
<h3 id="Odoo版本"><a href="#Odoo版本" class="headerlink" title="Odoo版本"></a>Odoo版本</h3><p>Odoo有两个版本。第一个是社区版，完全开源，另一个是企业版，需要支付授权证书费用。不同于其它软件供应商，Odoo企业版仅仅是在社区版基础上添加了一些附加特性或新应用的高级应用。基本上，企业版运行于社区版之上。社区版采用Lesser General Public License v3.0 (LGPLv3)许可证书，并带有企业版企业资源计划（ERP）的所有基础应用，如销售、客户关系管理（CRM）、发票、采购、网站构建器等等。而企业版采用 Odoo 企业版许可证书，这是一个自有证书。Odoo 企业版带有很多高级功能如完整的财务、studio、基于IP的语音传输（VoIP）、移动端响应式设计、电子签名、营销自动化、快递与银行的集成以及IoT等。企业版还为你提供无限的漏洞修复支持。下图显示了企业版依赖于社区版，这也是为什么使用企业版时需要用到社区版：</p>
<p><a target="_blank" rel="noopener" href="http://alanhou.org/homepage/wp-content/uploads/2019/05/2019050403383533.png"><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/129c5e10025a47e8ae4b26ccd889cf41~tplv-k3u1fbpfcp-zoom-1.image" alt="图1.1 – 社区版和企业版的差别"></a></p>
<p> </p>
<p>图1.1 – 社区版和企业版的差别</p>
<p>读者可以访问<a target="_blank" rel="noopener" href="https://www.odoo.com/page/editions%E6%9F%A5%E7%9C%8B%E8%BF%99%E4%B8%A4%E4%B8%AA%E7%89%88%E6%9C%AC%E7%9A%84%E5%AE%8C%E6%95%B4%E5%AF%B9%E6%AF%94%E3%80%82">https://www.odoo.com/page/editions查看这两个版本的完整对比。</a></p>
<blockquote>
<p>📝Odoo有数量庞大的社区开发人员，这也是你在应用商店中看到有大量的第三方应用（模块）的原因。有些免费应用使用Affero General Public License version 3 (AGPLv3)许可证书。如果你的应用依赖于这些应用就不能使用其自有证书。Odoo自有证书的应用仅能在拥有LGPL或其它自有证书的模块基础上进行开发。</p>
</blockquote>
<h3 id="Git仓库"><a href="#Git仓库" class="headerlink" title="Git仓库"></a>Git仓库</h3><p>Odoo的完整代码托管在GitHub上。可以在这里对稳定版提交漏洞&#x2F;问题。还可以通过提交拉取请求（Pull Request - PR）来提议添加新功能。Odoo有许多个仓库，参见下表来获取更多信息：</p>
<table>
<thead>
<tr>
<th>仓库</th>
<th>用途</th>
</tr>
</thead>
<tbody><tr>
<td><a target="_blank" rel="noopener" href="https://github.com/odoo/odoo">https://github.com/odoo/odoo</a></td>
<td>这是 Odoo 的社区版。对公众开放。</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://github.com/odoo/enterprise">https://github.com/odoo/enterprise</a></td>
<td>这是 Odoo 的企业版。仅对Odoo 官方合作伙伴开放。</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://github.com/odoo-dev/odoo">https://github.com/odoo-dev/odoo</a></td>
<td>这是不断开发中的仓库。对公众开放。(已废弃)</td>
</tr>
</tbody></table>
<p>每年，Odoo会发布一个大版本（长期支持(LTS)版本）和数个小版本。小版本多用于Odoo的在线SaaS服务，也就是说Odoo的SaaS用户可以更早地使用到这些功能。GitHub 上大版本分支的名称像14.0, 13.0和12.0，而小版本分支名称有saas-14.1和saas-14.2。小版本多用于Odoo 的SaaS平台。master分支处于开发中，不稳定，因此，不建议在生产环境中使用它，因为它可能导致数据库的崩溃。</p>
<h3 id="Runbot"><a href="#Runbot" class="headerlink" title="Runbot"></a>Runbot</h3><p>Runbot是Odoo的自动化测试环境。在Odoo的Github 分支中有新提交时，Runbot会拉取最新的修改并并创建最近4个提交的构建。这里，你可以测试所有的稳定版和开发中的分支。甚至可以使用到企业版并测试它的开发分支。</p>
<p>每个构建有不同的背景色，表明测试用例的状态。绿色背景表示所有的测试用例成功运行，用户可以测试该分支，而红色背景表示在这个分支上有些测试用例出错了，有些功能在该构建上可能出现崩溃。可以查看到所有测试用例的日志，会显示在安装过程中所发生的具体问题。每个构建有两个数据库。数据库all安装了所有的模块，而数据库base仅安装了Odoo的基础模块。每个构建均安装了基本演示数据，因此可以快速进行测试而无需额外的配置。</p>
<blockquote>
<p>ℹ️使用如下 URL 来访问runbot：<a target="_blank" rel="noopener" href="http://runbot.odoo.com/runbot">http://runbot.odoo.com/runbot</a></p>
</blockquote>
<p>以下账户信息可用于访问任一runbot构建：</p>
<ul>
<li>登录ID: admin 密码: admin</li>
<li>登录ID:demo 密码: demo</li>
<li>登录ID: portal 密码: portal</li>
</ul>
<blockquote>
<p>📝这是公共测试环境，因此有时可能会有其它用户使用&#x2F;测试你所测试的相同分支。</p>
</blockquote>
<h3 id="Odoo应用商店"><a href="#Odoo应用商店" class="headerlink" title="Odoo应用商店"></a>Odoo应用商店</h3><p>Odoo在几年前发布了应用商店，当即大热。现在，那里托管着22,000多个不同的应用。在应用商店中，可以找到大量的针对不同版本的免费和付费应用。包含不同垂直业务领域的具体解决方案，如教育、食品行业和医药业。它还包含一些继承了已有Odoo应用或添加了新功能的应用。应用商店还为Odoo网站构建器提供了大量的美观的主题。在<a target="_blank" rel="noopener" href="https://alanhou.org/odoo-14-creating-odoo-add-on-modules/">第三章 创建Odoo插件模块</a>中，我们将学习如何为你的自定义模块设置价格和币种。</p>
<p>可以通过如下链接访问Odoo应用商店：<a target="_blank" rel="noopener" href="https://www.odoo.com/apps%E3%80%82">https://www.odoo.com/apps。</a></p>
<blockquote>
<p>📝Odoo开源了很版本13和14的主题。在此前的版本均为付费主题。也就是在 Odoo 13和14中无需花费额外费用即可下载、使用这些漂亮的主题。</p>
</blockquote>
<h3 id="Odoo社区联盟（OCA）"><a href="#Odoo社区联盟（OCA）" class="headerlink" title="Odoo社区联盟（OCA）"></a>Odoo社区联盟（OCA）</h3><p>Odoo社区联盟（OCA）是一个开发&#x2F;管理Odoo社区模块的非营利组织。所有的OCA模块都开源并由Odoo社区成员维护。在OCA的GitHub账户下，可以找到针对不同Odoo应用的多个仓库。除Odoo模块外，它还包含很多工具、迁移库、会计本地化等等。</p>
<p>以下是OCA官方GitHub账号的URL：<a target="_blank" rel="noopener" href="https://github.com/OCA%E3%80%82">https://github.com/OCA。</a></p>
<h3 id="Odoo官方帮助论坛"><a href="#Odoo官方帮助论坛" class="headerlink" title="Odoo官方帮助论坛"></a>Odoo官方帮助论坛</h3><p>Odoo 拥有一个非常强大的框架，大量的操作只需通过使用&#x2F;激活选项或遵循指定的模式即可实现。因此，如果你碰到了一些技术问题或是对一些复杂用例不确定，那么就可以在Odoo官方帮助论坛上询问。这个论坛上有大量活跃的开发人员，包含一些Odoo官方的员工。</p>
<p>在如下 URL 上可以搜索或提交你的问题：<a target="_blank" rel="noopener" href="https://help.odoo.com/%E3%80%82">https://help.odoo.com/。</a></p>
<h3 id="Odoo的eLearning平台"><a href="#Odoo的eLearning平台" class="headerlink" title="Odoo的eLearning平台"></a>Odoo的eLearning平台</h3><p>最近Odoo发布了一个全新的eLearning平台。该平台上有大量的视频讲解如何使用各类Odoo应用。在编写本书时，平台上还没有技术相关视频，只是一些介绍功能的视频。</p>
<p>eLearning平台的网址为：<a target="_blank" rel="noopener" href="https://www.odoo.com/slides%E3%80%82">https://www.odoo.com/slides。</a></p>
<h2 id="通过源码轻松安装Odoo"><a href="#通过源码轻松安装Odoo" class="headerlink" title="通过源码轻松安装Odoo"></a>通过源码轻松安装Odoo</h2><p>强烈推荐使Linux Ubuntu操作系统来安装Odoo，因为这是Odoo测试、调试和安装Odoo企业版所使用的操作系统，此外大部分的Odoo开发人员都使用GNU&#x2F;Linux，使用GNU&#x2F;Linux而非Windows或macOS会更有机会获取操作系统相关问题的社区支持。</p>
<p>也推荐使用和生产环境相同的环境（相同发行版和版本号）进行开发。这样可以避免讨厌的“彩蛋”，比如在部署当天发现有个库有一个预料外的版本，会有一些不同和不兼容的问题。如果你的工作站使用不同的操作系统，一种推荐的方式是在工作站上配置虚拟机（VM）并在 VM 上安装 GNU&#x2F;Linux发行版。</p>
<blockquote>
<p>📝Ubuntu已成为微软商店中的一个应用，如果不希望切换操作系统的话也可以使用它。</p>
</blockquote>
<p>本书假定读者使用的是Ubuntu 18.04 LTS版，但也可以使用其它的GNU&#x2F;Linux系统。不论你选择哪个Linux发行版，都应该要有一个从命令行使用它的概念，有系统运维相关知识显然会更好。</p>
<p>相关文章：<a target="_blank" rel="noopener" href="https://alanhou.org/odoo14-installation/">Odoo 14安装简明教程（CentOS）</a></p>
<h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><p>假设读者已运行了Ubuntu 18.04并已拥有 root 密码或配置了sudo拥有root访问权限。下面的部分中，我们将安装Odoo的相关依赖并通过GitHub下载Odoo源码。</p>
<blockquote>
<p>ℹ️有些配置需要使用到系统登录用户，这里我们在需要用到用户名时在命令行中使用$(whoami)。这个shell命令可以在所键入命令中替换为登录用户。</p>
</blockquote>
<p>如果你有GitHub账户的话有些操作一定会更容易。如果还没有GitHub账户，请访问<a target="_blank" rel="noopener" href="https://github.com并创建账户./">https://github.com并创建账户。</a></p>
<h3 id="如何安装…"><a href="#如何安装…" class="headerlink" title="如何安装…"></a>如何安装…</h3><p>使用源码安装 Odoo，需要按照如下的步骤：</p>
<ol>
<li><p>运行如下命令来安装主要依赖：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get update</span><br><span class="line">$ sudo apt install git python3-pip build-essential wget python3-dev python3-venv python3-wheel libxslt-dev libzip-dev libldap2-dev libsasl2-dev python3-setuptools libpq-dev -y</span><br></pre></td></tr></table></figure>
</li>
<li><p>下载并安装wkhtmltopdf：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ wget https://github.com/wkhtmltopdf/wkhtmltopdf/releases/download/0.12.5/wkhtmltox_0.12.5-1.bionic_amd64.deb</span><br><span class="line">$ sudo dpkg -i wkhtmltox_0.12.5-1.bionic_amd64.deb</span><br></pre></td></tr></table></figure>

<p>如果以上命令出现了报错，通过如下命令可强制安装依赖：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get install -f</span><br></pre></td></tr></table></figure>
</li>
<li><p>此时安装PostgreSQL数据库  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt install postgresql -y</span><br></pre></td></tr></table></figure>
</li>
<li><p>配置PostgreSQL  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo -u postgres createuser --superuser $(whoami)</span><br></pre></td></tr></table></figure>

<p><strong>译者注：</strong> 如果报错说明服务未启动createuser: could not connect to database template1: could not connect to server: No such file or directory</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl start postgresql</span><br></pre></td></tr></table></figure>
</li>
<li><p>配置git（以下信息请自行修改）：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global user.name &quot;Your Name&quot;</span><br><span class="line">$ git config --global user.email youremail@example.com</span><br></pre></td></tr></table></figure>
</li>
<li><p>克隆 Odoo 基础代码：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir ~/odoo-dev</span><br><span class="line">$ cd ~/odoo-dev</span><br><span class="line">$ git clone -b 14.0 --single-branch --depth 1 https://github.com/odoo/odoo.git</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建一个odoo-14.0 虚拟环境并启用：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ python3 -m venv ~/venv-odoo-14.0</span><br><span class="line">$ source ~/venv-odoo-14.0/bin/activate</span><br></pre></td></tr></table></figure>
</li>
<li><p>在venv中安装Odoo的Python依赖：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cd ~/odoo-dev/odoo/</span><br><span class="line">$ pip3 install -r requirements.txt</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建并启动第一个Odoo实例：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ createdb odoo-test</span><br><span class="line">$ python3 odoo-bin -d odoo-test -i base --addons-path=addons --db-filter=odoo-test$</span><br></pre></td></tr></table></figure>
</li>
<li><p>在浏览器中访问<a href="http://localhost:8069（虚拟机请修改为对应的">http://localhost:8069（虚拟机请修改为对应的</a> IP 地址），并使用admin账户和密码admin来进行登录  </p>
<blockquote>
<p>📝如需RTL（文字从右向左）的支持，请使用如下命令安装node 和 rtlcss ：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install nodejs npm -y</span><br><span class="line"> sudo npm install -g rtlcss</span><br></pre></td></tr></table></figure></blockquote>
</li>
</ol>
<h3 id="运行原理…"><a href="#运行原理…" class="headerlink" title="运行原理…"></a>运行原理…</h3><p>第1步中，我们安装了一些核心依赖。这些依赖包含各类工具，如git, pip3, wget, Python设置工具等。这些核心工作帮助我们使用简单命令安装其它Odoo依赖。</p>
<p>第2步中，我们下载并安装了wkhtmltopdf包，用于在Odoo中将销售订单、发票等报告打印为PDF文档。Odoo 14.0要求使用wkhtmltopdf的0.12.5版本，这一版本可能在当前Linux发行版中并未包含。所幸wkhtmltopdf的维护者在<a target="_blank" rel="noopener" href="http://wkhtmltopdf.org/downloads.html%E4%B8%BA%E6%88%91%E4%BB%AC%E6%8F%90%E4%BE%9B%E4%BA%86%E9%92%88%E5%AF%B9%E5%90%84%E5%8F%91%E8%A1%8C%E7%89%88%E7%9A%84%E9%A2%84%E6%9E%84%E5%BB%BA%E5%8C%85%EF%BC%8C%E9%80%9A%E8%BF%87%E8%AF%A5URL%E5%8F%AF%E8%BF%9B%E8%A1%8C%E4%B8%8B%E8%BD%BD%E5%8F%8A%E5%AE%89%E8%A3%85%E3%80%82">http://wkhtmltopdf.org/downloads.html为我们提供了针对各发行版的预构建包，通过该URL可进行下载及安装。</a></p>
<h4 id="PostgreSQL配置"><a href="#PostgreSQL配置" class="headerlink" title="PostgreSQL配置"></a>PostgreSQL配置</h4><p>第3步中，我们安装了PostgreSQL数据库。</p>
<p>第4步中，我们通过系统登录用户名新建了一个数据库。$(whoami) 用于获取系统用户名，-s选项用于授予超级用户权限。我们来了解下为什么需要这些配置。</p>
<p>Odoo使用psycopg2 Python库来与PostgreSQL数据库建立连接。通过psycopg2库访问PostgreSQL数据库。Odoo使用如下的默认值：</p>
<ul>
<li>默认psycopg2尝试使用本地连接的当前用户相同的用户名来连接数据库，这会启动无密码认证（在开发环境中这样很好）</li>
<li>本地连接使用Unix域套接字</li>
<li>数据库服务监听5432端口</li>
</ul>
<p>这样就好了！PostgreSQL现在就做好了与Odoo建立连接的准备。</p>
<p>因为这个是开发服务器，我们对用户授予了–superuser的权限。对生产实例，可以在命令行中使用–createdb来代替–createdb以进行权限限制。在生产服务上–superuser权限会给予黑客在一些部署代码中找到更多漏洞的机会。</p>
<p>如果想使用不同的数据库用户，则需提供该用户的密码。通过在创建用户时在命令行传递–pwprompt标记来实现，此时命令行会提示你输入密码。</p>
<p>如果用户已存在而你又想要为其设置密码（或修改已忘记的密码），可以使用如下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ psql -c &quot;alter role $(whoami) with password &#x27;newpassword&#x27;&quot;</span><br></pre></td></tr></table></figure>

<p>如果这个命令执行报错提示数据库不存在，那是因为你没按照操作步骤的第4步创建一个与当前登录名相同的数据库。不必担心，仅需使用 –dbname选项来添加已有数据库名，例如 –dbname template1。</p>
<h4 id="Git配置"><a href="#Git配置" class="headerlink" title="Git配置"></a>Git配置</h4><p>开发环境我们使用GitHub上的Odoo源代码。借助于git可以轻松地在各个Odoo版本间进行切换。同时可以使用git pull命令拉取最新的修改。</p>
<p>在第5步中，我们配置了git用户信息。</p>
<p>第6步中，我们从Odoo官方GitHub仓库下载了源代码。使用的是git clone命令来下载Odoo源代码。指定了单分支这样只需要下载14.0版本的分支即可。同时还使用了–depth 1来避免下载该分支的完整历史提交。这些选项会让源代码下载变得快速，你也可以在需要的时候省略掉这些选项。</p>
<p>Odoo开发者还推荐nightly构建，以tar文件和发行包的形式出现。使用git clone最主要的优势是在源代码树中提交了新的bug修复时可以对仓库直接进行更新。还能够轻松地测试所推荐的修复并追踪回退，这样会让bug报告更为精确、对开发者也更有帮助。</p>
<blockquote>
<p>📝如果你可以访问企业版源代码，也可以将其下载到~&#x2F;odoo-dev目录下面单独的文件夹中。</p>
</blockquote>
<h4 id="虚拟环境"><a href="#虚拟环境" class="headerlink" title="虚拟环境"></a>虚拟环境</h4><p>Python虚拟环境或简称virtualenv，是隔离的Python工作空间。这些对于Python开发者非常有用，因为它们允许在Python解释器版本上安装不同版本的Python库。</p>
<p>你可以使用python3 -m venv ~&#x2F;newvenv命令来创建所需数量的环境。这会在指定位置创建一个newenv目录，其中包含一个bin&#x2F;子目录和一个lib&#x2F;python3.6（<strong>译者注：</strong> 或你安装的其它 Python 3版本）子目录。</p>
<p>在第7步中，我们在~&#x2F;venv-odoo-14.0目录下新建了一个虚拟环境。这就是我们为Odoo准备的独立Python环境。Odoo的所有Python依赖都在这一环境中进行安装。</p>
<p>要启用虚拟环境，我们需要使用source命令。通过source ~&#x2F;venv-odoo-14.0&#x2F;bin&#x2F;activate，我们激活了该虚拟环境。</p>
<h4 id="安装-Python包"><a href="#安装-Python包" class="headerlink" title="安装 Python包"></a>安装 Python包</h4><p>Odoo的源代码中有一系列Python依赖，位于requirements.txt中。第8步中，我们通过pip3 install命令安装了所有这些依赖。</p>
<p>这样就可以了，此时即可运行Odoo实例。</p>
<h4 id="启动实例"><a href="#启动实例" class="headerlink" title="启动实例"></a>启动实例</h4><p>到了你期待已久的时刻了。要启动我们的第一个实例，第9步中首先我们新建了一个空数据库，然后使用odoo-bin以及如下命令行参数启动Odoo实例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 odoo-bin -d odoo-test -i base --addons-path=addons --db-filter=odoo-test$</span><br></pre></td></tr></table></figure>

<p>可以通过在odoo-bin的前面添加.&#x2F;来省略掉python3，因其是一个可执行的Python脚本，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./odoo-bin -d odoo-test –i base --addons-path=addons --db-filter=odoo-test$</span><br></pre></td></tr></table></figure>

<p>odoo-bin后使用了如下命令行参数：</p>
<ul>
<li>-d database_name：默认使用这一数据库。</li>
<li>–db-filter&#x3D;database_name$：仅尝试连接匹配所提供正则表达式的数据库。一个Odoo安装可以为使用不同数据库的多个实例提供服务，通过这一参数限制可用的数据库。最后的那个$很重要，因为在匹配模式中使用了正则表达式，这会避免选择以相同的指定字符串开头的名称。</li>
<li>–addons-path&#x3D;directory1,directory2,…：Odoo通过这一逗号分隔列表中的目录来查找插件（add-on）。在实例创建的时候扫描该列表来添加实例中可用的插件模块列表。如果希望使用Odoo企业版，请在这一选项中添加其目录。</li>
</ul>
<!---->

<ul>
<li>-i base: 用于安装base模块。通过命令行创建数据库时需要使用到。</li>
</ul>
<p>如果你使用了与Linux当前登录用户不同的数据库用户，则需要再传递如下的参数：</p>
<ul>
<li>–db_host&#x3D;localhost: 使用TCP连接数据库服务</li>
<li>–db_user&#x3D;database_username: 使用指定的数据库登录用户</li>
<li>–db_password&#x3D;database_password: 这是用于认证PostgreSQL服务的密码</li>
</ul>
<p>使用–help可获取所有可用选项的一个总览。我们在本章后面还会来了解odoo-bin脚本更多的知识。</p>
<p>Odoo在一个空数据库上启动时，它会首先创建一个支持其操作所需的数据库结构。还会扫描插件路径来查找可用的插件模块，并将一些内容插入到数据库的初始记录中。这包括admin用户及默认admin密码，在登录时将使用到。</p>
<p>在浏览器中访问<a target="_blank" rel="noopener" href="http://localhost:8069/%EF%BC%88">http://localhost:8069/（</a> <strong>译者注：</strong> 非本地请自行修改为 IP 地址）会访问到你所新创建的实例的登录页面，如下图所示：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fe650f217c674dbc85c7943c7e2917b1~tplv-k3u1fbpfcp-zoom-1.image" alt="图1.2 - Odoo实例的登录页面"></p>
<p>图1.2 - Odoo实例的登录页面</p>
<p>这是因为Odoo内置有HTTP服务器。默认，它监听TCP端口8069上的所有本地网络接口。</p>
<h2 id="管理Odoo服务端数据库"><a href="#管理Odoo服务端数据库" class="headerlink" title="管理Odoo服务端数据库"></a>管理Odoo服务端数据库</h2><p>在使用Odoo时，你的实例所有的数据都存储在PostgreSQL数据库中。可以使用你习惯的任意标准数据库管理工具，但Odoo为一些常用操作提供了一个网页界面。</p>
<h3 id="准备工作-1"><a href="#准备工作-1" class="headerlink" title="准备工作"></a>准备工作</h3><p>我们假定你的工作环境已配置好，并且已运行了一个实例。</p>
<h3 id="如何管理…"><a href="#如何管理…" class="headerlink" title="如何管理…"></a>如何管理…</h3><p>Odoo数据库管理界面提供创建、复制、删除、备份和恢复数据库的工具。还有一种修改主控密码（master密码）的方式，用于保护对数据库管理界面的访问。</p>
<h4 id="访问数据库管理界面"><a href="#访问数据库管理界面" class="headerlink" title="访问数据库管理界面"></a>访问数据库管理界面</h4><p>需要执行如下步骤来访问数据库：</p>
<ol>
<li>进入实例的登录页面（如果已登录请先登出）。</li>
<li>点击Manage Databases链接。这会导航至<a target="_blank" rel="noopener" href="http://localhost:8069/web/database/manager%EF%BC%88%E4%B9%9F%E5%8F%AF%E4%BB%A5%E5%9C%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E7%9B%B4%E6%8E%A5%E8%AE%BF%E9%97%AE%E8%BF%99%E4%B8%AAURL%EF%BC%89%E3%80%82">http://localhost:8069/web/database/manager（也可以在浏览器中直接访问这个URL）。</a></li>
</ol>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fe3d966e7b9b430881781d7fed68bdc2~tplv-k3u1fbpfcp-zoom-1.image" alt="图1.3 – 数据库管理器"></p>
<p>图1.3 – 数据库管理器</p>
<h4 id="设置或修改主控密码"><a href="#设置或修改主控密码" class="headerlink" title="设置或修改主控密码"></a>设置或修改主控密码</h4><p>如果已经以默认值设置了实例且尚未像下面讲解的那样做过修改，数据库管理页面会显示一条警告，告诉你还没有设置主控密码并建议你通过直接点击链接来进行设置：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7de77456ac6d4883b827d4f4a979659f~tplv-k3u1fbpfcp-zoom-1.image" alt="图1.4 – Master密码警告"></p>
<p>图1.4 – 主控密码警告</p>
<p>需要执行如下步骤来设置master：</p>
<ol>
<li>点击Set Master Password按钮。会弹出一个对话框来要求你提供新的主控密码：<br><a target="_blank" rel="noopener" href="https://alanhou.org/homepage/wp-content/uploads/2019/05/2019050505371024.jpg"><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d0670e99fe8840428f3f02916e1be986~tplv-k3u1fbpfcp-zoom-1.image" alt="设置 Master 密码对话框"></a>图1.5 – 设置新主控密码对话框</li>
<li>输入一个复杂的新密码并点击Continue</li>
</ol>
<p>如果已设置了主控密码，点击页面底部的Set Master Password按钮来进行修改。在弹出的对话框中输入老的主控密码再输入新密码，然后点击Continue。</p>
<blockquote>
<p>📝主控密码是在admin_password键下的服务端配置。如果启动服务时没有指定配置文件，会在~&#x2F;.odoorc中生成新的配置文件。查看下一部分获取更多有关配置文件的信息。</p>
</blockquote>
<h4 id="创建新数据库"><a href="#创建新数据库" class="headerlink" title="创建新数据库"></a>创建新数据库</h4><p>这个对话框用于创建一个由当前Odoo服务处理的新数据库实例：</p>
<ol>
<li><p>在数据库管理窗口中，点击页面底部的Create Database按钮。会弹出如下对话框：<br><a target="_blank" rel="noopener" href="https://alanhou.org/homepage/wp-content/uploads/2019/05/2019050505390961.jpg"><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/90956616a91e497ab0475288f6904274~tplv-k3u1fbpfcp-zoom-1.image" alt="创建数据库页面"></a>图1.6 – 新建数据库对话框</p>
</li>
<li><p> 填写表单，如下：</p>
<ul>
<li>Master Password：这是这一实例的主控密码。</li>
<li>Database Name：输入所想要创建的数据库名称。</li>
<li>Email: 在此处添加email地址；在稍后用作用户名。</li>
<li>Password：输入你想为新实例所设置的admin用户密码。</li>
<li>Phone Number：设置电话号码（可选）。</li>
<li>Language：在下拉列表中选择你希望新数据库默认安装的语言。Odoo会自动加载所选语言的翻译。</li>
<li>Country：在下拉列表中选择主租户的国家。选择这一项后会自动做一些配置，如公司的币种。</li>
<li>Demo data：勾选获取演示数据。这对于运行交互式测试或为用户设置演示项目非常有用，但针对包含生产数据的数据库设计时则不应勾选。</li>
</ul>
<blockquote>
<p>ℹ️如果想要使用该数据库来运行模块的自动化测试（参见<a target="_blank" rel="noopener" href="https://alanhou.org/odoo-14-debugging/">第七章 调试</a>），则需要有演示数据，因为Odoo中的大多数自动化测试依赖于这些记录来成功运行。</p>
</blockquote>
</li>
<li><p>点击Continue按钮并等待新数据库初始化完成。然后会被重定向到该实例并以管理员进行连接。</p>
</li>
</ol>
<blockquote>
<p>问题处理：如果被重定向到了登录页，这可能是因为向Odoo传递了–db-filter选项并且与新数据库名不匹配造成的。注意odoo-bin start会默默地进行这一操作，仅让当前数据库可用。解决这一问题，只需不使用start命令来对Odoo进行重启，在本章中的<em>通过源码轻松安装 Odoo</em> 一节展示过这一做法。如果你有一个配置文件（参见本章后面的<em>在一个文件中存储实例配置</em>一节），那么请检查db_filter未进行设置或设置一个与新数据库名称匹配的值。</p>
</blockquote>
<h4 id="复制数据库"><a href="#复制数据库" class="headerlink" title="复制数据库"></a>复制数据库</h4><p>通常你已经有一个数据库了，会希望使用它做一存储过程的试验或运行测试，但又不修改已有数据。这里的方案很简单：复制该数据库并在拷贝上运行测试。可以按需重复多次：</p>
<ol>
<li><p>在数据库管理页面，点击Duplicate Database：<br><a target="_blank" rel="noopener" href="https://alanhou.org/homepage/wp-content/uploads/2019/05/2019050515123745.jpg"><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b9216e8203a046189c63d79353f232b4~tplv-k3u1fbpfcp-zoom-1.image" alt="Duplicate Database"></a>图1.7 – 复制数据库对话框</p>
</li>
<li><p>填写表单如下：</p>
<ul>
<li>Master Password:这是Odoo服务的主控密码</li>
<li>New Name：给予拷贝的名称</li>
</ul>
</li>
<li><p>点击Continue按钮。</p>
</li>
<li><p>可以在数据库管理页面点击新创建的数据库名称来访问该数据库的登录页面。</p>
</li>
</ol>
<h4 id="删除数据库"><a href="#删除数据库" class="headerlink" title="删除数据库"></a>删除数据库</h4><p>在完成测试之后，如想要清理掉所复制的数据库。通过如下步骤来进行清理：</p>
<ol>
<li>在数据库管理页面，点击想删除的数据库名称旁的Delete Database链接，会出现下图中的对话框：<br><a target="_blank" rel="noopener" href="https://alanhou.org/homepage/wp-content/uploads/2019/05/2019050515230631.jpg"><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bc4e415ea9e941c1ab3bba2e8d4efd13~tplv-k3u1fbpfcp-zoom-1.image" alt="Delete Database"></a>图1.8 – 删除数据库弹窗</li>
<li>填写表单并输入 Master Password，即Odoo服务的主控密码。</li>
<li>点击Delete按钮。</li>
</ol>
<blockquote>
<p>📝小心！数据丢失！</p>
<p>如果你选择了错误的数据库，并且没有备份，则无法恢复损失的数据。</p>
</blockquote>
<h4 id="备份数据库"><a href="#备份数据库" class="headerlink" title="备份数据库"></a>备份数据库</h4><p>需执行如下步骤来创建备份：</p>
<ol>
<li><p>在数据库管理页面，点击想备份数据库名称旁的Backup按钮，会弹出下图这样的对话框：<br><a target="_blank" rel="noopener" href="https://alanhou.org/homepage/wp-content/uploads/2019/05/2019050516024419.jpg"><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7ca40ba288d44ff08c4f620f610831aa~tplv-k3u1fbpfcp-zoom-1.image" alt="Backup Database"></a>图1.9 – 备份数据库弹窗</p>
</li>
<li><p>填写表单</p>
<ul>
<li>Master Password：Odoo服务的主控密码。</li>
<li>Backup Format：对生产数据库请保持使用zip，因为这是唯一真正的全量备份格式。仅在备份不关心文件存储的开发数据库时使用pg_dump格式。</li>
</ul>
</li>
<li><p>点击Backup。然后浏览器会下载备份文件。</p>
</li>
</ol>
<h4 id="还原数据库备份"><a href="#还原数据库备份" class="headerlink" title="还原数据库备份"></a>还原数据库备份</h4><p>如果需要还原一个备份，需要按如下步骤操作：</p>
<ol>
<li><p>在数据库管理页面，点击页面底部的Restore Database按钮，会弹出如下的对话框：<br><a target="_blank" rel="noopener" href="https://alanhou.org/homepage/wp-content/uploads/2019/05/2019050516123082.jpg"><img src="/" alt="Restore Database"></a>图1.10 – 还原数据库对话框</p>
</li>
<li><p>填写表单：</p>
<ul>
<li>Master Password：这是Odoo服务的主控密码。</li>
<li>File：这是之前所下载的Odoo备份</li>
<li>Database Name：提供你需进行备份还原的数据库名称。该数据库在服务器上一定不能存在。</li>
<li>数据库可能进行了迁移或拷贝：如果原数据库在另一台服务器上或是为从当前服务器删除则选择This database was moved。否则选择This database is a copy，这也是安全的默认选项。</li>
</ul>
</li>
<li><p>点击Continue按钮。</p>
</li>
</ol>
<blockquote>
<p>📝不能在数据库自身之上还原数据库。这么做会得到一条错误消息（Database restore error: Database already exists）。需要先删除该数据库。</p>
</blockquote>
<h3 id="运行原理…-1"><a href="#运行原理…-1" class="headerlink" title="运行原理…"></a>运行原理…</h3><p>除Change master password以外的这些页面上的功能，是在服务器上运行PostgreSQL运维命令并通过网页界面报告结果。</p>
<p>主控密码是非常重要的信息，仅存储在Odoo服务的配置文件中，从不在数据库中进行存储。曾经有一个admin默认值，但使用这个值是一个广为人知的安全问题。在Odoo v9及之后的版本中，这被识别为一个未设置的主控密码，并在访问数据库管理页面时会敦促你修改密码。虽然这在配置文件中以admin_passwd进行存储，它与admin的密码是不同的，它们是两个不同的密码。主控密码是为Odoo服务进程设置的，进程本身可以处理多个数据库实例，每个实例都有一个独立的admin用户及其自己的密码。</p>
<blockquote>
<p>📝安全考虑：记住本章中我们所考虑的是开发环境。Odoo数据库管理界面在我们运行生产服务时是需要进行安全保护的，因为这里给到了过多敏感信息的访问权限，尤其是在服务器托管了多个不同客户端的Odoo实例时。</p>
</blockquote>
<p>Odoo使用PostgreSQL的createdb工具来新建数据库，它通过和以空数据库启动Odoo时相同的方式调用内部的Odoo函数来初始化新数据库。</p>
<p>Odoo使用createdb的–template选项传递原数据库作为参数来复制数据库。这基本上使用内部优化的PostgreSQL例行程序在新数据库中复制模板数据库的结构，这比创建备份和还原备份的速度会快很多（尤其是在使用网页界面时，还要求你下载备份文件然后再重新上传）。</p>
<p>备份和还原操作分别使用pg_dump和pg_restore工具。在使用zip格式时，备份还包含文件存储的拷贝，其中为配置Odoo不保存在数据库中的文档的拷贝，这是14.0中的默认选项。如果没做过修改的话，这些文件存放在~&#x2F;.local&#x2F;share&#x2F;Odoo&#x2F;filestore中。</p>
<blockquote>
<p>📝如果备份很大，下载时会失败。这可能是因为Odoo服务本身无法在内存中处理这么大的文件或者是因为服务在反向代理之后运行，而这个代理设置了HTTP响应大小的限制。反过来，出于某些原因，你可能会在还原数据库的操作中遇到问题。在碰到这些问题时，应当投入时间建立更健壮的外部备份方案。</p>
</blockquote>
<h3 id="更多内容…"><a href="#更多内容…" class="headerlink" title="更多内容…"></a>更多内容…</h3><p>有经验的Odoo开发者通常不使用数据库管理界面，而在命令行执行相关操作。比如使用演示数据初始化新数据库，可以使用如下的一行代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ createdb testdb &amp;&amp; odoo-bin -d testdb</span><br></pre></td></tr></table></figure>

<p>命令行的另一个彩蛋是可以在使用时要求安装一些插件，比如 -i sale,purchase,stock。</p>
<p>停止服务并运行如下这些命令来复制数据库：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ createdb -T dbname newdbname</span><br><span class="line">$ cd ~/.local/share/Odoo/filestore # 如果你修改了data_dir请调整此处</span><br><span class="line">$ cp -r dbname newdbname</span><br><span class="line">$ cd -</span><br></pre></td></tr></table></figure>

<p>注意在开发的上下文中，文件存储通常会被省略。</p>
<blockquote>
<p>📝createdb -T 仅在数据库没有活跃会话时方能使用，这表示在通过命令行复制数据库之前你需要关闭Odoo服务。</p>
</blockquote>
<p>可运行如下命令来删除一个实例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ dropdb dbname</span><br><span class="line">$ rm -rf ~/.local/share/Odoo/filestore/dbname</span><br></pre></td></tr></table></figure>

<p>可运行如下命令来创建一个备份（假设PostgreSQL服务在本地运行）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ pg_dump -Fc -f dbname.dump dbname</span><br><span class="line">$ tar cjf dbname.tgz dbname.dump ~/.local/share/Odoo/filestore/dbname</span><br></pre></td></tr></table></figure>

<p>可运行如下命令来还原备份：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ tar xf dbname.tgz</span><br><span class="line">$ pg_restore -C -d dbname dbname.dump</span><br></pre></td></tr></table></figure>

<blockquote>
<p>📝<strong>当心！</strong></p>
<p>如果你的Odoo实例使用了另一个用户连接数据库，需要传递-U username来使用正确的用户作为还原数据库的所有者。</p>
</blockquote>
<h2 id="在文件中存储实例配置"><a href="#在文件中存储实例配置" class="headerlink" title="在文件中存储实例配置"></a>在文件中存储实例配置</h2><p>odoo-bin脚本有几十个选项，记住所有这些以及记得在启动服务时适当地进行配置会非常单调费力。所幸可以将它们存储在一个配置文件中，只需对想要修改的选项进行手动修改，比如为开发环境做修改。</p>
<h3 id="如何配置"><a href="#如何配置" class="headerlink" title="如何配置"></a>如何配置</h3><p>对于本小节可执行如下步骤：</p>
<ol>
<li><p>运行如下命令来为你的Odoo实例生成一个配置文件：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ./odoo-bin --save --config myodoo.cfg --stop-after-init</span><br></pre></td></tr></table></figure>
</li>
<li><p>还可以添加其它选项，它们的值会被保存到所生成的文件中。所有未设置的值都会以默认值进行保存。使用如下命令来获取可用的选项列表：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ./odoo-bin --help | less</span><br></pre></td></tr></table></figure>

<p>这会提供一些不同选项所执行内容的帮助文档。</p>
</li>
<li><p>要从命令行形式转化为配置形式，使用长选项名，删除前面的中间杠，并将中间的中间杠转换为下划线。–without-demo就变成了without_demo。对大多数选项都是如此，但有一些例外，在下一部分中会列出。</p>
</li>
<li><p>编辑myodoo.cfg文件（使用下一部分中的表格来查看所要修改的参数）。然后运行如下命令来以所保存的选项启动服务：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ./odoo-bin -c myodoo.cfg</span><br></pre></td></tr></table></figure>

<blockquote>
<p>📝-config选项通常简写为-c。</p>
</blockquote>
</li>
</ol>
<h3 id="运行原理"><a href="#运行原理" class="headerlink" title="运行原理"></a>运行原理</h3><p>启动时，Odoo通过三个步骤来加载它的配置。首先，所有选项的一组默认值会从源码中进行初始化，然后解析配置文件，该文件中所定义的任意值会覆盖默认值。最后，会分析命令行选项，它们的值会覆盖前面步骤中所获取的配置。</p>
<p>前面我们已提到，配置变量的名称可通过删除命令行选项的前置中间杠以及将中间的连接符转换为下划线来获取。其中有一些例外，特别是下面这些：</p>
<table>
<thead>
<tr>
<th>命令行</th>
<th>配置文件</th>
</tr>
</thead>
<tbody><tr>
<td>–db-filter</td>
<td>dbfilter</td>
</tr>
<tr>
<td>–no-http</td>
<td>http_enable &#x3D; True&#x2F;False</td>
</tr>
<tr>
<td>–database</td>
<td>db_name</td>
</tr>
<tr>
<td>–dev</td>
<td>dev_mode</td>
</tr>
<tr>
<td>–i18n-import&#x2F;–i18n-export</td>
<td>不可用</td>
</tr>
</tbody></table>
<p>表1.2</p>
<p>以下是通过配置文件设置的常用选项列表：</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>格式</th>
<th>用途</th>
</tr>
</thead>
<tbody><tr>
<td>without_demo</td>
<td>逗号分隔的模块名列表</td>
<td>该选项阻止模块演示数据被加载。 设置为all取消所有模块的演示数据，设为False为所有模块启用演示数据。对具体模块禁用演示数据，应提供模块名，如 sale,purchase,crm。</td>
</tr>
<tr>
<td>addons_path</td>
<td>逗号分隔的路径列表</td>
<td>这是一个服务查找插件的路径名列表。</td>
</tr>
<tr>
<td>admin_passwd</td>
<td>文本</td>
<td>这是 master 密码（参见前面部分的内容）</td>
</tr>
<tr>
<td>data_dir</td>
<td>一个目录路径</td>
<td>这个目录中服务会存储session信息、从网上下载的插件以及在启用了文件存储时存放文档。</td>
</tr>
<tr>
<td>http_interface</td>
<td>网络接口的 IP 地址</td>
<td>默认为0.0.0.0，表示服务监听所有接口。</td>
</tr>
<tr>
<td>http_port longpolling_port</td>
<td>端口号</td>
<td>这些是 Odoo 服务所会监听的端口。你需要指定这两者来在同一台主机上运行多个 Odoo 服务；longpolling_port仅在workers不为0时使用。 http_port默认值为8069，longpolling_port默认为8072。</td>
</tr>
<tr>
<td>logfile</td>
<td>文件路径</td>
<td>Odoo 写入日志的文件。</td>
</tr>
<tr>
<td>log_level</td>
<td>日志信息级别</td>
<td>指定日志的级别。可接受的值（内容逐渐增加）包括critical, error, warn, info, debug, debug_rpc, debug_rpc_answer, debug_sql。</td>
</tr>
<tr>
<td>workers</td>
<td>整数</td>
<td>worker进程的数量，更多信息参见<a target="_blank" rel="noopener" href="https://alanhou.org/server-deployment/">第三章 服务器部署</a>。</td>
</tr>
<tr>
<td>proxy_mode</td>
<td>True&#x2F;False</td>
<td>激活反向代理WSGI封装。仅在运行于可信任的 web 代理后启用它。</td>
</tr>
</tbody></table>
<p>表1.3</p>
<p>以下是与数据库相关的配置选项列表：</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>格式</th>
<th>用途</th>
</tr>
</thead>
<tbody><tr>
<td>db_host</td>
<td>主机名</td>
<td>这是运行PostgreSQL服务的服务器名。使用 False 来使用本地 Unix 域套接字，以及 localhost 来使用本地 TCP 套接字。</td>
</tr>
<tr>
<td>db_user</td>
<td>数据库登录用户</td>
<td>在db_host为 False 时这通常为空。这将是用于连接数据库的用户。</td>
</tr>
<tr>
<td>db_password</td>
<td>数据库用户密码</td>
<td>在db_host为 False以及 db_user 与运行服务的用户相同时通常为空。阅读pg_hba.conf的主页面来获取更多相关信息。</td>
</tr>
<tr>
<td>db_name</td>
<td>数据库名</td>
<td>用于设置一些默认执行命令操作的数据库名。这不会限制服务所操作的数据库。参照下面的 dbfilter 参数。</td>
</tr>
<tr>
<td>db_sslmode</td>
<td>数据库SSL模式</td>
<td>用于指定数据库SSL连接模式。</td>
</tr>
<tr>
<td>dbfilter</td>
<td>一个正则表达式</td>
<td>该表达式应匹配服务所使用的数据库名。如果你运行网站，应该匹配单个数据库，类似^databasename$。更多相关信息请参见<a target="_blank" rel="noopener" href="https://alanhou.org/server-deployment/">第三章 服务器部署</a>。</td>
</tr>
<tr>
<td>list_db</td>
<td>True&#x2F;False</td>
<td>设置为 True 来取消列出数据库。更多信息请参见<a target="_blank" rel="noopener" href="https://alanhou.org/server-deployment/">第三章 服务器部署</a>。</td>
</tr>
</tbody></table>
<p>表1.4</p>
<p><strong>译者注：</strong> 表中的pg_hba.conf文件位置：&#x2F;etc&#x2F;postgresql&#x2F;xxx&#x2F;main&#x2F;pg_hba.conf，另表中的<a target="_blank" rel="noopener" href="https://alanhou.org/server-deployment/">第三章 服务器部署</a>为上一版中的内容，在本书中已不再包含。</p>
<p>Odoo对配置文件的解析现在使用Python的ConfigParser模块。但是在Odoo 11.0中的实现发生了变化，它不再支持使用变量插值。因此，如果你习惯了使用%(section.variable)s表达式通过其它变量的值定义变量值的话，需要改变这一习惯并恢复使用显式的值。</p>
<p>有些选项不在配置文件使用，但广泛用于开发之中：</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>格式</th>
<th>用途</th>
</tr>
</thead>
<tbody><tr>
<td>-i或–init</td>
<td>逗号分隔的模块名列表</td>
<td>它会在初始化数据库时默认安装给定的模块</td>
</tr>
<tr>
<td>-u 或-update</td>
<td>逗号分隔的模块名列表</td>
<td>它会在重启服务时更新给定的模块。多在修改了源代码或从 git 更新了分支时使用</td>
</tr>
<tr>
<td>–dev</td>
<td>all, reload, qweb, werkzeug, xml</td>
<td>这会启用开发者模式及自动重新加载功能。</td>
</tr>
</tbody></table>
<p>表1.5</p>
<h2 id="激活Odoo开发者工具"><a href="#激活Odoo开发者工具" class="headerlink" title="激活Odoo开发者工具"></a>激活Odoo开发者工具</h2><p>开发人员在使用Odoo时，应当知道如何在网页界面激活开发者模式，这样你就可以访问技术设置菜单及开发者信息。启动调试模式会暴露出一些高级配置项及字段。Odoo隐藏这些选项和字段来实现更好的易用性，因为日常不会使用到它们。</p>
<h3 id="如何激活"><a href="#如何激活" class="headerlink" title="如何激活"></a>如何激活</h3><p>按照如下步骤来在网页界面中激活开发者模式：</p>
<ol>
<li>连接到你的实例并以 admin 登录</li>
<li>访问Settings菜单</li>
<li>滚动至页面底部，找到Developer Tools版块<br><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d6b4e9a1cba34a269167f9dece0c8ca6~tplv-k3u1fbpfcp-zoom-1.image" alt="图1.11 – 启用不同开发者模式的链接"><br>图1.11 – 启用不同开发者模式的链接</li>
<li> 点击Activate the developer mode链接</li>
<li>等待用户界面重载</li>
</ol>
<blockquote>
<p>ℹ️<strong>其它方式：</strong> 也可以通过编辑 URL 来激活开发者模式。在链接的#号前，插入?debug&#x3D;1。例如，如果你的链接是<a target="_blank" rel="noopener" href="http://localhost:8069/web#menu_id=102&action=94%EF%BC%8C%E9%82%A3%E4%B9%88%E4%BD%A0%E9%9C%80%E8%A6%81%E5%B0%86%E5%85%B6%E4%BF%AE%E6%94%B9%E4%B8%BAhttp://localhost:8069/web?debug=1#menu_id=102&action=94%E3%80%82%E6%AD%A4%E5%A4%96%EF%BC%8C%E5%A6%82%E6%9E%9C%E4%BD%A0%E6%83%B3%E8%A6%81%E4%BD%BF%E7%94%A8%E5%B8%A6%E9%9D%99%E6%80%81%E6%96%87%E4%BB%B6%E7%9A%84%E8%B0%83%E8%AF%95%E6%A8%A1%E5%BC%8F%EF%BC%8C%E5%88%99%E5%B0%86">http://localhost:8069/web#menu_id=102&amp;action=94，那么你需要将其修改为http://localhost:8069/web?debug=1#menu_id=102&amp;action=94。此外，如果你想要使用带静态文件的调试模式，则将</a> URL修改为<a target="_blank" rel="noopener" href="http://localhost:8069/web?debug=assets#menu_id=102&action=94">http://localhost:8069/web?debug=assets#menu_id=102&amp;action=94</a></p>
</blockquote>
<p><strong>译者注：</strong> 加(with assets)的模式会将静态文件（css, js）分拆每一个具体文件，这将有助于调试，但相对于合并的静态文件而言会损失一些加载速度</p>
<p>通过如下其中一种方式可退出开发者模式：</p>
<ul>
<li>编辑URL并在查询字符串中写入?debug&#x3D;0</li>
<li>通过使用Settings菜单相同位置下的Deactivate the developer mode链接</li>
<li>点击顶部调试小虫图标，在下拉菜单中点击Leave Developer Tools选项</li>
</ul>
<p>很多开发者使用浏览器插件来切换调试者模式。通过使用插件，可以无需访问settings菜单快速地切换调试模式。这些插件可在Firefox和Chrome浏览器中使用。参见如下截图，它有助于你在Chrome商店中找到该插件：</p>
<p><a target="_blank" rel="noopener" href="https://alanhou.org/homepage/wp-content/uploads/2019/05/2019050613255271.jpg"><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/edc5d20677594b7286abb158858cbccd~tplv-k3u1fbpfcp-zoom-1.image" alt="Odoo Debug Chrome 插件"></a></p>
<p>图1.12 – 调试模式的浏览器插件</p>
<blockquote>
<p>📝调试模式的行为从Odoo v13开始发生了改变。从v13开始，调试模式的状态存储在会话中，那么即使在URL中删除掉?debug，调试模式依然处于启动状态。</p>
</blockquote>
<h3 id="运行原理-1"><a href="#运行原理-1" class="headerlink" title="运行原理"></a>运行原理</h3><p>开发者模式中，会发生两件事情：</p>
<ul>
<li>鼠标在表单视图的字段上或列表视图的列名上悬浮时会给出提示信息，提供该字段的技术信息（内部名称、类型等）。</li>
<li>调试图标下拉菜单会显示在右上角用户菜单旁，给到显示的模型相关技术信息的访问，有各种关联的视图定义、工作流、自定义过滤管理等等。</li>
</ul>
<p>开发模式有一个变体：Developer mode (with assets)。这一模式和普通的开发者模式相似，但除此之外，发送到浏览器的JavaScript 和 CSS没有做最小化处理，这表示你浏览器的web开发者工具可以方便地用于调试JavaScript代码（更多内容请见<a target="_blank" rel="noopener" href="https://alanhou.org/odoo-14-web-client-development/">第十五章 网页客户端开发</a>）。</p>
<blockquote>
<p>📝<strong>注意！</strong></p>
<p>使用非开发者模式及开发者模式来测试你的插件，因JavaScript库的非最小化版本会隐藏最小化版本中伤你至深的 bug。</p>
</blockquote>
<h2 id="更新插件模块列表"><a href="#更新插件模块列表" class="headerlink" title="更新插件模块列表"></a>更新插件模块列表</h2><p>在新增模块时，Odoo并不知道新模块的存在。为在Odoo中列出该模块，需要更新模块列表。本小节中学习如何更新应用列表。</p>
<h3 id="准备工作-2"><a href="#准备工作-2" class="headerlink" title="准备工作"></a>准备工作</h3><p>启动实例并使用Administrator账号连接实例。然后启用开发者模式（如尚不知道如何启用开发者模式，参见<a target="_blank" rel="noopener" href="https://alanhou.org/odoo-14-installing-the-odoo-development-environment/">第一章 安装Odoo开发环境</a>）。</p>
<h3 id="如何实现…"><a href="#如何实现…" class="headerlink" title="如何实现…"></a>如何实现…</h3><p>在实例中更新已有的插件模块列表，执行如下步骤：</p>
<ol>
<li>打开Apps菜单 <strong>。</strong></li>
<li>点击Update Apps List。<br><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a85d7d89a2b64768945bbf3200756ce2~tplv-k3u1fbpfcp-zoom-1.image" alt="图1.13 – 更新应用列表的菜单项"><br>图1.13 – 更新应用列表的菜单项</li>
<li>在弹出的对话框中点击Update按钮：<br><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/14ac3806d4cd43d1abd63e017fd248b7~tplv-k3u1fbpfcp-zoom-1.image" alt="图1.14 – 更新应用列表对话框"><br>图1.14 – 更新应用列表对话框</li>
<li>在更新结束时，可以点击Apps查看更新后的可用插件模块列表。需要删除掉Apps搜索框中默认的过滤器来查看所有模块。</li>
</ol>
<h3 id="运行原理…-2"><a href="#运行原理…-2" class="headerlink" title="运行原理…"></a>运行原理…</h3><p>在点击Update按钮时，Odoo会读取插件路径配置变量。对于列表中的每个路径，它会查找插件声明文件包含的直接子目录，声明文件__manifest__.py存储在插件模块目录下。Odoo读取声明内容，查找其中的Python字典。只要声明中键为installable的实例不设置为False，就会将插件模块元数据存储到数据库中。如果模块已存在，会更新信息。如不存在，会新建一条记录。如果此前可用的插件模块查找不到，也不会从列表中进行删除。</p>
<blockquote>
<p>📝仅在初始化数据库后新增插件路径时才需要更新应用列表。如果在初始化数据库之前在配置文件中新增了插件路径，则无需手动更新模块列表。</p>
</blockquote>
<p>总结一下我们目前所学到的知识，在完成安装后，我们使用如下命令启动Odoo服务(如果使用了虚拟环境，需要先激活该环境)：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 odoo-bin -d odoo-test -i base --addons-path=addons --db-filter=odoo-test</span><br></pre></td></tr></table></figure>

<p>运行后，可以通过<a target="_blank" rel="noopener" href="http://localhost:8069/">http://localhost:8069</a> 来访问Odoo。</p>
<p>还可以使用配置文件来运行Odoo，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./odoo-bin -c myodoo.cfg</span><br></pre></td></tr></table></figure>

<p>启动好Odoo服务后，可以在Apps 菜单下安装&#x2F;更新其中的模块。</p>
<h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><p>1、Running setup.py install for psycopg2 … error<br>ERROR: Command errored out with exit status 1</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt install libpq-dev -y</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://alanhou.github.io/2019/01/23/odoo-essentials-12-chapter14/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Alan Hou">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Alan Hou的个人博客">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Alan Hou的个人博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2019/01/23/odoo-essentials-12-chapter14/" class="post-title-link" itemprop="url">第十四章 Odoo 12开发之部署和维护生产实例</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2019-01-23 00:00:00" itemprop="dateCreated datePublished" datetime="2019-01-23T00:00:00+08:00">2019-01-23</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2023-02-03 14:20:02" itemprop="dateModified" datetime="2023-02-03T14:20:02+08:00">2023-02-03</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>本文为<a target="_blank" rel="noopener" href="https://alanhou.org/odoo-12-development/">最好用的免费ERP系统Odoo 12开发手册</a>系列文章第十四篇暨完结篇。</p>
<p>本文中将学习将 Odoo 服务器作为生产环境的基本准备。安装和维护服务器是一个复杂的话题，应该由专业人员完成。本文中所学习的不足以保证普通用户创建应对包含敏感数据和服务的健壮、安全环境。</p>
<p>本文旨在介绍 Odoo 部署的重要配置和最佳实践，这样系统管理员可以更好地准备 Odoo 服务器主机。通过本文的学习，我们将能创建一个相对安全的 Odoo 服务器，足够应对普通的生产环境使用。本文所述并非部署 Odoo 的唯一方法，其它的方法也会同样适用。</p>
<p>本文主要内容有：</p>
<ul>
<li><p>通过源码安装 Odoo，主要包含：</p>
<ul>
<li>安装依赖</li>
<li>准备一个独立的系统用户</li>
<li>通过源码安装</li>
<li>设置配置文件</li>
<li>多进程</li>
</ul>
</li>
<li><p>设置 Odoo 为系统服务，主要包含：</p>
<ul>
<li>创建 systemd 服务</li>
<li>创建自启动或 sysvinit 服务</li>
<li>通过命令行查看 Odoo 服务</li>
</ul>
</li>
<li><p>设置 Nginx 反向代理</p>
</li>
<li><p>配置HTTPS安全服务, 主要包含 :</p>
<ul>
<li>创建自签名SSL证书</li>
<li>在 Nginx 上配置 HTTPS访问</li>
<li>缓存静态内容</li>
</ul>
</li>
<li><p>服务器和模块更新，主要包含：</p>
<ul>
<li>创建模拟环境</li>
<li>更新 Odoo 源码</li>
</ul>
</li>
</ul>
<h2 id="开发准备"><a href="#开发准备" class="headerlink" title="开发准备"></a>开发准备</h2><p>本章无需使用前面开发的代码，相关代码和脚本请见 <a target="_blank" rel="noopener" href="https://github.com/alanhou/odoo12-development">GitHub 仓库</a>。</p>
<h2 id="通过源码安装-Odoo"><a href="#通过源码安装-Odoo" class="headerlink" title="通过源码安装 Odoo"></a>通过源码安装 Odoo</h2><p>Odoo 有 Debian 或 Ubuntu的安装包，使用它可以实现工作服务进程以及在系统启动时自动开启服务。安装过程按步骤即可，在<a target="_blank" rel="noopener" href="https://nightly.odoo.com/%E4%B8%8A%E5%8F%AF%E4%BB%A5%E6%89%BE%E5%88%B0%E7%9B%B8%E5%85%B3%E4%BF%A1%E6%81%AF%E3%80%82%E4%B8%8A%E9%9D%A2%E8%BF%98%E6%9C%89CentOS%E7%9A%84rpm%E6%96%87%E4%BB%B6%E4%BB%A5%E5%8F%8A">https://nightly.odoo.com/上可以找到相关信息。上面还有CentOS的rpm文件以及</a> Windows 的.exe 安装包。</p>
<p>虽然这样安装 Odoo 很容易也很方便，大多数人倾向于部署和运行版本控制的源码来进行集成。这样能更好地控制部署内容，并且在生产环境中也更易于管理代码的变更和修复。</p>
<h3 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h3><p>使用Debian发行版时，默认登录用户为带有管理员权限的 root，这时命令行显示的为#。在Ubuntu系统中，禁用了 root 账号，在安装时配置的初始用户可通过 sudo 来运行 root 权限的命令。首先我们应更新包索引，然后执行升级来确保所有安装的程序是最新的，命令如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt update</span><br><span class="line">sudo apt upgrade -y</span><br></pre></td></tr></table></figure>

<p>下一步，我们将安装PostgreSQL数据库，并让当前用户成为数据库超级用户，命令如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install postgresql -y</span><br><span class="line">sudo su -c &quot;createuser -s $USER&quot; postgres</span><br></pre></td></tr></table></figure>

<p>我们将通过源码运行 Odoo，但在那之前，我们需要安装所需依赖。以下是所需的Debian包：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install git python3-dev python3-pip -y</span><br><span class="line">sudo apt install build-essential libxslt-dev libzip-dev libldap2-dev libsasl2-dev libssl-dev -y</span><br></pre></td></tr></table></figure>

<p>还应记得安装打印报表所需的wkhtmltox，命令如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wget &quot;https://github.com/wkhtmltopdf/wkhtmltopdf/releases/download/0.12.5/wkhtmltox_0.12.5-1.xenial_amd64.deb&quot; -O /tmp/wkhtml.deb</span><br><span class="line">sudo dpkg -i /tmp/wkhtml.deb</span><br><span class="line">sudo apt-get -fy install # 处理依赖错误</span><br></pre></td></tr></table></figure>

<p>注意安装包时可能报依赖错误，像这里最一条命令会强制这些依赖的安装并正确完成安装。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 错误信息</span><br><span class="line">...</span><br><span class="line">dpkg: error processing package wkhtmltox (--install):</span><br><span class="line"> dependency problems - leaving unconfigured</span><br><span class="line">Errors were encountered while processing:</span><br><span class="line"> wkhtmltox</span><br></pre></td></tr></table></figure>

<p>现在我们就只缺少 Odoo 所需要的 Python 包了，它们大多数都有Debian或Ubuntu系统包。官方Debian安装包使用到这些，可在Odoo 源码debian&#x2F;control文件中找到这些包名。但是这些 Python 依赖也可以通过PyPI（Python Package Index）直接安装。所要求的包和通常基于 Python 的项目一样在 Odoo 的requirements.txt文件中。我们可以使用如下命令安装这些包：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wget https://raw.githubusercontent.com/odoo/odoo/12.0/requirements.txt</span><br><span class="line">sudo -H pip3 install -r requirements.txt</span><br></pre></td></tr></table></figure>

<p>在Ubuntu 18.04中，最后一条命令可能会打印了红色的警告，内容是PyYAML 和pySerial的卸载，这在系统中通过包安装了老版本时会发生。这种警告可以安全的略过。</p>
<p>既然我们有了所有的依赖，安装了数据库服务、系统包和 Python 包，我们就可以安装 Odoo 了。</p>
<h3 id="准备独立的系统用户"><a href="#准备独立的系统用户" class="headerlink" title="准备独立的系统用户"></a>准备独立的系统用户</h3><p>从安全角度建议使用独立的用户运行 Odoo，这一用户不带有任何系统的特权。为此我们需要创建系统和数据库用户，使用命令如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo adduser --disabled-password --gecos &quot;Odoo&quot; odoo</span><br><span class="line">sudo su -c &quot;createuser odoo&quot; postgres</span><br><span class="line">createdb --owner=odoo odoo-prod</span><br></pre></td></tr></table></figure>

<p>以上odoo 为用户名，odoo-prod用于运行 Odoo 实例的数据库名。odoo用户成为了odoo-prod数据库的所有者。也就说它对该数据库有创建和删除的权限，包括删除整个数据库的权限。如果你运行的是多租户服务器，应为每个租户创建一个类似 odoo 的指定系统用户。</p>
<blockquote>
<p><strong>小贴士：</strong> Odoo的设计即使在系统用户不是数据库所有者时也可以正确运行。但这可能会让设置变复杂，并且固化安全的好习惯是有一个主系统用户作为数据库的所有者、为每个实例创建一个指定的不带有超级用户权限的系统用户来运行服务。</p>
</blockquote>
<p>注意这些是没有管理权限的普通用户，新建系统用户时会自动创建一个家目录。比如&#x2F;home&#x2F;odoo，用户可通过~快捷符号来表示自己的家目录。我们在用户 Odoo 对应的配置和文件中会使用到它。我们可以使用如下命令来以该用户打开一个会话：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo su odoo</span><br><span class="line">exit</span><br></pre></td></tr></table></figure>

<p>exit命令终止会话并回到原用户。</p>
<h3 id="源码安装"><a href="#源码安装" class="headerlink" title="源码安装"></a>源码安装</h3><p>要不了多久，你的服务就会需要升级、打补丁。这时版本控制仓库会很有帮助。我们使用 git来从仓库中获取代码，就像我们在安装开发环境时的操作一样。下面我将使用 odoo 用户并将代码下载家目录中：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo su odoo</span><br><span class="line">git clone https://github.com/odoo/odoo.git /home/odoo/odoo-12 -b 12.0 --depth=1</span><br></pre></td></tr></table></figure>

<p>-b 选项确保获取的是正确的分支，–depth&#x3D;1选项会忽略修改历史并仅获取最新修订的代码，这样下载内容更精简，速度也更快。</p>
<blockquote>
<p><strong>小贴士：</strong> git在管理 Odoo 部署版本时是一个非常有价值的工具。注意本系列文章中仅仅涉及到代码版本管理的冰山一角。想要更加熟悉 git，值得花时间进一步学习，可从<a target="_blank" rel="noopener" href="http://git-scm.com/doc%E5%BC%80%E5%A7%8B%E3%80%82">http://git-scm.com/doc开始。</a></p>
</blockquote>
<p>到此为止，我们应该已经拥有源码安装 Odoo 的所有内容。可通过如下命令以指定用户会话检查是否正确启动并退出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ /home/odoo/odoo-12/odoo-bin --version</span><br><span class="line">Odoo Server 12.0</span><br><span class="line">$ exit</span><br></pre></td></tr></table></figure>

<p>下面我们将设置一些在系统中使用的系统级别的文件和目录。</p>
<h3 id="设置配置文件"><a href="#设置配置文件" class="headerlink" title="设置配置文件"></a>设置配置文件</h3><p>在启动 Odoo 服务时添加–save参数会将配置保存到~&#x2F;.odoorc文件中。我们将以这个文件作为服务配置的初始文件，将其保存到&#x2F;etc&#x2F;odoo下，使用命令如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo su -c &quot;~/odoo-12/odoo-bin -d odoo-prod --db-filter=&#x27;^odoo-prod$&#x27; --without-demo=all -i base --save --stop-after-init&quot; odoo</span><br></pre></td></tr></table></figure>

<p>这行命令中也会包含服务实例所使用的配置参数。</p>
<blockquote>
<p><strong>小贴士：</strong> 老版本中的.openerp_serverrc配置文件还被支持，找到后会进行使用。如果安装 Odoo 10或之后版本的服务器上同时还安装了老版本的 Odoo，可能会引起混淆。这时你会发现–save选项没有更新.odoorc，而是更新了.openerp_serverrc文件。</p>
</blockquote>
<p>下一步我们需要将配置文件放到系统的配置文件目录&#x2F;etc 下，命令如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo mkdir /etc/odoo</span><br><span class="line">sudo cp /home/odoo/.odoorc /etc/odoo/odoo.conf</span><br><span class="line">sudo chown -R odoo /etc/odoo</span><br><span class="line">sudo chmod u=r,g=rw,o=r /etc/odoo/odoo.conf # 安全加固使用</span><br></pre></td></tr></table></figure>

<p>以上命令最后一行是可选的，但它提升了系统的安全性。它确保运行 Odoo 进程的用户可以读取但无法修改配置文件。这时你将无法修改数据库主密码，但在生产服务下这不是什么问题，因为应使用list_db&#x3D;False服务配置来禁用网页数据库管理员。我们还需为 Odoo 服务创建一个存储日志文件的目录。这通常放在&#x2F;var&#x2F;log目录下，命令如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo mkdir /var/log/odoo</span><br><span class="line">sudo chown odoo /var/log/odoo</span><br></pre></td></tr></table></figure>

<p>现在让我们通过如下命令编辑配置文件并确保已配置了一些重要参数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo nano /etc/odoo/odoo.conf</span><br></pre></td></tr></table></figure>

<p>以下是大部分重要参数的推荐值：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[options]</span><br><span class="line">addons_path = /home/odoo/odoo-12/odoo/addons,/home/odoo/odoo-12/addons</span><br><span class="line">admin_passwd = False</span><br><span class="line">db_name = odoo-prod</span><br><span class="line">dbfilter = ^odoo-prod$</span><br><span class="line">http_port = 8069</span><br><span class="line">list_db = False</span><br><span class="line">logfile = /var/log/odoo/odoo-server.log</span><br><span class="line">proxy_mode = True</span><br><span class="line">without_demo = all</span><br><span class="line">workers = 6</span><br></pre></td></tr></table></figure>

<p>下面逐一讲解：</p>
<ul>
<li>addons_path是一组逗号分隔的用于查找插件模块的路径。读取顺序为从左到右，最左边目录的优先级最高。</li>
<li>admin_passwd是访问网页客户端数据库管理功能的主密码。一定要设置复杂的密码，或者最好是设为 False来关闭这一功能。</li>
<li>db_name是在服务启动时初始化的数据库实例。</li>
<li>dbfilter用于过滤可访问的数据库，它是一个 Python 解释的正则表达式。为使用户无需弹出窗口选择数据库，并使未经身份验证的 URL 可正常运作，应设置为^dbname$，比如dbfilter&#x3D;^odoo-prod$。它支持%h和%d占位符，由 HTTP 请求主机名和子域名进行替换。</li>
<li>http_port是服务器监听的端口号，默认使用的是8069</li>
<li>list_db &#x3D; False在 RPC级别和 UI 上屏蔽数据库列表，并屏蔽数据库管理界面以及相应的 RPC 功能。</li>
<li>logfile是服务日志写入的位置。对于系统服务，一般位于&#x2F;var&#x2F;log文件夹内。如果留空，日志会转而在标准输出中打印。</li>
<li>proxy_mode在需要反向代理访问时应设为True，我们需要用到反向代理。</li>
<li>without_demo在生产环境中应进行设置，这样新建的数据库中不会带有演示数据。</li>
<li>workers的值在大于等于2时启用多进程，一会儿我们会进一步的讨论。</li>
</ul>
<blockquote>
<p>ℹ️Odoo 10中引入http_port参数来替代老版本中使用但现在已淘汰了的xmlrpc_port参数。</p>
</blockquote>
<p>从安全角度看，admin_passwd&#x3D;False和list_db&#x3D;False选项尤为重要。它们屏蔽掉对数据库管理功能的网页端访问，在生产环境和面向外网的 Odoo 服务中都应进行设置。</p>
<p>以下也是会用到的参数：</p>
<ul>
<li>data_dir是会话数据和附件存储的路径，记住将备份放在这里</li>
<li>http_interface设置监听的地址。默认监听0.0.0.0，但在使用反向代理时应设置为127.0.0.1来仅响应本地请求。Odoo 11中引入它来代替淘汰了的xmlrpc_interface参数。</li>
</ul>
<p>我们可通过-c或–config选项来检查运行服务的设置：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo su -c &quot;~/odoo-12/odoo-bin -c /etc/odoo/odoo.conf&quot; odoo</span><br></pre></td></tr></table></figure>

<p>通过上述设置运行 Odoo 不会在终端中有任何输出，因为修改都写到了配置文件中定义的日志文件中了。要追踪服务的操作，我们需要在终端中运行如下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo tail -f /var/log/odoo/odoo-server.log</span><br></pre></td></tr></table></figure>

<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/89b08b66bd13498e969f67835263a58b~tplv-k3u1fbpfcp-zoom-1.image" alt="Odoo 12通过-c 检查配置文件"></p>
<p>有时可能会需要将日志输出到标准输出中，最好的方法是复制一份不带logfile选项的配置文件。</p>
<blockquote>
<p><strong>小贴士：</strong> 要在同一个终端窗口中运行多个终端会话，可以使用tmux这样的应用或者GNU Screen。可以使用<a target="_blank" rel="noopener" href="https://help.ubuntu.com/community/Byobu">Byobu</a>，它基于GNU Screen或Tmux提供了好看的用户界面。</p>
</blockquote>
<h3 id="多进程工作进程"><a href="#多进程工作进程" class="headerlink" title="多进程工作进程"></a>多进程工作进程</h3><p>生产实例可能会处理大量的工作负载。默认服务运行单进程并只能使用CPU 的一个核心来处理请求，这是因为Python语言的全局解释器锁（GIL）。但是可使用多进程模式来处理并发请求，来充分利用多核的优势。workers&#x3D;N选项设置使用的工作进程数，作为一个参照，可设置为1+2*P，其中 P为处理器的核数。最佳设置需要根据具体情况进行调优，因为这取决于服务器的负载以及多少其它像PostgreSQL这样大负载服务在运行。</p>
<p>为负载将workers设置高比低好，最低值应为6，因为这是大多数浏览器的并行连接数，最大值通常受服务器的 RAM 所限。普通使用模式的经验是，Odoo服务应能处理(1+2*P)*6个并发用户。</p>
<p>还有一些limit-配置参数可用于调优工作进程。在达到这些值时工作进程会被回收，相应的进程会停止并启动一个新进程。这可以防止服务器内存溢出以及防止某一进程过度使用服务器资源。</p>
<p>官方文档中对工作进程参数调优也给出了一些很好的建议，欲知详情，请参照官方文档<a target="_blank" rel="noopener" href="https://www.odoo.com/documentation/12.0/setup/deploy.html">Odoo 部署</a>。</p>
<h2 id="设置-Odoo-为系统服务"><a href="#设置-Odoo-为系统服务" class="headerlink" title="设置 Odoo 为系统服务"></a>设置 Odoo 为系统服务</h2><p>现在我们需要将 Odoo 设为系统服务，并在系统启动时自动开启。</p>
<p>在Ubuntu或Debian中，init程序负责服务的启动。Debian或其分支操作系统曾使用过sysvinit，Ubuntu曾使用过兼容的名为Upstart的启动程序。但最近都进行了修改，最新的Debian和Ubuntu发行版的init程序都使用了systemd。这表示现在有两种方式来安装系统服务，你需要根据操作系统的版本来选择正确的方法。Ubuntu 16.04或之后的版本中应使用systemd，但是很多云服务商还在使用更早的版本，所以很有可能你也会使用到这些老版本。要检查系统中是否使用systemd，可使用如下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">man init</span><br></pre></td></tr></table></figure>

<p>这条命令会打印当前使用的 init 程序的文档，然后就可以查看所使用的启动服务。</p>
<blockquote>
<p>ℹ️Window的子系统(WSL) 中的 Ubuntu环境仅适用于开发，它有可能发生些异常问题，完全不适合用于运行生产环境。在写本文时，man init显示启动服务为systemd，但并不能安装systemd服务，反而安装sysvinit服务时是正常的。</p>
</blockquote>
<p>补充：如出现-bash: man: command not found，则通过sudo apt install man -y来执行安装</p>
<h3 id="创建systemd服务"><a href="#创建systemd服务" class="headerlink" title="创建systemd服务"></a>创建systemd服务</h3><p>如果你使用的是较近的操作系统，如Debian 8或Ubuntu 16.04，你的启动服务就应该是systemd。要在系统中添加服务，只需创建一个描述服务的文件。我们创建&#x2F;lib&#x2F;systemd&#x2F;system&#x2F;odoo.service文件并加入如下内容：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=Odoo</span><br><span class="line">After=postgresql.service</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type=simple</span><br><span class="line">User=odoo</span><br><span class="line">Group=odoo</span><br><span class="line">ExecStart=/home/odoo/odoo-12/odoo-bin -c /etc/odoo/odoo.conf</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>小贴士：</strong> Odoo源码中在debian&#x2F;下包含一个odoo.service文件示例。你可以不用新建方件，直接把拷贝该文件然后进行所需修改。至少需要根据设置来修改ExecStart选项。</p>
</blockquote>
<p>下一步我们需要使用如下命令来注册这个新服务：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl enable odoo.service</span><br></pre></td></tr></table></figure>

<p>使用如下命令启动该服务：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl start odoo</span><br></pre></td></tr></table></figure>

<p>使用如下命令检查该服务状态：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl status odoo</span><br></pre></td></tr></table></figure>

<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e700ac8d059d4d749c1d58956cd4c197~tplv-k3u1fbpfcp-zoom-1.image" alt="Odoo 12服务运行状态"></p>
<p>最后，如需停止服务，请使用如下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl stop odoo</span><br></pre></td></tr></table></figure>

<h3 id="创建Upstart或sysvinit-服务"><a href="#创建Upstart或sysvinit-服务" class="headerlink" title="创建Upstart或sysvinit 服务"></a>创建Upstart或sysvinit 服务</h3><p>如果你使用更老的操作系统，如Debian 7或Ubuntu 15.04，那么很有可能需要使用sysvinit或Upstart启动服务。就创建系统服务而言，两者的作用一致。一些虚拟专用服务器(VPS)服务还在使用老的Ubuntu镜像，所以在碰到这种情况时可以通过以下方式部署Odoo服务。</p>
<p>Odoo源码中有一个init脚本用于Debian发行包，我们仅需做一些小修改来使用它创建启动服务：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo cp /home/odoo/odoo-12/debian/init /etc/init.d/odoo</span><br><span class="line">sudo chmod +x /etc/init.d/odoo</span><br></pre></td></tr></table></figure>

<p>现在你可能需要查看一下init脚本的内容，主要的参数都在文件上方定义的变量中，如下例所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">PATH=/sbin:/bin:/usr/sbin:/usr/bin:/usr/local/bin</span><br><span class="line">DAEMON=/usr/bin/odoo</span><br><span class="line">NAME=odoo</span><br><span class="line">DESC=odoo</span><br><span class="line">CONFIG=/etc/odoo/odoo.conf</span><br><span class="line">LOGFILE=/var/log/odoo/odoo-server.log</span><br><span class="line">PIDFILE=/var/run/$&#123;NAME&#125;.pid</span><br><span class="line">USER=odoo</span><br></pre></td></tr></table></figure>

<p>这些变量应该足够使用了，接下来我们将使用它们的默认值进行设置，但你可以根据自己的需要进行修改。变量USER是运行服务的系统用户，我们前面已经创建了一个odoo用户。变量DAEMON是可执行服务的路径，我们启动 Odoo 的文件在不同的路径下，但可创建以下软链接：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo ln -s /home/odoo/odoo-12/odoo-bin /usr/bin/odoo</span><br><span class="line">sudo chown -h odoo /usr/bin/odoo</span><br></pre></td></tr></table></figure>

<p>变量CONFIG是我们需要使用的配置文件。在前面一节中，我们在默认配置的路径&#x2F;etc&#x2F;odoo&#x2F;odoo.conf下创建了配置文件。最后变量LOGFILE是存储日志文件的路径。配置的路径&#x2F;var&#x2F;log&#x2F;odoo我们在定义配置文件时进行了创建。</p>
<p>现在我们应该可以像下面这样来启动和关闭 Odoo 服务了：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo /etc/init.d/odoo start</span><br><span class="line">Starting odoo: ok</span><br></pre></td></tr></table></figure>

<p>关闭服务方法相似，命令如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo /etc/init.d/odoo stop</span><br><span class="line">Stopping odoo: ok</span><br></pre></td></tr></table></figure>

<p>Ubuntu中可使用 service 命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo service odoo start</span><br><span class="line">sudo service odoo status</span><br><span class="line">sudo service odoo stop</span><br></pre></td></tr></table></figure>

<p>现在我们需要在系统启动时自动开启服务，通过如下命令实现：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo update-rc.d odoo defaults</span><br></pre></td></tr></table></figure>

<p>这时，重启服务器 Odoo 服务就会正常地自动启动了。是时候测试下一切是否都如预期一样了。</p>
<h3 id="使用命令行检查-Odoo-服务"><a href="#使用命令行检查-Odoo-服务" class="headerlink" title="使用命令行检查 Odoo 服务"></a>使用命令行检查 Odoo 服务</h3><p>现在我们可以确定Odoo实例是否运行以及是否能正常对请求进行响应。如果Odoo正常运行，我们应该可以得到响应并且日志文件中不会报错。在服务器上通过如下命令可检测 Odoo 是否对HTTP请求进行响应：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl http://localhost:8069</span><br><span class="line">&lt;html&gt;&lt;head&gt;&lt;script&gt;window.location = &#x27;/web&#x27; + location.hash;&lt;/script&gt;&lt;/head&gt;&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p>此外通过如下命令可查看日志文件的内容：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo less /var/log/odoo/odoo-server.log</span><br></pre></td></tr></table></figure>

<p>你还可以使用tail -f 来实时查看日志文件中新增的内容：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo tail -f /var/log/odoo/odoo-server.log</span><br></pre></td></tr></table></figure>

<h2 id="设置-Nginx-反向代理"><a href="#设置-Nginx-反向代理" class="headerlink" title="设置 Nginx 反向代理"></a>设置 Nginx 反向代理</h2><p>虽然 Odoo 自身可以输出网页，但强烈建议在其上加一层反向代理。反向代理作为一个中间层来管理客户端所发送请求以及 Odoo 服务作出响应之间的数据流。使用反向代理有诸多好处。</p>
<p>从安全角度考虑，有以下几点：</p>
<ul>
<li>处理并加固HTTPS协议来对数据流加密</li>
<li>隐藏内部网络特征</li>
<li>作为应用防火墙，限制所接受处理的 URL</li>
</ul>
<p>然后从性能角度考虑，反向代理可提供如下显著的改进：</p>
<ul>
<li>缓存静态内容，因而降低 Odoo 服务器的负载</li>
<li>压缩内容来加快加载时间</li>
<li>作为负载均衡器，在多台服务间分配负载</li>
</ul>
<p>Apache是在考虑反向代理时的一个常用选择，Nginx 是近期在技术圈被热议的对其的替代。此处我们使用Nginx作为反向代理，并展示如何使用它来实现上述讨论的安全和性能方面的功能。</p>
<p>首先，我们应当安装Nginx，我们需要它监听默认的HTTP端口，所以需要确保没有被其它服务所占用。执行如下命令应该会报错：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ curl http://localhost</span><br><span class="line">curl: (7) Failed to connect to localhost port 80: Connection refused</span><br></pre></td></tr></table></figure>

<p>如果没有收到错误，应当禁用相应服务来让Nginx使用该端口。例如，关闭已有的Apache服务，使用sudo service apache2 stop。更好的选择是从服务器上删除该服务或重新配置让其监听其它端口，这样Nginx就可以正常使用HTTP和HTTPS端口(80 and 443) 了。</p>
<p>一旦完成上述操作，就可以安装Nginx了：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install nginx -y</span><br><span class="line">sudo service nginx start # 如尚未启动，启动Nginx服务</span><br></pre></td></tr></table></figure>

<p>要确定Nginx是否正确运行，通过浏览器访问或在服务上执行curl <a target="_blank" rel="noopener" href="http://localhost应该可以得到一个welcome/">http://localhost应该可以得到一个Welcome</a> to nginx页面。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3e4ed2e165ea469ab7ceecba32f1b42e~tplv-k3u1fbpfcp-zoom-1.image" alt="Nginx 欢迎页面"></p>
<p>Nginx配置文件和Apache的方式基本相同，存储在&#x2F;etc&#x2F;nginx&#x2F;available-sites&#x2F;中，并可通过在&#x2F;etc&#x2F;nginx&#x2F;enabled-sites&#x2F;中添加软链接来激活。注意应同时关闭Nginx安装时默认带有的配置：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo rm /etc/nginx/sites-enabled/default</span><br><span class="line">sudo touch /etc/nginx/sites-available/odoo</span><br><span class="line">sudo ln -s /etc/nginx/sites-available/odoo /etc/nginx/sites-enabled/odoo</span><br></pre></td></tr></table></figure>

<p>使用nano或vi等编辑器来编辑 Nginx配置文件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo nano /etc/nginx/sites-available/odoo</span><br></pre></td></tr></table></figure>

<p>一个基本的针对Odoo服务的Nginx配置文件如下例所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">upstream odoo &#123;</span><br><span class="line">    server 127.0.0.1:8069;</span><br><span class="line">&#125;</span><br><span class="line">upstream odoochat &#123;</span><br><span class="line">    server 127.0.0.1:8072;</span><br><span class="line">&#125;</span><br><span class="line">server &#123;</span><br><span class="line">     listen 80;</span><br><span class="line">     # Add Headers for odoo proxy mode</span><br><span class="line">     proxy_set_header X-Forwarded-Host $host;</span><br><span class="line">     proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">     proxy_set_header X-Forwarded-Proto $scheme;</span><br><span class="line">     proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line"></span><br><span class="line">     # log</span><br><span class="line">     access_log /var/log/nginx/odoo.access.log;</span><br><span class="line">     error_log /var/log/nginx/odoo.error.log;</span><br><span class="line">     # Redirect longpoll requests to odoo longpolling port</span><br><span class="line">     location /longpolling &#123;</span><br><span class="line">        proxy_pass http://odoochat;</span><br><span class="line">     &#125;</span><br><span class="line">     # Redirect requests to odoo backend server</span><br><span class="line">     location / &#123;</span><br><span class="line">         proxy_redirect off;</span><br><span class="line">         proxy_pass http://odoo;</span><br><span class="line">     &#125;</span><br><span class="line">     # common gzip</span><br><span class="line">    gzip_types text/css text/scss text/plain text/xml application/xml application/json application/javascript;</span><br><span class="line">    gzip on;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>补充：添加域名请在server 配置区内添加对 server_name 的配置</p>
<p>首先为Odoo服务添加了upstream配置，监听了默认端口8069和8072。8069用于网页客户端和RPC请求，8072用于多进程时 Odoo 实时消息所需的长轮询(long polling)请求。</p>
<p>Nginx应在默认HTTP端口80上接收访问流量，然后重定向到upstream odoo服务中。这在server配置区中进行了定义。&#x2F;longpolling 地址的访问流量会传递到upstream odoochat，剩余的流量则传递到upstream odoo。这里我们还添加了一些请求头的信息，这样 Odoo 后台服务就会知道这些是经过代理的流量。</p>
<p>出于安全考虑，应确保proxy_mode参数设为True。这是因为在Nginx作为代理时，所有的请求都会认为是来自本地而不是远程 IP 地址。在代理中设置X-ForwardedFor头以及启动–proxy-mode可解决这一问题。但是，如果不在代理级别强制header就启用–proxy-mode 会让其他人可以伪装远程地址。</p>
<p>在配置文件的最后，可以看到两条gzip相关的命令，它们用于对一些文件进行压缩，提升性能。可通过如下命令测试配置是否正确：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ sudo nginx -t</span><br><span class="line">nginx: the configuration file /etc/nginx/nginx.conf syntax is ok</span><br><span class="line">nginx: configuration file /etc/nginx/nginx.conf test is successful</span><br></pre></td></tr></table></figure>

<p>如果出现错误，请检查配置文件中输入是否正确。常见的问题是默认的HTTP被其它服务所占用，如Apache或默认的Nginx网站，所以在重启Nginx服务前先通过本文中的命令确保并没有这种问题。在完成处理后，可使用如下命令重新加载新的配置：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo /etc/init.d/nginx reload</span><br></pre></td></tr></table></figure>

<p>如果操作系统使用的是systemd，上述命令正确的版本应该是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl reload nginx</span><br></pre></td></tr></table></figure>

<p>通过如下命令可确认 Nginx 是否将访问流量重定向到了后台Odoo服务中：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ curl http://localhost</span><br><span class="line">&lt;html&gt;&lt;head&gt;&lt;script&gt;window.location = &#x27;/web&#x27; + location.hash;&lt;/script&gt;&lt;/head&gt;&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/17946dc3efac4971a92c7d72e199447d~tplv-k3u1fbpfcp-zoom-1.image" alt="Odoo 12登录页面"></p>
<h2 id="配置HTTPS安全服务"><a href="#配置HTTPS安全服务" class="headerlink" title="配置HTTPS安全服务"></a>配置HTTPS安全服务</h2><p>网站数据不应在因特网中以普通文件进行传输，在将Odoo网页服务暴露在网络中时，我们应使用HTTPS协议来对数据进行加密。有时可使用自签署证书。但注意自签署证书可能会带来安全风险，比如中间人攻击(<em>Man-in-the-Middle</em> Attack)，因此有些浏览器会不接受该证书。</p>
<p>更健壮的解决方案是使用认证的证书机构所签署的证书，在运行商业或电商网站时这就尤为重要了。</p>
<blockquote>
<p><strong>小贴士：</strong> <a target="_blank" rel="noopener" href="https://letsencrypt.org/">Let’s Encrypt</a>服务提供免费的证书。Odoo 有现存插件模块处理对Odoo服务SSL证书的自动请求，但在写本文时，还未移植到Odoo 12中，可访问 <a target="_blank" rel="noopener" href="https://github.com/OCA/server-tools/tree/11.0/letsencrypt">GitHub</a> 进一步了解。</p>
</blockquote>
<h3 id="创建自签署-SSL-证书"><a href="#创建自签署-SSL-证书" class="headerlink" title="创建自签署 SSL 证书"></a>创建自签署 SSL 证书</h3><p>下一步，我们应安装证书来启用SSL。创建一个自签署证书，可使用如下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ sudo mkdir /etc/ssl/nginx &amp;&amp; cd /etc/ssl/nginx</span><br><span class="line">$ sudo openssl req -x509 -newkey rsa:2048 -keyout server.key -out server.crt -days 365 -nodes</span><br><span class="line">$ sudo chmod a-wx * # make files read only</span><br><span class="line">$ sudo chown www-data:root * # access only to www-data group</span><br></pre></td></tr></table></figure>

<p>上述命令创建一个&#x2F;etc&#x2F;ssl&#x2F;nginx目录以及不带密码的自签署SSL证书。在运行openssl命令时，会要求用户输入其它信息，然后会生成一个证书和密钥文件。最后，将这些文件的所有权赋予用于运行网页服务的www-data用户。</p>
<h3 id="在-Nginx上配置HTTPS访问"><a href="#在-Nginx上配置HTTPS访问" class="headerlink" title="在 Nginx上配置HTTPS访问"></a>在 Nginx上配置HTTPS访问</h3><p>既然我们已经有了SSL证书，就可以配置 Nginx 来使用它了。要强制使用HTTPS，需要将所有的 HTTP 访问重定向到HTTPS。将前面的server区中替换为如下内容：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    rewrite ^(.*) https://$host$1 permanent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在，如果重新加载Nginx配置并在浏览器中访问服务的话，将会看到http:&#x2F;&#x2F;地址被转换成了https:&#x2F;&#x2F; 地址。但该地址不会返回任何内容，我们需要正确地配置HTTPS服务，可通过添加如下服务器配置来实现：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 443;</span><br><span class="line">    # Add Headers for odoo proxy mode</span><br><span class="line">    proxy_set_header X-Forwarded-Host $host;</span><br><span class="line">    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">    proxy_set_header X-Forwarded-Proto $scheme;</span><br><span class="line">    proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line"></span><br><span class="line">    # SSL parameters</span><br><span class="line">    ssl on;</span><br><span class="line">    ssl_certificate /etc/ssl/nginx/server.crt;</span><br><span class="line">    ssl_certificate_key /etc/ssl/nginx/server.key;</span><br><span class="line">    ssl_session_timeout 30m;</span><br><span class="line">    ssl_protocols TLSv1 TLSv1.1 TLSv1.2;</span><br><span class="line">    ssl_ciphers &#x27;ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES128-GCMSHA256:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-AES256-GCM-SHA384:DHE-RSAAES128-GCM-SHA256:DHE-DSS-AES128-GCM-SHA256:kEDH+AESGCM:ECDHE-RSA-AES128-</span><br><span class="line">    SHA256:ECDHE-ECDSA-AES128-SHA256:ECDHE-RSA-AES128-SHA:ECDHE-ECDSA-AES128-</span><br><span class="line">    SHA:ECDHE-RSA-AES256-SHA384:ECDHE-ECDSA-AES256-SHA384:ECDHE-RSA-AES256-</span><br><span class="line">    SHA:ECDHE-ECDSA-AES256-SHA:DHE-RSA-AES128-SHA256:DHE-RSA-AES128-SHA:DHEDSS-AES128-SHA256:DHE-RSA-AES256-SHA256:DHE-DSS-AES256-SHA:DHE-RSA-AES256-</span><br><span class="line">    SHA:AES128-GCM-SHA256:AES256-GCM-SHA384:AES128-SHA256:AES256-SHA256:AES128-</span><br><span class="line">    SHA:AES256-SHA:AES:CAMELLIA:DES-CBC3-</span><br><span class="line">    SHA:!aNULL:!eNULL:!EXPORT:!DES:!RC4:!MD5:!PSK:!aECDH:!EDH-DSS-DES-CBC3-</span><br><span class="line">    SHA:!EDH-RSA-DES-CBC3-SHA:!KRB5-DES-CBC3-SHA&#x27;;</span><br><span class="line">    ssl_prefer_server_ciphers on;</span><br><span class="line"></span><br><span class="line">    # log</span><br><span class="line">    access_log /var/log/nginx/odoo.access.log;</span><br><span class="line">    error_log /var/log/nginx/odoo.error.log;</span><br><span class="line">    # Redirect longpoll requests to odoo longpolling port</span><br><span class="line">    location /longpolling &#123;</span><br><span class="line">        proxy_pass http://odoochat;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    # Redirect requests to odoo backend server</span><br><span class="line">    location / &#123;</span><br><span class="line">        proxy_redirect off;</span><br><span class="line">        proxy_pass http://odoo;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    # common gzip</span><br><span class="line">    gzip_types text/css text/scss text/plain text/xml application/xml application/json application/javascript;</span><br><span class="line">    gzip on;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上配置代码会监听HTTPS端口并使用&#x2F;etc&#x2F;ssl&#x2F;nginx&#x2F; 证书文件来对数据进行加密。这与我们在<a href="#proxy">设置 Nginx 反向代理</a> 中看到的server 配置区相似。如果重新加载配置，我们的 Odoo 服务将通过HTTPS进行运作，如以下命令所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ sudo nginx -t</span><br><span class="line">nginx: the configuration file /etc/nginx/nginx.conf syntax is ok</span><br><span class="line">nginx: configuration file /etc/nginx/nginx.conf test is successful</span><br><span class="line">$ sudo service nginx reload # or: sudo systemctl reload nginx</span><br><span class="line">* Reloading nginx configuration nginx</span><br><span class="line">...done.</span><br><span class="line">$ curl -k https://localhost</span><br><span class="line">&lt;html&gt;&lt;head&gt;&lt;script&gt;window.location = &#x27;/web&#x27; + location.hash;&lt;/script&gt;&lt;/head&gt;&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p>最后部分的输入可用于确认Odoo客户端正通过HTTPS进行访问。</p>
<blockquote>
<p><strong>小贴士：</strong> 在更早的Odoo镜像中，PosBox仅在HTTP模式下生效，这就需要在 Nginx 中添加对&#x2F;pos&#x2F; 链接的例外处理。Odoo 10及之后的镜像中包含了自签署证书来让PosBOx和IoT Box可通过HTTPS进行通讯，这一修改在 <a target="_blank" rel="noopener" href="https://github.com/odoo/odoo/pull/27936">GitHub</a> 中引入。</p>
</blockquote>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5a25b842e8f54186b9ef0ae1004b7125~tplv-k3u1fbpfcp-zoom-1.image" alt="Odoo 12自签署证书 Nginx"></p>
<h3 id="缓存静态内容"><a href="#缓存静态内容" class="headerlink" title="缓存静态内容"></a>缓存静态内容</h3><p>我们可以配置 Nginx 来缓存服务端静态文件，这样再次请求时就可以访问Nginx 中的缓存，而无需将请求传递到upstream odoo服务中。启用静态内容缓存可带来更快的响应时间并减少 Odoo 服务的工作负载。要启用这一设置，在location &#x2F;longpolling区之前加入如下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># cache static data</span><br><span class="line">    location ~* /web/static/ &#123;</span><br><span class="line">    proxy_cache_valid 200 60m;</span><br><span class="line">    proxy_buffering on;</span><br><span class="line">    expires 864000;</span><br><span class="line">    proxy_pass http://odoo;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过这一些命令，静态数据就可以缓存60分钟了。在这个期间的其它请求Nginx 会直接使用缓存进行响应。</p>
<h2 id="服务和模块更新"><a href="#服务和模块更新" class="headerlink" title="服务和模块更新"></a>服务和模块更新</h2><p>一旦 Odoo 服务运行了一段时间，就会需要对其进行升级。这包括两个步骤：获取服务或模块的新版本、执行安装。</p>
<h3 id="创建分阶环境"><a href="#创建分阶环境" class="headerlink" title="创建分阶环境"></a>创建分阶环境</h3><p>如果你按照<a href="#source">通过源码安装 Odoo</a>一节正确地进行了安装，应该就可以在暂存区仓库中获取并测试新版本源码。强烈建议创建一个生产环境数据库的拷贝，并使用它进行升级测试。如果odoo-prod是我们的生产环境数据库，可通过如下命令创建一个拷贝odoo-stage：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">dropdb odoo-stage</span><br><span class="line">createdb --owner=odoo odoo-stage</span><br><span class="line">pg_dump odoo-prod | psql -d odoo-stage</span><br><span class="line">sudo su odoo</span><br><span class="line">cd ~/.local/share/Odoo/filestore/</span><br><span class="line">cp -al odoo-prod odoo-stage # create filestore hardlinks</span><br><span class="line">exit</span><br></pre></td></tr></table></figure>

<p>在使用以上数据库拷贝之前，应进行清理，比如停止计划动作、关闭 email 服务（包含发送和接收消息）。根据你的设置来执行这些指定步骤，但通常可使用自动化脚本来执行。记住psql可用于在命令行直接执行SQL命令，如psql -d odoo-stage -c “&lt;SQL命令&gt;”。</p>
<blockquote>
<p> <strong>小贴士：</strong> 可通过createdb命令来更快地创建拷贝：createdb –owner&#x3D;odoo –template&#x3D;odoo-prod odoo-stage。但需要说明的是要运行该命令，不能有任何对odoo-prod数据库的连接，因此需要停止Odoo生产环境的服务。</p>
</blockquote>
<h3 id="更新-Odoo-源码"><a href="#更新-Odoo-源码" class="headerlink" title="更新 Odoo 源码"></a>更新 Odoo 源码</h3><p>我们使用git pull 命令来从GitHub仓库获取最新的Odoo源码。在那之前，我们可以使用git tag命令来为当前使用的提交创建一个标签，这样可以可容易的对更新进行撤销，命令如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo su odoo</span><br><span class="line">cd ~/odoo-12</span><br><span class="line">git tag --force 12-last-prod</span><br><span class="line">git pull</span><br></pre></td></tr></table></figure>

<p>要让代码修改生效，我们需要重启Odoo服务。而要使用数据文件的修改生效，需要对模块进行升级。通常对Odoo稳定版本的修改都是代码的修复，因此无需冒险执行模块升级。如果需要对模块升级，可使用-u <module>附加参数，或者是-u base，它将升级所有模块。</p>
<p>现在可以启动Odoo的分阶服务了，它将使用在分阶数据库上使用升级代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">~/odoo-12/odoo-bin -d odoo-stage --http-port=8080 -c /etc/odoo/odoo.conf # optionally add: -u base</span><br><span class="line">exit</span><br></pre></td></tr></table></figure>

<p>Odoo 分阶服务通过在8080端口上进行配置。可通过浏览器访问<a href="http://xxx:8080来检查升级代码是否正确运作。如果出现了错误，可通过如下命令来返回上一个版本：">http://xxx:8080来检查升级代码是否正确运作。如果出现了错误，可通过如下命令来返回上一个版本：</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo su odoo</span><br><span class="line">cd ~/odoo-12</span><br><span class="line">git checkout 12-last-prod</span><br><span class="line">exit</span><br></pre></td></tr></table></figure>

<p>如果一切运行都如预期，则可安全地执行生产环境服务的升级，通常是通过重启来实现。如果想要执行实际的模块升级，建议的方法是停止服务、运行升级、再重启服务，命令如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo service odoo stop</span><br><span class="line">sudo su -c &quot;~/odoo-12/odoo-bin -c /etc/odoo/odoo.conf -u base --stop-after-init&quot; odoo</span><br><span class="line">sudo service odoo start</span><br></pre></td></tr></table></figure>

<p>记住对在用Git 版本进行记录，可通过 git checkout回到修改前，这让我们可以在需要的时候进行回滚。强烈推荐在执行数据库升级前保存备份。在完成之后，可使用 Git 拉取新的版本到生产仓库并完成升级：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sudo su odoo</span><br><span class="line">cd ~/odoo-12</span><br><span class="line">git tag --force 12-last-prod</span><br><span class="line">git pull</span><br><span class="line">exit</span><br><span class="line">sudo service odoo restart # or: sudo systemctl restart odoo</span><br></pre></td></tr></table></figure>

<p>无需频繁进行升级，但也不建议等上一年再进行升级。每几个月进行一次升级。还要记得重启服务来启用代码升级，但对模块升级则并非如此。但如果需要进行指定的漏洞修复，可以更早的进行升级。还应关注公开渠道对 Odoo 安全漏洞的披露，发 GitHub 上 Odoo 的Issues，具体可查看<a target="_blank" rel="noopener" href="https://github.com/odoo/odoo/issues?q=is:issue+label:Security">Security标签</a>，或者是官方的邮件列表，可通过<a target="_blank" rel="noopener" href="https://www.odoo.com/groups%E8%BF%9B%E8%A1%8C%E8%AE%A2%E9%98%85%E3%80%82">https://www.odoo.com/groups进行订阅。</a></p>
<p>作为一项服务，企业版用户会更早地收到邮件通知来警报这一类问题。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在本文中，我们学习了在Debian系生产服务器中设置和运行 Odoo 所需的其它步骤。我们一起了解了配置文件中最重要的设置项，并学习了如何擅用多进程模式。为提升安全性和扩展性，我们还学习了如何使用 Nginx 来作为 Odoo 服务处理之上的反向代理。</p>
<p>本文涵盖了运行 Odoo 服务并向用户提供稳定、安全服务的基础知识。要更多地了解 Odoo，可参考<a target="_blank" rel="noopener" href="https://www.odoo.com/documentation/12.0/">官方文档</a>。其中更深入的讲解了一些课题，并包含了一些本系列文章未涉及的课题。</p>
<p>还有一些有关 Odoo 的出版图书还助于你的学习。Packt Publishing中有一些相关书籍，具体来说Odoo Development Cookbook包含了本系列文章未讨论到的高级课题。</p>
<p>最后，Odoo是一个拥有活跃社区的开源产品。参与、提问并回馈社区不仅有助于学习，还有助于建立人脉。说到这，就不能不提 Odoo 社区联盟(OCA)，它倡导协作并提供高质量的开源代码，可访问<a target="_blank" rel="noopener" href="https://odoo-community.org/%E5%81%9A%E6%9B%B4%E8%BF%9B%E4%B8%80%E6%AD%A5%E4%BA%86%E8%A7%A3%E3%80%82">https://odoo-community.org/做更进一步了解。</a></p>
<h2 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h2><p>以下Odoo官方文档的内容可作为本文讨论课程的补充材料，来帮助获取额外的参考：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.odoo.com/documentation/12.0/setup/deploy.html">部署 Odoo</a></li>
<li><a target="_blank" rel="noopener" href="https://www.odoo.com/documentation/12.0/setup/install.html">安装 Odoo</a></li>
</ul>
<p>本文首发地址：<a target="_blank" rel="noopener" href="https://alanhou.org/developer-mode-odoo12/">Alan Hou 的个人博客</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://alanhou.github.io/2019/01/21/odoo-essentials-12-chapter13/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Alan Hou">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Alan Hou的个人博客">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Alan Hou的个人博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2019/01/21/odoo-essentials-12-chapter13/" class="post-title-link" itemprop="url">第十三章 Odoo 12开发之创建网站前端功能</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2019-01-21 00:00:00" itemprop="dateCreated datePublished" datetime="2019-01-21T00:00:00+08:00">2019-01-21</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2023-02-03 14:19:53" itemprop="dateModified" datetime="2023-02-03T14:19:53+08:00">2023-02-03</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>本文为<a target="_blank" rel="noopener" href="https://alanhou.org/odoo-12-development/">最好用的免费ERP系统Odoo 12开发手册</a>系列文章第十三篇。</p>
<p>Odoo 起初是一个后台系统，但很快就有了前端界面的需求。早期基于后台界面的门户界面不够灵活并且对移动端不友好。为解决这一问题，Odoo 引入了新的网站功能，为系统添加了 CMS(Content Management System)内容管理系统。这使得我们无需集成第三方 CMS 便可创建美观又高效的前端。本文中我们将学习如何利用 Odoo 自带的网站功能开发面向前端的插件模块。</p>
<p>本文主要内容有：</p>
<ul>
<li>学习项目 - 自助图书馆</li>
<li>第一个网页</li>
<li>创建网站</li>
</ul>
<h2 id="开发准备"><a href="#开发准备" class="headerlink" title="开发准备"></a>开发准备</h2><p>我将用第十一章 <a target="_blank" rel="noopener" href="https://alanhou.org/odoo12-kanban-qweb/">Odoo 12开发之看板视图和用户端 QWeb</a>中最后编辑的library_checkout插件模块，代码请见<a target="_blank" rel="noopener" href="https://github.com/alanhou/odoo12-development/tree/master/chapter11">GitHub 仓库</a>。本文完成后的代码也请参见<a target="_blank" rel="noopener" href="https://github.com/alanhou/odoo12-development/tree/master/chapter13">GitHub 仓库</a>。</p>
<h2 id="学习项目-自助图书馆"><a href="#学习项目-自助图书馆" class="headerlink" title="学习项目 - 自助图书馆"></a>学习项目 - 自助图书馆</h2><p>本文中我们将为图书会员添加一个自助服务功能。可供会员分别登录账号来访问他们的借阅请求列表。这样我们就可以学习网站开发的基本技术：创建动态页面、在页面间传递参数、创建表单以及处理表单数据验证。对这些新的图书网站功能，我们要新建一个插件模块library_website。</p>
<p>大家应该已经轻车熟路了，首先创建插件的声明文件ibrary_website&#x2F;<strong>manifest</strong>.py，代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &#x27;name&#x27;: &#x27;Library Website&#x27;,</span><br><span class="line">    &#x27;description&#x27;: &#x27;Create and check book checkout requests.&#x27;,</span><br><span class="line">    &#x27;author&#x27;: &#x27;Alan Hou&#x27;,</span><br><span class="line">    &#x27;depends&#x27;: [</span><br><span class="line">        &#x27;library_checkout&#x27;</span><br><span class="line">    ],</span><br><span class="line">    &#x27;data&#x27;: [</span><br><span class="line">        &#x27;security/ir.model.access.csv&#x27;,</span><br><span class="line">        &#x27;security/library_security.xml&#x27;,</span><br><span class="line">        &#x27;views/library_member.xml&#x27;,</span><br><span class="line">    ],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>网站功能将会依赖于library_checkout。我们并没有添加对website核心插件模块的依赖。website插件为创建完整功能的网站提供了有用的框架，但现在我们仅探讨核心框架自带的基础网站功能，尚无需使用website。我们想要图书会员通过登录信息在图书网站上访问自己的借阅请求。为此需要在图书会员模型中添加一个user_id字段，需要分别在模型和视图中添加，下面就开始进行网站的创建：</p>
<p>1、添加library_website&#x2F;models&#x2F;library_member.py文件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">from odoo import fields, models</span><br><span class="line"></span><br><span class="line">class Member(models.Model):</span><br><span class="line">    _inherit = &#x27;library.member&#x27;</span><br><span class="line">    user_id = fields.Many2one(&#x27;res.users&#x27;)</span><br></pre></td></tr></table></figure>

<p>2、添加library_website&#x2F;models&#x2F;<strong>init</strong>.py文件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">from . import library_member</span><br></pre></td></tr></table></figure>

<p>3、添加library_website&#x2F;<strong>init</strong>.py文件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">from . import models</span><br></pre></td></tr></table></figure>

<p>4、添加library_website&#x2F;views&#x2F;library_member.xml文件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot;?&gt;</span><br><span class="line">&lt;odoo&gt;</span><br><span class="line">    &lt;record id=&quot;view_form_member&quot; model=&quot;ir.ui.view&quot;&gt;</span><br><span class="line">        &lt;field name=&quot;name&quot;&gt;Member Form&lt;/field&gt;</span><br><span class="line">        &lt;field name=&quot;model&quot;&gt;library.member&lt;/field&gt;</span><br><span class="line">        &lt;field name=&quot;inherit_id&quot; ref=&quot;library_member.view_form_member&quot; /&gt;</span><br><span class="line">        &lt;field name=&quot;arch&quot; type=&quot;xml&quot;&gt;</span><br><span class="line">            &lt;field name=&quot;card_number&quot; position=&quot;after&quot;&gt;</span><br><span class="line">                &lt;field name=&quot;user_id&quot; /&gt;</span><br><span class="line">            &lt;/field&gt;</span><br><span class="line">        &lt;/field&gt;</span><br><span class="line">    &lt;/record&gt;</span><br><span class="line">&lt;/odoo&gt;</span><br></pre></td></tr></table></figure>

<p>访问这些网页的都是门户用户，无需访问后台菜单。我们需要为这个用户组设置安全访问权限，否则会在使用图书网站功能时报权限错误。</p>
<p>5、添加library_website&#x2F;security&#x2F;ir.model.access.csv文件，添加对图书模型的读权限：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">id,name,model_id:id,group_id:id,perm_read,perm_write,perm_create,perm_unlink</span><br><span class="line">access_book_portal,Book Portal Access,library_app.model_library_book,base.group_</span><br><span class="line">portal,1,0,0,0</span><br><span class="line">access_member_portal,Member Portal Access,library_member.model_library_member,ba</span><br><span class="line">se.group_portal,1,0,0,0</span><br><span class="line">access_checkout_portal,Checkout Portal Access,library_checkout.model_library_che</span><br><span class="line">ckout,base.group_portal,1,0,0,0</span><br></pre></td></tr></table></figure>

<p>6、在library_website&#x2F;security&#x2F;library_security.xml文件中添加记录规则来限制门户用户所能访问的记录：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot;?&gt;</span><br><span class="line">&lt;odoo&gt;</span><br><span class="line">    &lt;data noupdate=&quot;1&quot;&gt;</span><br><span class="line">        &lt;record id=&quot;member_portal_rule&quot; model=&quot;ir.rule&quot;&gt;</span><br><span class="line">            &lt;field name=&quot;name&quot;&gt;Library Member Portal Access&lt;/field&gt;</span><br><span class="line">            &lt;field name=&quot;model_id&quot; ref=&quot;library_member.model_library_member&quot; /&gt;</span><br><span class="line">            &lt;field name=&quot;domain_force&quot;&gt;</span><br><span class="line">                [(&#x27;user_id&#x27;, &#x27;=&#x27;, user.id)]</span><br><span class="line">            &lt;/field&gt;</span><br><span class="line">            &lt;field name=&quot;groups&quot; eval=&quot;[(4,ref(&#x27;base.group_portal&#x27;))]&quot; /&gt;</span><br><span class="line">        &lt;/record&gt;</span><br><span class="line"></span><br><span class="line">        &lt;record id=&quot;checkout_portal_rule&quot; model=&quot;ir.rule&quot;&gt;</span><br><span class="line">            &lt;field name=&quot;name&quot;&gt;Library Checkout Portal Access&lt;/field&gt;</span><br><span class="line">            &lt;field name=&quot;model_id&quot; ref=&quot;library_checkout.model_library_checkout&quot; /&gt;</span><br><span class="line">            &lt;field name=&quot;domain_force&quot;&gt;</span><br><span class="line">                [(&#x27;member_id.user_id&#x27;, &#x27;=&#x27;, user.id)]</span><br><span class="line">            &lt;/field&gt;</span><br><span class="line">            &lt;field name=&quot;groups&quot; eval=&quot;[(4,ref(&#x27;base.group_portal&#x27;))]&quot; /&gt;</span><br><span class="line">        &lt;/record&gt;</span><br><span class="line">    &lt;/data&gt;</span><br><span class="line">&lt;/odoo&gt;</span><br></pre></td></tr></table></figure>

<p>base.group_portal是门户用户组的标识符。在创建门户用户时，应设置他们的用户类型为 Portal，而不是Internal User。这会让他们属于门户用户组并继承我们上面定义的访问权限：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2a259e27886f45cc80f07a4af70f1ea5~tplv-k3u1fbpfcp-zoom-1.image" alt="Odoo 12门户用户类型"></p>
<p>补充：以上内容需开启开发者模式才可见</p>
<p>一旦为图书会员创建了一个门户用户，就应在我们会员表单中的用户字段中使用。该登录信息将可以访问相应会员的借阅请求。</p>
<blockquote>
<p><strong>小贴士：</strong> 在模型中使用 ACL 和记录规则来实现安全权限比使用控制器的逻辑要更为安全。这是因为攻击者有可能跳过网页控制器直接使用RPC 来访问模型 API 。</p>
</blockquote>
<p>了解了这些，我们就可以开始实现图书网站的功能了。但首先我们来使用简单的Hello World网页简短地介绍下基本网站概念。</p>
<h2 id="第一个网页"><a href="#第一个网页" class="headerlink" title="第一个网页"></a>第一个网页</h2><p>要开始了解 Odoo 网页开发的基础，我们将先实现一个Hello World网页来展示基本概念和技术。很有想象空间，是不是？</p>
<p>要创建第一个网页，我们需要一个控制器对象。首先来添加controllers&#x2F;hello.py文件：</p>
<p>1、在library_website&#x2F;<strong>init</strong>.py文件中添加如下行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">from . import controllers</span><br></pre></td></tr></table></figure>

<p>2、在library_website&#x2F;controllers&#x2F;<strong>init</strong>.py文件中添加如下行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">from . import hello</span><br></pre></td></tr></table></figure>

<p>3、添加实际的控制器文件 library_website&#x2F;controllers&#x2F;hello.py，代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">from odoo import http</span><br><span class="line"></span><br><span class="line">class Hello(http.Controller):</span><br><span class="line">    @http.route(&#x27;/helloworld&#x27;, auth=&quot;public&quot;)</span><br><span class="line">    def helloworld(self):</span><br><span class="line">        return(&#x27;&lt;h1&gt;Hello World!&lt;/h1&gt;&#x27;)</span><br></pre></td></tr></table></figure>

<p>odoo.http模块提供 Odoo 网页相关的功能。我们用于渲染页面的控制器，应该是一个继承了odoo.http.Controller类的对象。实际使用的名称并不是太重要，这里选择了 Hello()，一个常用的选择是 Main()。</p>
<p>在控制器类中使用了匹配 URL 路由的方法。这些路由用于做一些处理并返回结果，通常是返回用户网页浏览器的 HTML 页面。odoo.http.route装饰器用于为 URL 路由绑定方法，本例中使用的是&#x2F;helloworld 路由。</p>
<p>安装library_website模块（~&#x2F;odoo-dev&#x2F;odoo&#x2F;odoo-bin -d dev12 -i library_website）就可以在浏览器中打开<a target="_blank" rel="noopener" href="http://xxx:8069/helloworld%EF%BC%8C%E6%88%91%E4%BB%AC%E5%BA%94%E8%AF%A5%E5%B0%B1%E5%8F%AF%E4%BB%A5%E7%9C%8B%E5%88%B0Hello">http://xxx:8069/helloworld，我们应该就可以看到Hello</a> World问候语了。</p>
<p>本例中方法执行的处理非常简单，它返回一个带有 HTML 标记的文本字符串，Hello World。</p>
<blockquote>
<p>ℹ️使用这里的简单 URL 访问按制器，如果同一 Odoo 实例有多个数据库时，在没有指定目标数据库的情况下将会失败。这可通过在启动配置中设置-d或–db-filter来解决，参见第二章 <a target="_blank" rel="noopener" href="https://alanhou.org/odoo12-development-environment/">Odoo 12开发之开发环境准备</a>。</p>
</blockquote>
<p>你可能注意到在路由装饰中使用了auth&#x3D;’public’参数，对于无需登录的用户开放的页面就需要使用它。如果删除该参数，仅有登录用户方可浏览此页面。如果没有活跃会话(session)则会进入登录页面。</p>
<blockquote>
<p><strong>小贴士：</strong> auth&#x3D;’public’参数实际表示如果访客未登录则使用public特殊用户运行网页控制器。如果登录了，则使用登录用户来代替public。</p>
</blockquote>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d20786befdc4431f87ad79da49878911~tplv-k3u1fbpfcp-zoom-1.image" alt="Odoo 12 Hello World"></p>
<h3 id="使用-QWeb-模板的-Hello-World"><a href="#使用-QWeb-模板的-Hello-World" class="headerlink" title="使用 QWeb 模板的 Hello World"></a>使用 QWeb 模板的 Hello World</h3><p>使用 Python 字符串来创建 HTML 很快就会觉得乏味。QWeb可用来增添色彩，下面就使用模板来写一个改进版的Hello World网页。QWeb模板通过 XML 数据文件添加，技术层面上它是与表单、列表视图类似的一种视图类型。它们甚至存储在同一个技术模型ir.ui.view中。</p>
<p>老规矩，需要在声明文件中添加声明来加载文件，编辑library_website&#x2F;<strong>manifest</strong>.py文件并添加内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x27;data&#x27;: [</span><br><span class="line">...</span><br><span class="line">  &#x27;views/helloworld_template.xml&#x27;,</span><br><span class="line">],</span><br></pre></td></tr></table></figure>

<p>然后添加实际的数据文件views&#x2F;helloworld_template.xml，内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot;?&gt;</span><br><span class="line">&lt;odoo&gt;</span><br><span class="line">    &lt;template id=&quot;helloworld&quot; name=&quot;Hello World Template&quot;&gt;</span><br><span class="line">        &lt;h1&gt;Hello again World!&lt;/h1&gt;</span><br><span class="line">    &lt;/template&gt;</span><br><span class="line">&lt;/odoo&gt;</span><br></pre></td></tr></table></figure>

<p><code>&lt;template&gt;</code>实际上是一种简写形式，它声明<code>&lt;record&gt;</code>将数据以type&#x3D;”qweb”类型加载到ir.ui.view模型中。现在，我们需要修改控制器方法来使用这个模板：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">from odoo import http</span><br><span class="line">from odoo.http import request</span><br><span class="line"></span><br><span class="line">class Hello(http.Controller):</span><br><span class="line"></span><br><span class="line">    @http.route(&#x27;/helloworld&#x27;, auth=&quot;public&quot;)</span><br><span class="line">    def helloworld(self, **kwargs):</span><br><span class="line">        return request.render(&#x27;library_website.helloworld&#x27;)</span><br></pre></td></tr></table></figure>

<p>模板的渲染是通过render()函数的 request 对象来实现的。</p>
<blockquote>
<p><strong>小贴士：</strong> 注意我们添加了**kwargs方法参数。使用该参数，HTTP 请求中的任意附加参数，如GET 或 POST 请求参数，可通过 kwargs 字典捕获。这会让我们的方法更加健壮，因为即便添加了未预期的参数也不会产生错误。</p>
</blockquote>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5cc539144a484939b87d2c77e4f0b38e~tplv-k3u1fbpfcp-zoom-1.image" alt="Odoo 12 使用 QWeb 模板的 Hello World"></p>
<h3 id="HelloCMS"><a href="#HelloCMS" class="headerlink" title="HelloCMS!"></a>HelloCMS!</h3><p>下面我们来增加点趣味性，创建我们自己的简单 CMS。为此我们可以通过 URL在路由中使用模板名（一个页面），然后对其进行渲染。然后就可以动态创建网页，通过我们的 CMS 来提供服务。实现方法很简单：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@http.route(&#x27;/hellocms/&lt;page&gt;&#x27;, auth=&#x27;public&#x27;)</span><br><span class="line">def hello(self, page, **kwargs):</span><br><span class="line">    return http.request.render(page)</span><br></pre></td></tr></table></figure>

<p>以上page 参数应匹配一个模板的外部ID，如果在浏览器中打开<a target="_blank" rel="noopener" href="http://xxx:8069/hellocms/library_website.helloworld%EF%BC%8C%E5%BA%94%E8%AF%A5%E5%8F%88%E5%8F%AF%E4%BB%A5%E7%9C%8B%E5%88%B0%E7%86%9F%E6%82%89%E7%9A%84Hello">http://xxx:8069/hellocms/library_website.helloworld，应该又可以看到熟悉的Hello</a> World 页面了。实际上内置的website模块提供了CMS功能，在 &#x2F;page路径(endpoint)下还包含更为健壮的实现。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7c51b5e3e9f04a468bdec626cf6c4113~tplv-k3u1fbpfcp-zoom-1.image" alt="Odoo 12 CMS示例"></p>
<blockquote>
<p>ℹ️在werkzeug的行话中，endpoint是路由的别名，由其静态部分（不含占位符）来表示。比如，CMS 示例中的 endpoint为&#x2F;hellocms。</p>
</blockquote>
<p>大多数情况下，我们要将页面集成到 Odoo 网站中，因此接下来的示例将使用website插件模块。</p>
<h2 id="创建网站"><a href="#创建网站" class="headerlink" title="创建网站"></a>创建网站</h2><p>前面的示例并未集成到 Odoo 网站中，并有页面 footer 和网站菜单。Odoo 的website插件模板为方便大家提供这些功能。</p>
<p>要使用网站功能，我们需要在工作实例中安装website插件模块。应当在library_website插件模块中添加这一依赖，修改__manifest__.py的 depends 内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x27;depends&#x27;: [</span><br><span class="line">    &#x27;library_checkout&#x27;,</span><br><span class="line">    &#x27;website&#x27;,</span><br><span class="line">],</span><br></pre></td></tr></table></figure>

<p>要使用网站功能，我们需要对控制器和 QWeb模板进行一些修改。控制器中可在路由上添加一个额外的website&#x3D;True参数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@http.route(&#x27;/helloworld&#x27;, auth=&quot;public&quot;, website=True)</span><br><span class="line">def helloworld(self, **kwargs):</span><br><span class="line">    return request.render(&#x27;library_website.helloworld&#x27;)</span><br></pre></td></tr></table></figure>

<p>集成website模块并非严格要求website&#x3D;True参数，不添加它也可以在模板视图中添加网站布局。但是通过添加可以让我们在网页控制器中使用一些功能：</p>
<ul>
<li>路由会自动变成支持多语言并且会从网站安装的语言中自动检测最接近的语言。需要说明这可能会导致重新路由和重定向。</li>
<li>控制器抛出的任何异常都会由网站代码进行处理，这会将默认的错误码变成更友好的错误页面向访客展示。</li>
<li>带有当前网站浏览记录的request.website变量，可在请求中进行使用。</li>
<li>auth&#x3D;public路由的 public用户将是由后台网站配置中选择的用户。这可能会和本地区、时区等相关。</li>
</ul>
<p>如果在网页控制器中无需使用上述功能，则可省略website&#x3D;True参数。但大多数网站QWeb模板需要使用website&#x3D;True开启一些数据，比如底部公司信息，所以最好还是添加上。</p>
<blockquote>
<p>ℹ️传入QWeb运行上下文语言的网站数据由website&#x2F;model&#x2F;ir_ui_view.py文件中的_prepare_qcontext方法设定。</p>
</blockquote>
<p>要在模板中添加网站的基本布局，应为QWeb&#x2F;HTML包裹一个t-call&#x3D;”website.layout”指令，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;template id=&quot;helloworld&quot; name=&quot;Hello World Template&quot;&gt;</span><br><span class="line">    &lt;t t-call=&quot;website.layout&quot;&gt;</span><br><span class="line">        &lt;h1&gt;Hello World!&lt;/h1&gt;</span><br><span class="line">    &lt;/t&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure>

<p>t-call运行QWeb模板website.layout并向其传递 XML 内的tcall 节点。website.layout设计用于渲染带有菜单、头部和底部的完整网页，交将传入的内容放在对应的主区域内。这样，我们的Hello World!示例内容就会显示在 Odoo 网站页面中了。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2604500be7e744538fbe0e0496fd201a~tplv-k3u1fbpfcp-zoom-1.image" alt="Odoo 12依赖 website 后的 Hello World"></p>
<h3 id="添加-CSS-和-JavaScript-资源"><a href="#添加-CSS-和-JavaScript-资源" class="headerlink" title="添加 CSS 和 JavaScript 资源"></a>添加 CSS 和 JavaScript 资源</h3><p>我们的网站页面可能需要一些其它的 CSS 或JavaScript资源。这方面的网页由website 管理，因此需要一个方式来告诉它使用这些文件。我们将使用 CSS 来添加一个简单的删除线效果，创建library_website&#x2F;static&#x2F;src&#x2F;css&#x2F;library.css文件并添加如下内容：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.text-strikeout &#123;</span><br><span class="line">    text-decoration: line-through;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来需要在网站页面中包含该文件。通过在website.assets_frontend模板中添加来实现，该模板用于加载网站相关的资源。添加library_website&#x2F;views&#x2F;website_assets.xml数据文件来继承该模板：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot;?&gt;</span><br><span class="line">&lt;odoo&gt;</span><br><span class="line">    &lt;template id=&quot;assets_frontend&quot;</span><br><span class="line">        name=&quot;library_website_assets&quot;</span><br><span class="line">        inherit_id=&quot;website.assets_frontend&quot;&gt;</span><br><span class="line">        &lt;xpath expr=&quot;.&quot; position=&quot;inside&quot;&gt;</span><br><span class="line">            &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot;</span><br><span class="line">                href=&quot;/library_website/static/src/css/library.css&quot; /&gt;</span><br><span class="line">        &lt;/xpath&gt;</span><br><span class="line">    &lt;/template&gt;</span><br><span class="line">&lt;/odoo&gt;</span><br></pre></td></tr></table></figure>

<p>很快我们就会使用text-strikeout这个新的样式类。当然，可以使用相似的方法来添加JavaScript资源。</p>
<h3 id="借阅列表控制器"><a href="#借阅列表控制器" class="headerlink" title="借阅列表控制器"></a>借阅列表控制器</h3><p>既然我们已经过了一遍基础知识，就来一起实现借阅列表吧。我们需要使用&#x2F;checkout URL来显示借阅列表的网页。为此我们需要一个控制器方法来准备要展示的数据，以及一个QWeb模板来向用户进行展示。</p>
<p>在模块中添加library_website&#x2F;controllers&#x2F;main.py文件，代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">from odoo import http</span><br><span class="line">from odoo.http import request</span><br><span class="line"></span><br><span class="line">class Main(http.Controller):</span><br><span class="line">    @http.route(&#x27;/checkouts&#x27;, auth=&#x27;user&#x27;, website=True)</span><br><span class="line">    def checkouts(self, **kwargs):</span><br><span class="line">        Checkout = request.env[&#x27;library.checkout&#x27;]</span><br><span class="line">        checkouts = Checkout.search([])</span><br><span class="line">        return request.render(</span><br><span class="line">            &#x27;library_website.index&#x27;,</span><br><span class="line">            &#123;&#x27;docs&#x27;: checkouts&#125;)</span><br></pre></td></tr></table></figure>

<p>控制器获取要使用的数据并传给渲染的模板。本例中控制器需要一个登录了的会话，因为路由中有一个auth&#x3D;’user’属性。这是默认行为，推荐明确指出需要用户会话。登录了的用户存储在环境对象中，通过 request.env来使用。search()语句使用它来过滤出相应的借阅记录。</p>
<p>对于无需登录即可访问的控制器，所能读取的数据也是非常有限的。这种情况下，我们经常需要对部分代码采用提权上下文运行。这时我们可使用sudo()模型方法，它将权限上下文权限修改为内部超级用户，突破大部分限制。权力越大，责任越大，我们要小心这种操作带来的安全风险。需要特别注意在提权时输入的参数以及执行的操作的有效性。建议将sudo() 记录集操作控制在最小范围内。</p>
<p>回到我们的代码，它以request.render()方法收尾。和之前一样，我们传入了QWeb模板渲染的标识符，和模板运行用到的上下文字典。本例中我们向模板传入 docs 变量，该变量包含要渲染借阅记录的记录集。</p>
<h3 id="借阅-QWeb-模板"><a href="#借阅-QWeb-模板" class="headerlink" title="借阅 QWeb 模板"></a>借阅 QWeb 模板</h3><p>QWeb模板使用数据文件来添加，我们可以使用library_website&#x2F;views&#x2F;checkout_template.xml文件并添加如下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot;?&gt;</span><br><span class="line">&lt;odoo&gt;</span><br><span class="line">    &lt;template id=&quot;index&quot; name=&quot;Checkout List&quot;&gt;</span><br><span class="line">        &lt;t t-call=&quot;website.layout&quot;&gt;</span><br><span class="line">            &lt;div id=&quot;wrap&quot; class=&quot;container&quot;&gt;</span><br><span class="line">                &lt;h1&gt;Checkouts&lt;/h1&gt;</span><br><span class="line"></span><br><span class="line">                &lt;!-- List of Checkouts --&gt;</span><br><span class="line">                &lt;t t-foreach=&quot;docs&quot; t-as=&quot;doc&quot;&gt;</span><br><span class="line">                    &lt;div class=&quot;row&quot;&gt;</span><br><span class="line">                        &lt;input type=&quot;checkbox&quot; disabled=&quot;True&quot;</span><br><span class="line">                            t-att-checked=&quot;&#x27;checked&#x27; if doc.stage_id.fold else None&quot; /&gt;</span><br><span class="line">                        &lt;a t-attf-href=&quot;/checkout/&#123;&#123;slug(doc)&#125;&#125;&quot;&gt;</span><br><span class="line">                            &lt;h3 t-field=&quot;doc.request_date&quot;</span><br><span class="line">                                t-att-class=&quot;&#x27;text-strikeout&#x27; if doc.stage_id.fold else &#x27;&#x27;&quot; /&gt;</span><br><span class="line">                        &lt;/a&gt;</span><br><span class="line">                    &lt;/div&gt;</span><br><span class="line">                &lt;/t&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        &lt;/t&gt;</span><br><span class="line">    &lt;/template&gt;</span><br><span class="line">&lt;/odoo&gt;</span><br></pre></td></tr></table></figure>

<p>以上代码使用t-foreach指令来迭代 docs 记录集。我们使用了复选框 input 并在借阅完成时保持为已选状态。在 HTML 中，复选框是否被勾选取决于是否有 checked 属性。为此我们使用了t-att-NAME指定来根据表达式动态渲染 checked 属性。当表达式运行结果为 None（或任意其它 false 值）时，QWeb会忽略该属性，本例用它就非常方便了。</p>
<p>在渲染任务名时，t-attf指令用于动态创建打开每个指定任务的明细表单的URL。我们使用一个特殊函数slug()来为每条记录生成易于阅读的 URL。该链接目前尚无法使用，因为我们还没有创建对应的控制器。</p>
<p>在每条借阅记录上，我们还使用了t-att 指令来在借阅为最终状态时应用text-strikeout样式。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b825726a3ea94e80a58c647ca367c67e~tplv-k3u1fbpfcp-zoom-1.image" alt="Odoo 12图书项目 checkouts"></p>
<h3 id="借阅明细页面"><a href="#借阅明细页面" class="headerlink" title="借阅明细页面"></a>借阅明细页面</h3><p>借阅列表中的每一项都有一个相应明细页面的链接。我们就为这些链接实现一个控制器，以及实现一个QWeb模板来用于展示。说到这里应该已经很明朗了。</p>
<p>在library_website&#x2F;controllers&#x2F;main.py文件中添加如下方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Main(http.Controller):</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">    @http.route(&#x27;/checkout/&lt;model(&quot;library.checkout&quot;):doc&gt;&#x27;,</span><br><span class="line">        auth=&#x27;user&#x27;, # 默认值，但此处明确指定</span><br><span class="line">        website=True)</span><br><span class="line">    def checkout(self, doc, **kwargs):</span><br><span class="line">        return http.request.render(</span><br><span class="line">            &#x27;library_website.checkout&#x27;,</span><br><span class="line">            &#123;&#x27;doc&#x27;: doc&#125;)</span><br></pre></td></tr></table></figure>

<p>注意这里路由使用了带有model(“library.checkout”)转换器的占位符，会映射到方法的 doc 变量中。它从 URL 中捕获借阅标识符，可以是简单的 ID 数值或链接别名，然后转换成相应的浏览记录对象。</p>
<p>对于QWeb模板，应在library_website&#x2F;views&#x2F;checkout_template.xml数据文件中添加如下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;template id=&quot;checkout&quot; name=&quot;Checkout Form&quot;&gt;</span><br><span class="line">    &lt;t t-call=&quot;website.layout&quot;&gt;</span><br><span class="line">        &lt;div id=&quot;wrap&quot; class=&quot;container&quot;&gt;</span><br><span class="line">            &lt;h1 t-field=&quot;doc.request_date&quot; /&gt;</span><br><span class="line">            &lt;h5&gt;Member: &lt;span t-field=&quot;doc.member_id&quot; /&gt;&lt;/h5&gt;</span><br><span class="line">            &lt;h5&gt;Stage: &lt;span t-field=&quot;doc.stage_id&quot; /&gt;&lt;/h5&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    &lt;/t&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure>

<p>这里值得一提的是使用了<t t-field>元素。和在后台中一样，它处理字段值的相应展示。比如，它正确地展示日期值和many-to-one值。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e93e756d02ef4784a65fbfd3e43ae1c9~tplv-k3u1fbpfcp-zoom-1.image" alt="Odoo 12借阅明细页面"></p>
<p>补充：controllers&#x2F;<strong>init</strong>.py和__mainfest__.py 中请自行添加控制器文件和数据文件的引用</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>读者现在应该对网站功能的基础有了不错的掌握。我们学习了如何使用网页控制器和QWeb模板来动态渲染网页。然后学习了如何使用website插件并使用它来创建我们自己页面。最后，我们介绍了网站表单插件来帮助我们来创建网页表单。这些都是创建网站功能的核心能技巧。</p>
<p>我们已经学习了Odoo 主要构件的开发，是时候学习如何将Odoo 服务部署到生产环境了。</p>
<p> </p>
<p>☞☞☞第十四章 <a target="_blank" rel="noopener" href="https://alanhou.org/odoo12-deployment/">Odoo 12开发之部署和维护生产实例</a></p>
<p> </p>
<h2 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h2><p>Odoo 官方文档中有一些对本文讲解课题的补充参考材料：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.odoo.com/documentation/12.0/reference/http.html">网页控制器</a></li>
<li><a target="_blank" rel="noopener" href="https://www.odoo.com/documentation/12.0/reference/qweb.html">QWeb语言</a></li>
<li><a target="_blank" rel="noopener" href="https://www.odoo.com/documentation/12.0/reference/javascript_reference.html">JavaScript API指南</a></li>
<li><a target="_blank" rel="noopener" href="https://getbootstrap.com/docs/4.1/getting-started/introduction/">Bootstrap样式文档</a></li>
<li>还可以在<a target="_blank" rel="noopener" href="https://www.packtpub.com/tech/Bootstrap">Packt</a>上找到更多的 Bootstrap学习资源</li>
</ul>
<p>本文首发地址：<a target="_blank" rel="noopener" href="https://alanhou.org/developer-mode-odoo12/">Alan Hou 的个人博客</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://alanhou.github.io/2019/01/20/odoo-essentials-12-chapter12/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Alan Hou">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Alan Hou的个人博客">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Alan Hou的个人博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2019/01/20/odoo-essentials-12-chapter12/" class="post-title-link" itemprop="url">第十二章 Odoo 12开发之报表和服务端 QWeb</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2019-01-20 00:00:00" itemprop="dateCreated datePublished" datetime="2019-01-20T00:00:00+08:00">2019-01-20</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2023-02-03 14:19:47" itemprop="dateModified" datetime="2023-02-03T14:19:47+08:00">2023-02-03</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>本文为<a target="_blank" rel="noopener" href="https://alanhou.org/odoo-12-development/">最好用的免费ERP系统Odoo 12开发手册</a>系列文章第十一篇。</p>
<p>QWeb 是 Odoo 使用的模板引擎，它基于 XML 来生成 HTML 片断和页面。通过 QWeb可生成内容丰富的看板(Kankan)视图、报表和 CMS 网页。本文中我们将学习QWeb 语法以及如何使用 QWeb 来创建我们自己的看板视图和自定义报表。</p>
<p>本文主要内容有：</p>
<ul>
<li>看板是什么？</li>
<li>设计看板视图</li>
<li>QWeb 模板语言</li>
<li>看板视图的继承</li>
<li>添加自定义 CSS 和 JavaScript</li>
</ul>
<h2 id="开发准备"><a href="#开发准备" class="headerlink" title="开发准备"></a>开发准备</h2><p>我们将继续使用第十章 <a target="_blank" rel="noopener" href="https://alanhou.org/odoo12-backend-views/">Odoo 12开发之后台视图 - 设计用户界面</a>完成的library_checkout插件模块。相应代码请见 <a target="_blank" rel="noopener" href="https://github.com/alanhou/odoo12-development/tree/master/chapter10">GitHub仓库</a>。本章完成后的代码也请参见<a target="_blank" rel="noopener" href="https://github.com/alanhou/odoo12-development/tree/master/chapter11">GitHub仓库</a>。</p>
<h2 id="了解看板"><a href="#了解看板" class="headerlink" title="了解看板"></a>了解看板</h2><p>Kanban 是一个日语词汇，字面意思榜单，与精益制造和准时化生产相关联，由丰田工业工程师大野耐一(Taiichi Ohno)引入。最近看板的概念应用于更多领域，并且随着敏捷方法的施行在软件工业内流行起来。</p>
<p>看板让我们能够可视化工作队列，它以列来进行组织，每列代表工作进程的一个阶段。工作项以放在看板对应列的卡片来表示。新的工作项从最左边的列开始，并开始向右移动直至最右边列，代表工作完成。</p>
<p>看板的简单化或视觉效果让其对简单的业务流程有着优异的支持。一个基本的看板示例包含三列，如下图所示：待办、在办和完成。当然它可以扩展为你需要的其它指定流程：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c5f76dc3b9984ba08e1738ce9bdfa848~tplv-k3u1fbpfcp-zoom-1.image" alt="看板示例"></p>
<p>对许多业务用例，看板都是管理相应流程的更有效方式，与 Odoo 11之前的更重的工作流引擎形成鲜明对比。Odoo 在支持经典的列表和表单视图的同时还支持看板视图，这易于我们实施这种类型的视图。下面就让我们一起来学习如何使用看板视图。</p>
<h3 id="看板视图"><a href="#看板视图" class="headerlink" title="看板视图"></a>看板视图</h3><p>现在我们要为借阅模型添加一个看板视图。每个借阅是一个卡片，看板将会被组织成阶段列。在前面的文章中，我们已经添加了stage_id阶段字段。</p>
<p>此前在表单视图我们大部分时候使用 Odoo 独有的 XML 元素，比如<code>&lt;field&gt;</code>和<code>&lt;group&gt;</code>，有时也会使用 HTML 元素，如<code>&lt;h1&gt;</code>或<code>&lt;div&gt;</code>，但用得较少。在看板视图中则恰恰相反，展示模板基于 HTML，仅支持两个 Odoo 独有的元素：<code>&lt;field&gt;</code>和<code>&lt;button&gt;</code>。</p>
<p>最终呈现在网页客户端中的内容是由 QWeb 模板动态生成的。QWeb 引擎处理特殊的 XML 标签和属性来进行生成。这样可以很好地控制如何渲染内容，但也让视图设计更为复杂。看板视图设计灵活性很强，我们将尽力以直接易懂地方式介绍快速创建看板视图的知识。查看与所需相似的看板视图来获取创意然后创建自己的看板是一种不错的方法。</p>
<p>我们将学习两种使用看板视图的方式。一种是卡片列表，它用于联系人、产品、雇员通讯录或应用等。联系人看板视图长这样：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f8c1e58e31084937a9081ce43334a3f7~tplv-k3u1fbpfcp-zoom-1.image" alt="Odoo 12联系人看板视图"></p>
<p>但这不是真正的看板，看板应是一个组织成不同列的卡片，当然看板视图也支持这种布局。可能过 CRM 或项目应用来查看示例。访问CRM &gt; Sales &gt; My Pipeline可得到如下结果：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/06649a94199b4b1a8203711086869147~tplv-k3u1fbpfcp-zoom-1.image" alt="Odoo 12 CRM看板视图"></p>
<p>这两种布局的最大区别是卡片按列的组织方式。这通过 Group By 功能实现，与列表视图中相似。通常分组是通过stage字段实现。看板视图的一个非常有用的功能是可以在列之间拖放卡片，自动分配分组视图字段的对应值。从两个示例中的卡片我们可以看到一些分别。其实它们的设计非常灵活，设计看板卡片不只有一种方式。这两个示例为我们提供设计的一些基础。</p>
<p>联系人卡片基本组成有左侧的图像，主区域的加粗标题和紧随其后的一系列值。CRM 管道卡片结构更为复杂些。卡片主区域也有一个标题以及相关信息紧随其后，还有 footer 区。在该区域中，可看到左侧有一个优先级组件，后面带有一个活动指示，在右侧是一个负责用户的头像。上图中看不到，在鼠标悬停在右上角时还会有一个选项菜单。这个菜单让我们可以修改卡片的颜色提示等。</p>
<p>我们将使用这种更复杂的结构来作为借阅看板卡片的参照。</p>
<h2 id="设计看板视图"><a href="#设计看板视图" class="headerlink" title="设计看板视图"></a>设计看板视图</h2><p>我们将改进一直以来开发的library_checkout模型，为图书借阅添加看板视图。为此我们使用一个新文件library_checkout&#x2F;views&#x2F;checkout_kanban_view.xml。需要在__manifest__.py文件的 data 键最下方添加这个文件。在library_checkout&#x2F;views&#x2F;library_menu.xml文件中，可以看到借阅菜单项使用的窗口操作。需要对其修改来启用本文中添加的视图类型：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;act_window id=&quot;action_library_checkout&quot;</span><br><span class="line">    name=&quot;Checkouts&quot;</span><br><span class="line">    res_model=&quot;library.checkout&quot;</span><br><span class="line">    view_mode=&quot;kanban,tree,form,activity,calendar,graph,pivot&quot; /&gt;</span><br></pre></td></tr></table></figure>

<p>这里我们修改了菜单操作来在view_mode列表的最前面添加了kanban，来让它成为默认的视图模式。然后我们来添加kanban视图记录。与其它视图基本相同，除了 arch 字段内，最外层 XML元素为<kanban>。下一步创建实际使用的 XML 文件library_checkout&#x2F;views&#x2F;checkout_kanban_view.xml来放置这个惊艳的看板视图：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot;?&gt;</span><br><span class="line">&lt;odoo&gt;</span><br><span class="line">    &lt;record id=&quot;library_checkout_kanban&quot; model=&quot;ir.ui.view&quot;&gt;</span><br><span class="line">        &lt;field name=&quot;model&quot;&gt;library.checkout&lt;/field&gt;</span><br><span class="line">        &lt;field name=&quot;arch&quot; type=&quot;xml&quot;&gt;</span><br><span class="line">            &lt;kanban&gt;</span><br><span class="line"></span><br><span class="line">            &lt;/kanban&gt;</span><br><span class="line">        &lt;/field&gt;</span><br><span class="line">    &lt;/record&gt;</span><br><span class="line">&lt;/odoo&gt;</span><br></pre></td></tr></table></figure>

<p>在使用看板视图前，我们需要为图书借阅模型添加几个字段。</p>
<h3 id="优先级、看板状态和颜色"><a href="#优先级、看板状态和颜色" class="headerlink" title="优先级、看板状态和颜色"></a>优先级、看板状态和颜色</h3><p>除阶段外，看板中还有一些常用和有用的字段：</p>
<ul>
<li>priority让用户组织他们的工作项，标记什么应优先处理</li>
<li>kanban_state标记是否应移向下一阶段或因某种原因原地不动。在模型定义层中两者都是选择项字段。在视图层，对它们有特别的组件用于表单和看板视图。</li>
<li>color用于存储看板卡片显示的颜色，并可通过看板视图中的颜色拾取器菜单设置</li>
</ul>
<p>编辑library_checkout&#x2F;models&#x2F;library_checkout.py文件来在我们的模型中添加这些字段：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Checkout(models.Model):</span><br><span class="line">...</span><br><span class="line">    priority = fields.Selection(</span><br><span class="line">        [(&#x27;0&#x27;, &#x27;Low&#x27;),</span><br><span class="line">        (&#x27;1&#x27;, &#x27;Normal&#x27;),</span><br><span class="line">        (&#x27;2&#x27;, &#x27;High&#x27;)],</span><br><span class="line">        &#x27;Priority&#x27;,</span><br><span class="line">        default=&#x27;1&#x27;)</span><br><span class="line">    kanban_state = fields.Selection(</span><br><span class="line">        [(&#x27;normal&#x27;, &#x27;In Progress&#x27;),</span><br><span class="line">        (&#x27;blocked&#x27;, &#x27;Blocked&#x27;),</span><br><span class="line">        (&#x27;done&#x27;, &#x27;Ready for next stage&#x27;)],</span><br><span class="line">        &#x27;Kanban State&#x27;,</span><br><span class="line">        default=&#x27;normal&#x27;)</span><br></pre></td></tr></table></figure>

<p>我们还应该在表单视图中添加这些字段，使用各自的特别组件。kanban_state字段就加在<code>&lt;div class=&quot;oe_title&quot;&gt;</code>之前并在按钮框之后：<code>&lt;field name=&quot;kanban_state&quot; widget=&quot;state_selection&quot; /&gt;</code>。priority应添加在name 字段之前，包裹在<code>&lt;h1&gt;</code>元素中：<code>&lt;field name=&quot;priority&quot; widget=&quot;priority&quot; /&gt;</code>。color字段一般不出现在表单视图中。</p>
<p>既然借阅模型已有我们所需使用的所有字段，我们可以来写看板视图了。</p>
<h3 id="看板卡片元素"><a href="#看板卡片元素" class="headerlink" title="看板卡片元素"></a>看板卡片元素</h3><p>看板视图框架包含一个<code>&lt;kanban&gt;</code>外层元素和以下基础结构：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;kanban default_group_by=&quot;stage_id&quot; class=&quot;o_kanban_small_column&quot;&gt;</span><br><span class="line">                &lt;!-- Fields --&gt;</span><br><span class="line">                &lt;field name=&quot;stage_id&quot; /&gt;</span><br><span class="line">                &lt;field name=&quot;id&quot; /&gt;</span><br><span class="line">                &lt;field name=&quot;color&quot; /&gt;</span><br><span class="line">                &lt;field name=&quot;kanban_state&quot; /&gt;</span><br><span class="line">                &lt;field name=&quot;priority&quot; /&gt;</span><br><span class="line">                &lt;field name=&quot;message_partner_ids&quot; /&gt;</span><br><span class="line"></span><br><span class="line">                &lt;!-- Optional progress bar --&gt;</span><br><span class="line">                &lt;progressbar</span><br><span class="line">                    field=&quot;kanban_state&quot;</span><br><span class="line">                    colors=&#x27;&#123;&quot;done&quot;: &quot;success&quot;, &quot;blocked&quot;: &quot;danger&quot;&#125;&#x27; /&gt;</span><br><span class="line">                &lt;!-- Templates with HTML snippets to use --&gt;</span><br><span class="line">                &lt;templates&gt;</span><br><span class="line">                    &lt;t t-name=&quot;kanban-box&quot;&gt;</span><br><span class="line">                        &lt;!-- HTML Qweb template --&gt;</span><br><span class="line">                    &lt;/t&gt;</span><br><span class="line">                &lt;/template&gt;</span><br><span class="line">            &lt;/kanban&gt;</span><br></pre></td></tr></table></figure>

<p>注意在元素中使用了default_group_by&#x3D;”stage_id”属性，我们用它来让看板默认以 stage 分组，这也是看板通常的分组方式。在简单卡片列表的看板中，如联系人，我们不需要添加该属性，只需使用<code>&lt;kanban&gt;</code>标签即可。<code>&lt;kanban&gt;</code>元素支持以下属性：</p>
<ul>
<li>default_group_by设置默认列分组使用的字段</li>
<li>default_order设置看板项默认使用的排序</li>
<li> quick_create&#x3D;”false”禁用了每列顶部的快速创建选项（大的加号符号），快速创建只需提供标题描述即可创建新项。false是 JavaScript 的语法，必须是小写字母。</li>
<li>class为渲染看板视图的根元素添加 CSS 类。相关类是_kanban_small_column，让列比默认的更加紧湊。其它类可由我们模块的 CSS 文件来进行提供。</li>
<li> group_create, group_edit, group_delete和quick_create_view可设置为 false 来禁用看板列上对应的操作。如group_create&#x3D;”false”删除右侧添加新列的按钮。</li>
<li>on_create用于创建用户点击左上角 Create 按钮时弹出的自定义简单表单视图窗口。应为相应的表单视图添加<code>&lt;module&gt;.&lt;xml_id&gt;</code>值。</li>
</ul>
<p>然后我们的模板中使用了一组字段。确切地说，只有在 QWeb 表达式中明确使用的字段才需要在这里声明，用以保证从服务端抓取它们的数据。QWeb引擎在处理模板前，仅会在视图中查找 <code>&lt;field name=&quot;...&quot;&gt;</code>来从模型中获取数据。QWeb的属性通常使用不会被检测到的record.field引用方式。正因为如此，需在<code>&lt;templates&gt;</code>之前包含这些字段来让模板处理时有相应字段值可以使用。</p>
<blockquote>
<p>ℹ️<strong>Odoo 11中的修改</strong><br>引入了进度条组件。使用的时候在看板列的上方会出现一个颜色条，来提供该列各项的状态数据。在本文前面CRM Pipeline的示例图中可以查看。</p>
</blockquote>
<p><code>&lt;progressbar&gt;</code>有如下属性：</p>
<ul>
<li>field是对列中各项进行颜色分组的字段名</li>
<li>colors是一个字典，将分组字段值与以下三种颜色分别进行映射：danger (红色), warning (黄色)或success (绿色)。</li>
<li>sum_field是一个可选项，用于选取整列汇总的字段名。如未设置，会使用各项的计数值。</li>
</ul>
<p>然后我们的<code>&lt;templates&gt;</code>元素包含一个或多个QWeb模板来生成要使用的 HTML 片断。必须要有一个名为kanban-box的模板，它渲染看板卡片。还可以添加其它模板，通常用于定义主模板中复用到的 HTML 片断。这些模板使用标准的 HTML 和 QWeb 模板语言。QWeb提供了一些特殊指令，用于处理动态生成最终展示的 HTML。</p>
<blockquote>
<p>ℹ️<strong>Odoo 12中的修改</strong><br>Odoo 现在使用 Twitter Bootstrap 4，此前版本中使用Bootstrap 3。这些样式在渲染 HTML 的地方通常都可使用，有关Bootstrap更多知识请见<a target="_blank" rel="noopener" href="https://getbootstrap.com/">官方网站</a>。</p>
</blockquote>
<p>下面就来详细了解看板视图中所使用的QWeb模板设计。</p>
<h3 id="看板卡片布局"><a href="#看板卡片布局" class="headerlink" title="看板卡片布局"></a>看板卡片布局</h3><p>看板卡片主内容区域在kanban-box模板内定义。这个内容区也可以有一个 footer 底部子容器。卡片右上角还可以添加按钮，点击后打开操作菜单的功能。对于footer区域，应在看板盒子模型底部使用<div>并添加oe_kanban_bottom CSS 类。还可以通过oe_kanban_bottom_left和oe_kanban_bottom_right CSS 类进一步分割为左、右 footer 区。此外，可通过Bootstrap的pull-left和pull-right类在卡片的任意位置（包括oe_kanban_bottom底部区域）添加向左或向右对齐元素。</p>
<p>以下是对看板卡片中QWeb模板的第一次迭代：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;t t-name=&quot;kanban-box&quot;&gt;</span><br><span class="line">    &lt;!-- Set the Kanban Card color --&gt;</span><br><span class="line">    &lt;div t-attf-class=&quot;</span><br><span class="line">        oe_kanban_color_#&#123;kanban_getcolor(record.color.raw_value)&#125;</span><br><span class="line">        oe_kanban_global_click&quot;&gt;</span><br><span class="line">        &lt;div class=&quot;o_dropdown_kanban dropdown&quot;&gt;</span><br><span class="line">            &lt;!-- Top-right drop down menu here... --&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">        &lt;div class=&quot;oe_kanban_body&quot;&gt;</span><br><span class="line">            &lt;!-- Content elements and fields go here... --&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">        &lt;div class=&quot;oe_kanban_footer&quot;&gt;</span><br><span class="line">            &lt;div class=&quot;oe_kanban_footer_left&quot;&gt;</span><br><span class="line">                &lt;!-- Left hand footer... --&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">            &lt;div class=&quot;oe_kanban_footer_right&quot;&gt;</span><br><span class="line">                &lt;!-- Right hand footer... --&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">        &lt;div class=&quot;oe_clear&quot; /&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/t&gt;</span><br></pre></td></tr></table></figure>

<p>这就是看板卡片的整体结构。你可能注意到了在顶部<code>&lt;div&gt;</code>元素中使用了color字段来动态设置卡片颜色。在后面的部分中我们会讲解t-attf QWeb指令的细节。现在来为主内容区域添加内容：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;oe_kanban_body&quot;&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;strong&gt;</span><br><span class="line">            &lt;a type=&quot;open&quot;&gt;&lt;field name=&quot;member_id&quot; /&gt;&lt;/a&gt;</span><br><span class="line">        &lt;/strong&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;ul&gt;</span><br><span class="line">        &lt;li&gt;&lt;field name=&quot;user_id&quot; /&gt;&lt;/li&gt;</span><br><span class="line">        &lt;li&gt;&lt;field name=&quot;request_date&quot; /&gt;&lt;/li&gt;</span><br><span class="line">    &lt;/ul&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<p>这个模板中大部分都是常规 HTML，但也有渲染字段值的<code>&lt;field&gt;</code>元素和在常规表单视图按钮中使用的 type 属性，此处用在锚文本标签中。</p>
<p>在左部 footer 中插入优先级组件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">                            &lt;div class=&quot;o_kanban_record_bottom&quot;&gt;</span><br><span class="line">                                &lt;div class=&quot;oe_kanban_bottom_left&quot;&gt;</span><br><span class="line">                                    &lt;field name=&quot;priority&quot; widget=&quot;priority&quot; /&gt;</span><br><span class="line">                                    &lt;field name=&quot;activity_ids&quot; widget=&quot;kanban_activity&quot; /&gt;</span><br><span class="line">                                &lt;/div&gt;</span><br><span class="line">...</span><br><span class="line">                            &lt;/div&gt;</span><br></pre></td></tr></table></figure>

<p>这里像我们在表单视图中做的那样添加了priority字段。还添加了一个计划活动的字段，使用kanban_activity特殊组件来显示即将开始活动的指示。</p>
<p>在右部footer中，放入看板状态组件和请求借阅的会员头像：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;oe_kanban_bottom_right&quot;&gt;</span><br><span class="line">    &lt;field name=&quot;kanban_state&quot;</span><br><span class="line">        widget=&quot;kanban_state_selection&quot; /&gt;</span><br><span class="line">    &lt;img t-att-src=&quot;kanban_image(</span><br><span class="line">            &#x27;library.checkout&#x27;,</span><br><span class="line">            &#x27;member_image&#x27;,</span><br><span class="line">            record.id.raw_value)&quot;</span><br><span class="line">        t-att-title=&quot;record.member_id.value&quot;</span><br><span class="line">        t-att-alt=&quot;record.member_id.value&quot;</span><br><span class="line">        width=&quot;24&quot;</span><br><span class="line">        height=&quot;24&quot;</span><br><span class="line">        class=&quot;oe_kanban_avatar&quot;</span><br><span class="line">    /&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<p>补充：原文件使用的 CSS 类oe_kanban_footer，oe_kanban_footer_left和oe_kanban_footer_right经测试不会进行左右对齐，参照 CRM 进行了如上修改</p>
<p>看板状态通过<code>&lt;field&gt;</code>元素和kanban_state_selection组件来进行添加。用户头像使用 HTML <code>&lt;img&gt;</code>标签插入。图像内容使用QWeb t-att-命令动态生成，后面会详细讲解。这里使用了kanban_image()帮助函数来获取src属性的值。kanban_image() Javascript函数从 Odoo 模型中获取表单并在网页中渲染。有以下属性：</p>
<ul>
<li>获取图像的模型</li>
<li>包含图像的字段</li>
<li>获取的记录 ID</li>
</ul>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b3ad0d808c6d4afd9fc5eea7d201eaa9~tplv-k3u1fbpfcp-zoom-1.image" alt="Odoo 12看板 footer 添加"></p>
<h3 id="为看板卡片添加选项菜单"><a href="#为看板卡片添加选项菜单" class="headerlink" title="为看板卡片添加选项菜单"></a>为看板卡片添加选项菜单</h3><p>看板卡片可在右上角带有一个选项菜单。通常的操作有编辑或删除记录，但也可以为其添加和按钮调用的同样操作。还有一个设置卡片颜色的组件。以下是oe_kanban_content顶部添加的选项菜单的基础代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;o_dropdown_kanban dropdown&quot;&gt;</span><br><span class="line">    &lt;a class=&quot;dropdown-toggle btn&quot;</span><br><span class="line">        data-toggle=&quot;dropdown&quot; role=&quot;button&quot;</span><br><span class="line">        aria-label=&quot;Dropdown menu&quot;</span><br><span class="line">        title=&quot;Dropdown menu&quot;</span><br><span class="line">        href=&quot;#&quot;&gt;</span><br><span class="line">        &lt;span class=&quot;fa fa-ellipsis-v&quot; /&gt;</span><br><span class="line">    &lt;/a&gt;</span><br><span class="line">    &lt;div class=&quot;dropdown-menu&quot; role=&quot;menu&quot;&gt;</span><br><span class="line">        &lt;!-- Edit and Delete actions, if available: --&gt;</span><br><span class="line">        &lt;t t-if=&quot;widget.editable&quot;&gt;</span><br><span class="line">            &lt;a role=&quot;menuitem&quot; type=&quot;edit&quot; class=&quot;dropdown-item&quot;&gt;Edit&lt;/a&gt;</span><br><span class="line">        &lt;/t&gt;</span><br><span class="line">        &lt;t t-if=&quot;widget.deletable&quot;&gt;</span><br><span class="line">            &lt;a role=&quot;menuitem&quot; type=&quot;delete&quot; class=&quot;dropdown-item&quot;&gt;Delete&lt;/a&gt;</span><br><span class="line">        &lt;/t&gt;</span><br><span class="line">        &lt;!-- Color picker option --&gt;</span><br><span class="line">        &lt;ul class=&quot;oe_kanban_colorpicker&quot; data-field=&quot;color&quot; /&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<p>下拉菜单基本上是由带有<code>&lt;a&gt;</code>标签的<code>&lt;li&gt;</code> HTML 列表元素组成。Edit 和 Delete 这类选项需要满足指定条件下才会出现。这通过<a href="">QWeb的</a><a href="">t-if命令来实现。本文后续会详细讲解</a><a href="">QWeb的命令。widget全局变量表示一个KanbanRecord()  JS 对象，负责渲染当前看板卡片。有两个非常有用的属性：widget.editable和widget.deletable，让我们可以检查相应的操作是否可用。</a></p>
<p>可以看到如何根据记录字段值来显示或隐藏选项，Set as Done仅在未设置is_done 字段时才会显示。最后一个选项添加颜色拾取器组件来使用 color 数据字段选择或修改卡片背景色。因此，除<code>&lt;button&gt;</code>元素外，<code>&lt;a&gt;</code>也可用于运行Odoo 操作。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a970e9acfd144d05bdc69c10e05e285c~tplv-k3u1fbpfcp-zoom-1.image" alt="Odoo 12看板视图下拉选项"></p>
<h3 id="看板视图中的操作"><a href="#看板视图中的操作" class="headerlink" title="看板视图中的操作"></a>看板视图中的操作</h3><p>在QWeb模板中，用于超链的<code>&lt;a&gt;</code>标签可带有一个 type 属性。它设置链接执行的操作类型，这样链接和常规表单中的按钮可进行同样的操作。和表单视图一样，操作类型可以是action或object，并应带有一个 name 属性来标识所要执行的具体操作。此外，还有以下操作类型可以使用：</p>
<ul>
<li>open打开相应的表单视图</li>
<li>edit在编辑模式下直接打开相应的表单视图</li>
<li>delete删除记录并从看板视图中删除该项</li>
</ul>
<h2 id="QWeb-模板语言"><a href="#QWeb-模板语言" class="headerlink" title="QWeb 模板语言"></a>QWeb 模板语言</h2><p>QWeb会查找模板中的特殊指令并替换为动态生成的 HTML。这些指令是 XML 元素属性，可以用在<code>&lt;div&gt;</code>, <code>&lt;span&gt;</code>或<code>&lt;field&gt;</code>等有效标签或元素中。有时我们要使用QWeb指令但不希望放在模板的 XML 元素中。对这种情况，可以使用能带有 QWeb 指令（如t-if或t-foreach）的特殊元素<code>&lt;t&gt;</code>，该元组不会在最终产生的XML&#x2F;HTML有任何输出。</p>
<p>QWeb指令常使用运算的表达式来根据当前记录值生成不同的结果。有两种不同的QWeb实现：客户端JavaScript和服务端Python。报表和网页使用服务端QWeb的 Python 实现。看板视图使用客户端JavaScript实现。也就是说看板视图中的QWeb表达式应使用JavaScript语法书写，而不是 Python。</p>
<p>在显示看板视图时，内部的步骤大致如下：</p>
<ol>
<li>获取模板的XML进行渲染</li>
<li>调用服务端read()方法来获取模板中所涉及的字段数据</li>
<li>定位kanban-boxs模板并使用QWeb解析它来输出最终的HTML片断</li>
<li>在浏览器显示(DOM)中注入 HTML</li>
</ol>
<p>以上在技术上并不精确，仅是用于理解看板视图中如何运作的脑图。下面我们将学习QWeb表达式运行并探讨可用的QWeb指令，通过示例改进借阅看板卡片。</p>
<h3 id="QWeb-JavaScript-运行上下文"><a href="#QWeb-JavaScript-运行上下文" class="headerlink" title="QWeb JavaScript 运行上下文"></a>QWeb JavaScript 运行上下文</h3><p>许多QWeb指令使用表达式的运行来生成结果。在看板视图这类客户端的应用中，表达式应使用JavaScript书写。表达式在带有几个有用变量的上下文中进行运行。可用record 对象带有从服务端请求的字段来表示当前记录。字段值可通过raw_value或value属性来获取：</p>
<ul>
<li>raw_value是由服务端read()方法返回的值，因此在条件表达式中更适用</li>
<li>value根据用户设置来格式化，用于在用户界面中的显示。常用于date&#x2F;datetime, float&#x2F;monetary和关联字段。</li>
</ul>
<p>QWeb运行上下文还可在JavaScript网页客户端中引用。要擅用这些需要对网页客户端结构有很好的理解，但这里我们不会进行深入介绍。要进行引用 ，QWeb表达式运行中有以下标识符可以使用：</p>
<ul>
<li>widget是对当前KanbanRecord() 组件对象的引用 ，用于在看板卡片中渲染当前记录。它会暴露一些帮助函数供我们使用。</li>
<li>record是widget.record的简写形式，使用点号标记来提供对可用字段的访问。</li>
<li>read_only_mode表示当前视图是否为读模式（而非编辑模式）。它是widget.view.options.read_only_mode的简写形式。</li>
<li>instance是对全部网页客户端实例的一个引用 。</li>
</ul>
<p>值得一提的是有些字符是不能在表达式中使用的，比如小于号(<code>&lt;</code>) 。这是因为在 XML 标准中，这些字符具有特殊含义，不应在 XML 内容中使用。反向的<code>&gt;=</code>是一个有效替代方式，但通常是使用以下替代符号来进行不等式运算：</p>
<ul>
<li>lt是小于</li>
<li>lte是小于等于</li>
<li>gt是大于</li>
<li>gte是大于等于</li>
</ul>
<blockquote>
<p>ℹ️前述的比较符号仅用于 Odoo，是引入来解决 XML 格式中的限制的。它们不是 XML 标准的一部分。</p>
</blockquote>
<h3 id="字符串替换动态属性–-t-attf"><a href="#字符串替换动态属性–-t-attf" class="headerlink" title="字符串替换动态属性– t-attf"></a>字符串替换动态属性– t-attf</h3><p>我们的看板卡片使用t-attf QWeb指令来为顶级<code>&lt;div&gt;</code>元素动态设置一个类，这样卡片可根据 color 字段值来显示颜色。为此使用了t-attf- QWeb指令。t-attf-指令使用字符串替换动态生成标签属性。这让像 URL 地址或 CSS 类名这类较大字符串中的部分内容可动态生成。</p>
<p>该指令查找表达式代码块进行运行并替换结果。它们通过 或#{和}来进行分隔。代码块的内容可以是任意JavaScript表达式并使用QWeb表达式中的任意可用变量，如record和widget。本例中我们还使用了专门提供的kanban_color() JS 函数，用于映射索引值到类颜色名。</p>
<p>作为一个更复杂的示例，我们使用这个指令来动态生成用户的颜色，红色字体表示优先级很高。下面替换看板卡片中的相应代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;li t-attf-class=&quot;oe_kanban_text_&#123;&#123;</span><br><span class="line">    record.priority.raw_value lt &#x27;2&#x27;</span><br><span class="line">    ? &#x27;black&#x27; : &#x27;red&#x27;&#125;&#125;&quot;&gt;</span><br><span class="line">    &lt;field name=&quot;user_id&quot; /&gt;</span><br><span class="line">&lt;/li&gt;</span><br></pre></td></tr></table></figure>

<p>这将会根据借阅优先级的值生成class&#x3D;”oe_kanban_text_red”或class&#x3D;”oe_kanban_text_black”。请注意看板视图中是有oe_kanban_text_red这个 CSS 类的，但oe_kanban_text_black仅用于演示，实际并不存在。</p>
<blockquote>
<p>ℹ️注意JavaScript表达式中使用的lt符号，是<code>&lt;</code>的转义表达式，并不能在XML中使用。</p>
</blockquote>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bbb868371a0c4abca20de08364d4a513~tplv-k3u1fbpfcp-zoom-1.image" alt="Odoo 12字符串替换动态属性"></p>
<h3 id="表达式动态属性-t-att"><a href="#表达式动态属性-t-att" class="headerlink" title="表达式动态属性 - t-att"></a>表达式动态属性 - t-att</h3><p>t-att- QWeb指令通过运行表达式动态生成属性值。我们的看板卡片中使用它来为<code>&lt;img&gt;</code>标签动态生成属性，title 属性使用以下表达式动态渲染：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">t-att-title=&quot;record.member_id.value&quot;</span><br></pre></td></tr></table></figure>

<p>.value字段返回在屏幕上显示的值。对于many-to-one字段，这通常是相关记录的 name 值。对于用户则是用户名。运行之后在鼠标悬停于图像上时会显示相应的用户名。</p>
<p>在表达式运行的结果值为假时，就不会渲染该属性。这对于特殊的 HTML 属性非常重要，比如 input 字段中的 checked，即便在没有属性值时也会有显示效果。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/84a431fa9e4849ff8c848cc377f2a8ca~tplv-k3u1fbpfcp-zoom-1.image" alt="Odoo 12表达式动态属性 "></p>
<h3 id="循环-t-foreach"><a href="#循环-t-foreach" class="headerlink" title="循环 - t-foreach"></a>循环 - t-foreach</h3><p>通过循环遍历来重复同一 HTML 代码块。我们可使用它来添加记录 follower 的头像。让我们先来仅渲染记录的partner ID：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;t t-foreach=&quot;record.message_partner_ids.raw_value&quot; t-as=&quot;rec&quot;&gt;</span><br><span class="line">    &lt;t t-esc=&quot;rec&quot; /&gt;;</span><br><span class="line">&lt;/t&gt;</span><br></pre></td></tr></table></figure>

<p>t-foreach指令接收一个JavaScript表达式，运行来遍历集合。在大多数情况下，这会是 一个to-many关联字段的名称。与t-as指令一同使用来设置用于引用遍历各项的名称。下面使用的t-esc指令运行所提供的表达式，本处仅为 rec 变量名，将其渲染为已转译的安全 HTML。</p>
<p>在上例中，我们遍历了存储在message_partner_ids 字段中的 follower。因为在看板卡片上的空间有限，我们使用JS 的slice()函数来限定所显示的follower数量，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">t-foreach=&quot;record.message_partner_ids.raw_value.slice(0, 3)&quot;</span><br></pre></td></tr></table></figure>

<p>rec变量存储每个遍历值，本例中为partner ID。这样我们可以将循环改写为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;t t-foreach=&quot;record.message_partner_ids.raw_value.slice(0,3)&quot; t-as=&quot;rec&quot;&gt;</span><br><span class="line">    &lt;img t-att-src=&quot;kanban_image(&#x27;res.partner&#x27;, &#x27;image_small&#x27;, rec)&quot;</span><br><span class="line">        class=&quot;oe_avatar&quot; width=&quot;24&quot; height=&quot;24&quot; alt=&quot;&quot; /&gt;</span><br><span class="line">&lt;/t&gt;</span><br></pre></td></tr></table></figure>

<p>比如可将其添加在右侧 footer 的用户头像旁。还包含一些帮助变量，它们的名称以t_as 中定义的变量名为前缀。本例中使用了rec，因此可用的帮助变量如下：</p>
<ul>
<li>rec_index是迭代索引，从0开始</li>
<li>rec_size是集合中的元素数量</li>
<li>rec_first在迭代的第一个元素中为真</li>
<li>rec_last在迭代的最后一个元素中为真</li>
<li>rec_even在索引为偶数时为真</li>
<li>rec_odd在索引为奇数时为真</li>
<li>rec_parity根据当前索引为odd或even</li>
<li>rec_all表示进行迭代的对象</li>
<li>rec_value在迭代{key:value} 字典时，存储value (rec存储键名)</li>
</ul>
<p>例如可通过如下代码去除ID 列表最后逗号：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;t t-foreach=&quot;record.message_parter_ids.raw_value.slice(0, 3)&quot;</span><br><span class="line">    t-as=&quot;rec&quot;&gt;</span><br><span class="line">    &lt;t t-esc=&quot;rec&quot; /&gt;</span><br><span class="line">    &lt;t t-if=&quot;!rec_last&quot;&gt;;&lt;/t&gt;</span><br><span class="line">&lt;/t&gt;</span><br></pre></td></tr></table></figure>

<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/62b207944c9240ef9580c2e0dd46ae33~tplv-k3u1fbpfcp-zoom-1.image" alt="Odoo 12 循环遍历"></p>
<h3 id="条件判断-t-if"><a href="#条件判断-t-if" class="headerlink" title="条件判断 - t-if"></a>条件判断 - t-if</h3><p>我们的看板视图在卡片选项菜单中使用了t-if指令来根据不同条件显示不同选项。t-if指令在客户端渲染看板视图时需传入在 JS 中运行的表达式。标签和其内容仅在条件运行值为true 时才会渲染。作为示例，仅在借出有值时显示图书借出数量，在request_date字段后加入如下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;t t-if=&quot;record.num_books.raw_value gt 0&quot;&gt;</span><br><span class="line">    &lt;li&gt;&lt;field name=&quot;num_books&quot; /&gt; books&lt;/li&gt;</span><br><span class="line">&lt;/t&gt;</span><br></pre></td></tr></table></figure>

<p>我们使用了<code>&lt;t t-if=&quot;...&quot;&gt;</code>元素，这样在条件为 false 时，元素不会有任何输出。在为 true 时，仅会渲染其所包含的<code>&lt;li&gt;</code>元素来进行输出。注意条件表达式中使用gt符号来替代<code>&gt;</code>以表示大于运算符。可通过t-elif和t-else来支持else if和else条件语句，使用示例如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;t t-if=&quot;record.num_books.raw_value == 0&quot;&gt;</span><br><span class="line">    &lt;li&gt;No books.&lt;/li&gt;</span><br><span class="line">&lt;/t&gt;</span><br><span class="line">&lt;t t-elif=&quot;record.num_books.raw_value gt 9&quot;&gt;</span><br><span class="line">    &lt;li&gt;A lot of books!&lt;/li&gt;</span><br><span class="line">&lt;/t&gt;</span><br><span class="line">&lt;t t-else=&quot;&quot;&gt;</span><br><span class="line">    &lt;li&gt;&lt;field name=&quot;num_books&quot; /&gt; books.&lt;/li&gt;</span><br><span class="line">&lt;/t&gt;</span><br></pre></td></tr></table></figure>

<p>Javascript表达式中，AND和OR的运算符分别为&amp;&amp;和 ||。但在 XML 中不支持&amp;符号，我们可以使用 and 和 or 运算符来规避这一问题。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dd2823f9036f4465a39c5e956b743fd9~tplv-k3u1fbpfcp-zoom-1.image" alt="Odoo 12 QWeb 条件判断"></p>
<h3 id="渲染值-t-esc和t-raw"><a href="#渲染值-t-esc和t-raw" class="headerlink" title="渲染值 - t-esc和t-raw"></a>渲染值 - t-esc和t-raw</h3><p>我们使用了<code>&lt;field&gt;</code>元素来渲染值，但也可以无需<code>&lt;field&gt;</code>标签直接显示字段值。t-esc指令运行表达式并将其渲染为转义后的 HTML 值，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;t t-esc=&quot;record.message_partner_ids.raw_value&quot; /&gt;</span><br></pre></td></tr></table></figure>

<p>有些情况下，如果确定源数据是安全的，可以无需转义使用t-raw 来渲染原始值，如下例所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;t t-raw=&quot;record.message_partner_ids.raw_value&quot; /&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>小贴士：</strong> 出于安全考虑，应尽量避免使用t-raw。它应严格用于输出特别准备不包含用户数据的HTML 数据，或者是已明确对 HTML 特殊字符转义的用户数据。</p>
</blockquote>
<h3 id="为变量设置值-t-set"><a href="#为变量设置值-t-set" class="headerlink" title="为变量设置值 - t-set"></a>为变量设置值 - t-set</h3><p>对于更复杂的逻辑，我们可以将表达式结果存储在变量中，在模板中随后使用。这通过t-set指令来实现，它设置变量名，紧接着使用t-value指令来添加表达式计算分配的值。作为示例，以下代码将优先级较高的和前面一节一样渲染为红色，但使用red_or_black 变量来作为 CSS 类使用的变量，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;t t-set=&quot;red_or_black&quot;</span><br><span class="line">    t-value=&quot;record.priority.raw_value gte &#x27;2&#x27; ? &#x27;oe_kanban_text_red&#x27; :&#x27;&#x27;&quot; /&gt;</span><br><span class="line">&lt;li t-att-class=&quot;red_or_black&quot;&gt;</span><br><span class="line">    &lt;field name=&quot;user_id&quot; /&gt;</span><br><span class="line">&lt;/li&gt;</span><br></pre></td></tr></table></figure>

<p>变量中也可分配 HTML内容，示例如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;t t-set=&quot;calendar_sign&quot;&gt;</span><br><span class="line">    &lt;i class=&quot;fa fa-calendar&quot; /&gt;</span><br><span class="line">&lt;/t&gt;</span><br><span class="line">&lt;t t-raw=&quot;calendar_sign&quot; /&gt;</span><br></pre></td></tr></table></figure>

<p> </p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/30566f47384743f99269d8d535f13e98~tplv-k3u1fbpfcp-zoom-1.image" alt="Odoo 12为变量设置值"></p>
<h3 id="调用和复用其它模板-t-call"><a href="#调用和复用其它模板-t-call" class="headerlink" title="调用和复用其它模板 - t-call"></a>调用和复用其它模板 - t-call</h3><p>QWeb模板可作为可复用的 HTML 片段插入到其它模板中。我们无需重复相同的 HTML 代码块，可以设计构成部分来组成更为复杂的用户界面视图，可复用的模板在<code>&lt;templates&gt;</code>标签中定义，通过顶级元素中 kanban-box 以外的 t-name值进行标识。这些模板可通过t-call来进行包含，在当前看板视图、相同模块的其它地方以及其它插件模块中均可。</p>
<p>follower头像列表可以通过可复用代码段来进行分离，下面通过子模板重写代码。首先应在 XML 文件中添加另一个模板，在<code>&lt;templates&gt;</code>元素内，<code>&lt;t t-name=&quot;kanban-box&quot;&gt;</code>节点之后，添加如下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;t t-name=&quot;follower_avatars&quot;&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;t t-foreach=&quot;record.message_partner_ids.raw_value.slice(0,3)&quot;</span><br><span class="line">            t-as=&quot;rec&quot;&gt;</span><br><span class="line">            &lt;img t-att-src=&quot;kanban_image(&#x27;res.partner&#x27;, &#x27;image_small&#x27;, rec)&quot;</span><br><span class="line">                class=&quot;oe_avatar&quot; width=&quot;24&quot; height=&quot;24&quot; alt=&quot;&quot; /&gt;</span><br><span class="line">        &lt;/t&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/t&gt;</span><br></pre></td></tr></table></figure>

<p>在kanban-box主模板调用它就简单明了了，将原来包含 for each 指令的<div>元素修改为如下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;t t-call=&quot;follower_avatars&quot; /&gt;</span><br></pre></td></tr></table></figure>

<p>调用其它插件模块中定义的模板，和视图类似，我们需要使用完整的module.name标识符。比如，以上代码片断可使用library_checkout.follower_avatars完整标识符来进行引用 。调用的模板和调用者运行在同一上下文中，所以调用方中的变量名在处理调用模板时同样可用。</p>
<p>一种更优雅的实现方式是向调用模板传递参数，这通过在 t-call 标签中设置变量来完成。这些仅在子模板上下文中运行和使用，在调用方上下文中并不存在。我们将使用这个方法来让调用方设置follower 头像的最大数，而不是在子模板中硬编码。首先，我们将原固定值3修改为一个变量 arg_max：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;t t-name=&quot;follower_avatars&quot;&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;t t-foreach=&quot;record.message_partner_ids.raw_value.slice(0, arg_max)&quot;</span><br><span class="line">            t-as=&quot;rec&quot;&gt;</span><br><span class="line">            &lt;img t-att-src=&quot;kanban_image(&#x27;res.partner&#x27;, &#x27;image_small&#x27;, rec)&quot;</span><br><span class="line">                class=&quot;oe_avatar&quot; width=&quot;24&quot; height=&quot;24&quot; alt=&quot;&quot; /&gt;</span><br><span class="line">        &lt;/t&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/t&gt;</span><br></pre></td></tr></table></figure>

<p>然后像下面这样在执行子模板调用时定义该变量：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;t t-call=&quot;follower_avatars&quot;&gt;</span><br><span class="line">    &lt;t t-set=&quot;arg_max&quot; t-value=&quot;3&quot; /&gt;</span><br><span class="line">&lt;/t&gt;</span><br></pre></td></tr></table></figure>

<p>t-call元素内的整个内容可通过0（数字零）这个魔法变量在子模板中使用。不使用参数变量，我们还可以定义代码片断并在子模板中通过<code>&lt;t t-raw=&quot;0&quot; /&gt;</code>使用。这对以模块化的方式创建布局、合并&#x2F;嵌套 QWeb 模板尤为有用。</p>
<h3 id="字典和列表动态属性"><a href="#字典和列表动态属性" class="headerlink" title="字典和列表动态属性"></a>字典和列表动态属性</h3><p>我们已经学习最重要的那些QWeb指令，但还有一部分我们也应该了解。下面简短地进行讲解。</p>
<p>前面我们看到t-att-NAME和t-attf-NAME样式的动态标签属性，此外还可以使用固定的t-att指令。它接收键值对字典或pair（两个元素的列表）。</p>
<p>使用如下映射：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;p t-att=&quot;&#123;&#x27;class&#x27;: &#x27;oe_bold&#x27;, &#x27;name&#x27;: &#x27;Hello&#x27;&#125;&quot; /&gt;</span><br></pre></td></tr></table></figure>

<p>将生成如下结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;p class=&quot;oe_bold&quot; name=&quot;Hello&quot; /&gt;</span><br></pre></td></tr></table></figure>

<p>使用如下 pair：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;p t-att=&quot;[&#x27;class&#x27;, &#x27;oe_bold&#x27;]&quot; /&gt;</span><br></pre></td></tr></table></figure>

<p>将生成如下结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;p class=&quot;oe_bold&quot; /&gt;</span><br></pre></td></tr></table></figure>

<h2 id="看板视图的继承"><a href="#看板视图的继承" class="headerlink" title="看板视图的继承"></a>看板视图的继承</h2><p>看板视图和报表中使用的模板可通过视图相同的常规方法来进行继承，例如，使用XPath表达式，参见第四章 <a target="_blank" rel="noopener" href="https://alanhou.org/odoo12-extending-modules/">Odoo 12 开发之模块继承</a>。</p>
<p>常见的情况是使用<code>&lt;field&gt;</code>元素作为选择器，然后在其前或后添加其它元素。对于看板视图，同一字段可声明多次，例如在模板前和模板内分别声明。这时，选择器将匹配第一个字段元素，不会将修改我们希望修改的模板内的字段。要规避这一问题，我们需使用XPath来确保匹配的是模板内的字段，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;record id=&quot;res_partner_kanban_inherit&quot; model=&quot;ir.ui.view&quot;&gt;</span><br><span class="line">	&lt;field name=&quot;name&quot;&gt;Contact Kanban modification&lt;/field&gt;</span><br><span class="line">	&lt;field name=&quot;model&quot;&gt;res.partner&lt;/field&gt;</span><br><span class="line">	&lt;field name=&quot;inherit_id&quot; ref=&quot;base.res_partner_kanban_view&quot; /&gt;</span><br><span class="line">	&lt;field name=&quot;arch&quot; type=&quot;xml&quot;&gt;</span><br><span class="line">		&lt;xpath expr=&quot;//t[@t-name=&#x27;kanban-box&#x27;]//field[@name=&#x27;display_name&#x27;]&quot;</span><br><span class="line">			position=&quot;before&quot;&gt;</span><br><span class="line">			&lt;span&gt;Name:&lt;/span&gt;</span><br><span class="line">		&lt;/xpath&gt;</span><br><span class="line">	&lt;/field&gt;</span><br><span class="line">&lt;/record&gt;</span><br></pre></td></tr></table></figure>

<p>在上例中，XPath 查找<code>&lt;t t-name=&quot;kanban-box&quot;&gt;</code>元素内的<code>&lt;field name=&quot;display_name&quot;&gt;</code>元素。这条规则会排除掉<code>&lt;templates&gt;</code>版块之外的相同字段元素。对于更 复杂的XPath表达式，我们可以使用命令行工具来研究出正确的语法。你的 Linux 系统中可能已有安装了xmllint工具（sudo apt install libxml2-utils），它有一个–xpath 选项可对 XML 文件执行查询。</p>
<p>另一个输出更好看的选项是Debian&#x2F;Ubuntu包中的libxml-xpath-perl，带有一个xpath 命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get install libxml-xpath-perl</span><br><span class="line">$ xpath -e &quot;//record[@id=&#x27;res_partner_kanban_view&#x27;]&quot; -e &quot;//field[@name=&#x27;display_name&#x27;]]&quot; /path/to/myfile.xml</span><br></pre></td></tr></table></figure>

<h2 id="自定义-CSS-和-JavaScript"><a href="#自定义-CSS-和-JavaScript" class="headerlink" title="自定义 CSS 和 JavaScript"></a>自定义 CSS 和 JavaScript</h2><p>如前所见，看板视图大多数为 HTML 并重度使用了 CSS 类。我们介绍了标准产品中提供的一些常用 CSS 类，但要实现最佳效果，我们还可以为模块添加自己的 CSS。我们这里不会详细讲解 CSS 代码的写法，但相应地需要讲解如何为模块添加自己的 CSS (JavaScript)这些前端资源。Odoo 中后台的前端资源在assets_backend模块中声明。要在模块中添加前端资源，需要对模块进行继承。进行这一操作的 XML 文件通常放在views&#x2F; 模块子目录内。</p>
<p>以下是在library_checkout模块中添加一个 CSS 和 JavaScript文件的示例，对应文件为library_checkout&#x2F;views&#x2F;checkout_kanban_assets.xml：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;odoo&gt;</span><br><span class="line">    &lt;template id=&quot;assets_backend&quot; inherit_id=&quot;web.assets_backend&quot;</span><br><span class="line">        name=&quot;Library Checkout Kanban Assets&quot;&gt;</span><br><span class="line">        &lt;xpath expr=&quot;.&quot; position=&quot;inside&quot;&gt;</span><br><span class="line">            &lt;link rel=&quot;stylesheet&quot;</span><br><span class="line">                href=&quot;/library_checkout/static/src/css/checkout_kanban.css&quot; /&gt;</span><br><span class="line">            &lt;script type=&quot;text/javascript&quot;</span><br><span class="line">                src=&quot;/library_checkout/static/src/js/checkout_kanban.js&quot;&gt;</span><br><span class="line">            &lt;/script&gt;</span><br><span class="line">        &lt;/xpath&gt;</span><br><span class="line">    &lt;/template&gt;</span><br><span class="line">&lt;/odoo&gt;</span><br></pre></td></tr></table></figure>

<p>和平常一样，需要在__manifest__.py描述文件中对其进引用，注意这些前端文件放在&#x2F;static&#x2F;src 子目录中，这不是强制要求，但是约定俗成如此。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我们学习了看板和如何创建看板视图来实现这些看板。我们还介绍了QWeb模板以及使用它来设计看板卡片。QWeb同时还是 CMS 网站的渲染引擎，因此它在 Odoo 工具集中的重要性越来越高。</p>
<p>看板视图可通过其它视图中使用的相同XML语法来进行继承。看板的 XML 结构可能会更为复杂，我们经常需要使用XPath表达式来定义需继承的元素。</p>
<p>最后，高级看板视图可以使用独有的 CSS 和 JavaScript 文件。可作为模块文件来进行添加，然后应在web.assets_backend QWeb模板中添加这些文件，以在客户端页面中包含。</p>
<p>在下一篇文章中，我们将继续使用QWeb，但是是在服务端创建自定义报表 。</p>
<p> </p>
<p>☞☞☞第十二章 <a target="_blank" rel="noopener" href="https://alanhou.org/odoo12-reports-qweb/">Odoo 12开发之报表和服务端 QWeb</a></p>
<p> </p>
<h2 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h2><p>以下参考材料是对本文所学习课题的补充：</p>
<ul>
<li>Odoo<a target="_blank" rel="noopener" href="https://www.odoo.com/documentation/12.0/reference/qweb.html">官方文档</a>QWeb的介绍</li>
<li>Bootstrap<a target="_blank" rel="noopener" href="https://getbootstrap.com/docs/4.1/getting-started/introduction/">样式文档</a></li>
<li>Font Awesome<a target="_blank" rel="noopener" href="https://fontawesome.com/v4.7.0/icons/">图标索引</a></li>
</ul>
<p>本文首发地址：<a target="_blank" rel="noopener" href="https://alanhou.org/developer-mode-odoo12/">Alan Hou 的个人博客</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://alanhou.github.io/2019/01/19/odoo-essentials-12-chapter11/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Alan Hou">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Alan Hou的个人博客">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Alan Hou的个人博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2019/01/19/odoo-essentials-12-chapter11/" class="post-title-link" itemprop="url">第十一章 Odoo 12开发之看板视图和用户端 QWeb</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2019-01-19 00:00:00" itemprop="dateCreated datePublished" datetime="2019-01-19T00:00:00+08:00">2019-01-19</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2023-02-03 14:19:39" itemprop="dateModified" datetime="2023-02-03T14:19:39+08:00">2023-02-03</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>本文为<a target="_blank" rel="noopener" href="https://alanhou.org/odoo-12-development/">最好用的免费ERP系统Odoo 12开发手册</a>系列文章第十一篇。</p>
<p>QWeb 是 Odoo 使用的模板引擎，它基于 XML 来生成 HTML 片断和页面。通过 QWeb可生成内容丰富的看板(Kankan)视图、报表和 CMS 网页。本文中我们将学习QWeb 语法以及如何使用 QWeb 来创建我们自己的看板视图和自定义报表。</p>
<p>本文主要内容有：</p>
<ul>
<li>看板是什么？</li>
<li>设计看板视图</li>
<li>QWeb 模板语言</li>
<li>看板视图的继承</li>
<li>添加自定义 CSS 和 JavaScript</li>
</ul>
<h2 id="开发准备"><a href="#开发准备" class="headerlink" title="开发准备"></a>开发准备</h2><p>我们将继续使用第十章 <a target="_blank" rel="noopener" href="https://alanhou.org/odoo12-backend-views/">Odoo 12开发之后台视图 - 设计用户界面</a>完成的library_checkout插件模块。相应代码请见 <a target="_blank" rel="noopener" href="https://github.com/alanhou/odoo12-development/tree/master/chapter10">GitHub仓库</a>。本章完成后的代码也请参见<a target="_blank" rel="noopener" href="https://github.com/alanhou/odoo12-development/tree/master/chapter11">GitHub仓库</a>。</p>
<h2 id="了解看板"><a href="#了解看板" class="headerlink" title="了解看板"></a>了解看板</h2><p>Kanban 是一个日语词汇，字面意思榜单，与精益制造和准时化生产相关联，由丰田工业工程师大野耐一(Taiichi Ohno)引入。最近看板的概念应用于更多领域，并且随着敏捷方法的施行在软件工业内流行起来。</p>
<p>看板让我们能够可视化工作队列，它以列来进行组织，每列代表工作进程的一个阶段。工作项以放在看板对应列的卡片来表示。新的工作项从最左边的列开始，并开始向右移动直至最右边列，代表工作完成。</p>
<p>看板的简单化或视觉效果让其对简单的业务流程有着优异的支持。一个基本的看板示例包含三列，如下图所示：待办、在办和完成。当然它可以扩展为你需要的其它指定流程：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c5f76dc3b9984ba08e1738ce9bdfa848~tplv-k3u1fbpfcp-zoom-1.image" alt="看板示例"></p>
<p>对许多业务用例，看板都是管理相应流程的更有效方式，与 Odoo 11之前的更重的工作流引擎形成鲜明对比。Odoo 在支持经典的列表和表单视图的同时还支持看板视图，这易于我们实施这种类型的视图。下面就让我们一起来学习如何使用看板视图。</p>
<h3 id="看板视图"><a href="#看板视图" class="headerlink" title="看板视图"></a>看板视图</h3><p>现在我们要为借阅模型添加一个看板视图。每个借阅是一个卡片，看板将会被组织成阶段列。在前面的文章中，我们已经添加了stage_id阶段字段。</p>
<p>此前在表单视图我们大部分时候使用 Odoo 独有的 XML 元素，比如<code>&lt;field&gt;</code>和<code>&lt;group&gt;</code>，有时也会使用 HTML 元素，如<code>&lt;h1&gt;</code>或<code>&lt;div&gt;</code>，但用得较少。在看板视图中则恰恰相反，展示模板基于 HTML，仅支持两个 Odoo 独有的元素：<code>&lt;field&gt;</code>和<code>&lt;button&gt;</code>。</p>
<p>最终呈现在网页客户端中的内容是由 QWeb 模板动态生成的。QWeb 引擎处理特殊的 XML 标签和属性来进行生成。这样可以很好地控制如何渲染内容，但也让视图设计更为复杂。看板视图设计灵活性很强，我们将尽力以直接易懂地方式介绍快速创建看板视图的知识。查看与所需相似的看板视图来获取创意然后创建自己的看板是一种不错的方法。</p>
<p>我们将学习两种使用看板视图的方式。一种是卡片列表，它用于联系人、产品、雇员通讯录或应用等。联系人看板视图长这样：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f8c1e58e31084937a9081ce43334a3f7~tplv-k3u1fbpfcp-zoom-1.image" alt="Odoo 12联系人看板视图"></p>
<p>但这不是真正的看板，看板应是一个组织成不同列的卡片，当然看板视图也支持这种布局。可能过 CRM 或项目应用来查看示例。访问CRM &gt; Sales &gt; My Pipeline可得到如下结果：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/06649a94199b4b1a8203711086869147~tplv-k3u1fbpfcp-zoom-1.image" alt="Odoo 12 CRM看板视图"></p>
<p>这两种布局的最大区别是卡片按列的组织方式。这通过 Group By 功能实现，与列表视图中相似。通常分组是通过stage字段实现。看板视图的一个非常有用的功能是可以在列之间拖放卡片，自动分配分组视图字段的对应值。从两个示例中的卡片我们可以看到一些分别。其实它们的设计非常灵活，设计看板卡片不只有一种方式。这两个示例为我们提供设计的一些基础。</p>
<p>联系人卡片基本组成有左侧的图像，主区域的加粗标题和紧随其后的一系列值。CRM 管道卡片结构更为复杂些。卡片主区域也有一个标题以及相关信息紧随其后，还有 footer 区。在该区域中，可看到左侧有一个优先级组件，后面带有一个活动指示，在右侧是一个负责用户的头像。上图中看不到，在鼠标悬停在右上角时还会有一个选项菜单。这个菜单让我们可以修改卡片的颜色提示等。</p>
<p>我们将使用这种更复杂的结构来作为借阅看板卡片的参照。</p>
<h2 id="设计看板视图"><a href="#设计看板视图" class="headerlink" title="设计看板视图"></a>设计看板视图</h2><p>我们将改进一直以来开发的library_checkout模型，为图书借阅添加看板视图。为此我们使用一个新文件library_checkout&#x2F;views&#x2F;checkout_kanban_view.xml。需要在__manifest__.py文件的 data 键最下方添加这个文件。在library_checkout&#x2F;views&#x2F;library_menu.xml文件中，可以看到借阅菜单项使用的窗口操作。需要对其修改来启用本文中添加的视图类型：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;act_window id=&quot;action_library_checkout&quot;</span><br><span class="line">    name=&quot;Checkouts&quot;</span><br><span class="line">    res_model=&quot;library.checkout&quot;</span><br><span class="line">    view_mode=&quot;kanban,tree,form,activity,calendar,graph,pivot&quot; /&gt;</span><br></pre></td></tr></table></figure>

<p>这里我们修改了菜单操作来在view_mode列表的最前面添加了kanban，来让它成为默认的视图模式。然后我们来添加kanban视图记录。与其它视图基本相同，除了 arch 字段内，最外层 XML元素为<kanban>。下一步创建实际使用的 XML 文件library_checkout&#x2F;views&#x2F;checkout_kanban_view.xml来放置这个惊艳的看板视图：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot;?&gt;</span><br><span class="line">&lt;odoo&gt;</span><br><span class="line">    &lt;record id=&quot;library_checkout_kanban&quot; model=&quot;ir.ui.view&quot;&gt;</span><br><span class="line">        &lt;field name=&quot;model&quot;&gt;library.checkout&lt;/field&gt;</span><br><span class="line">        &lt;field name=&quot;arch&quot; type=&quot;xml&quot;&gt;</span><br><span class="line">            &lt;kanban&gt;</span><br><span class="line"></span><br><span class="line">            &lt;/kanban&gt;</span><br><span class="line">        &lt;/field&gt;</span><br><span class="line">    &lt;/record&gt;</span><br><span class="line">&lt;/odoo&gt;</span><br></pre></td></tr></table></figure>

<p>在使用看板视图前，我们需要为图书借阅模型添加几个字段。</p>
<h3 id="优先级、看板状态和颜色"><a href="#优先级、看板状态和颜色" class="headerlink" title="优先级、看板状态和颜色"></a>优先级、看板状态和颜色</h3><p>除阶段外，看板中还有一些常用和有用的字段：</p>
<ul>
<li>priority让用户组织他们的工作项，标记什么应优先处理</li>
<li>kanban_state标记是否应移向下一阶段或因某种原因原地不动。在模型定义层中两者都是选择项字段。在视图层，对它们有特别的组件用于表单和看板视图。</li>
<li>color用于存储看板卡片显示的颜色，并可通过看板视图中的颜色拾取器菜单设置</li>
</ul>
<p>编辑library_checkout&#x2F;models&#x2F;library_checkout.py文件来在我们的模型中添加这些字段：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Checkout(models.Model):</span><br><span class="line">...</span><br><span class="line">    priority = fields.Selection(</span><br><span class="line">        [(&#x27;0&#x27;, &#x27;Low&#x27;),</span><br><span class="line">        (&#x27;1&#x27;, &#x27;Normal&#x27;),</span><br><span class="line">        (&#x27;2&#x27;, &#x27;High&#x27;)],</span><br><span class="line">        &#x27;Priority&#x27;,</span><br><span class="line">        default=&#x27;1&#x27;)</span><br><span class="line">    kanban_state = fields.Selection(</span><br><span class="line">        [(&#x27;normal&#x27;, &#x27;In Progress&#x27;),</span><br><span class="line">        (&#x27;blocked&#x27;, &#x27;Blocked&#x27;),</span><br><span class="line">        (&#x27;done&#x27;, &#x27;Ready for next stage&#x27;)],</span><br><span class="line">        &#x27;Kanban State&#x27;,</span><br><span class="line">        default=&#x27;normal&#x27;)</span><br></pre></td></tr></table></figure>

<p>我们还应该在表单视图中添加这些字段，使用各自的特别组件。kanban_state字段就加在<code>&lt;div class=&quot;oe_title&quot;&gt;</code>之前并在按钮框之后：<code>&lt;field name=&quot;kanban_state&quot; widget=&quot;state_selection&quot; /&gt;</code>。priority应添加在name 字段之前，包裹在<code>&lt;h1&gt;</code>元素中：<code>&lt;field name=&quot;priority&quot; widget=&quot;priority&quot; /&gt;</code>。color字段一般不出现在表单视图中。</p>
<p>既然借阅模型已有我们所需使用的所有字段，我们可以来写看板视图了。</p>
<h3 id="看板卡片元素"><a href="#看板卡片元素" class="headerlink" title="看板卡片元素"></a>看板卡片元素</h3><p>看板视图框架包含一个<code>&lt;kanban&gt;</code>外层元素和以下基础结构：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;kanban default_group_by=&quot;stage_id&quot; class=&quot;o_kanban_small_column&quot;&gt;</span><br><span class="line">                &lt;!-- Fields --&gt;</span><br><span class="line">                &lt;field name=&quot;stage_id&quot; /&gt;</span><br><span class="line">                &lt;field name=&quot;id&quot; /&gt;</span><br><span class="line">                &lt;field name=&quot;color&quot; /&gt;</span><br><span class="line">                &lt;field name=&quot;kanban_state&quot; /&gt;</span><br><span class="line">                &lt;field name=&quot;priority&quot; /&gt;</span><br><span class="line">                &lt;field name=&quot;message_partner_ids&quot; /&gt;</span><br><span class="line"></span><br><span class="line">                &lt;!-- Optional progress bar --&gt;</span><br><span class="line">                &lt;progressbar</span><br><span class="line">                    field=&quot;kanban_state&quot;</span><br><span class="line">                    colors=&#x27;&#123;&quot;done&quot;: &quot;success&quot;, &quot;blocked&quot;: &quot;danger&quot;&#125;&#x27; /&gt;</span><br><span class="line">                &lt;!-- Templates with HTML snippets to use --&gt;</span><br><span class="line">                &lt;templates&gt;</span><br><span class="line">                    &lt;t t-name=&quot;kanban-box&quot;&gt;</span><br><span class="line">                        &lt;!-- HTML Qweb template --&gt;</span><br><span class="line">                    &lt;/t&gt;</span><br><span class="line">                &lt;/template&gt;</span><br><span class="line">            &lt;/kanban&gt;</span><br></pre></td></tr></table></figure>

<p>注意在元素中使用了default_group_by&#x3D;”stage_id”属性，我们用它来让看板默认以 stage 分组，这也是看板通常的分组方式。在简单卡片列表的看板中，如联系人，我们不需要添加该属性，只需使用<code>&lt;kanban&gt;</code>标签即可。<code>&lt;kanban&gt;</code>元素支持以下属性：</p>
<ul>
<li>default_group_by设置默认列分组使用的字段</li>
<li>default_order设置看板项默认使用的排序</li>
<li> quick_create&#x3D;”false”禁用了每列顶部的快速创建选项（大的加号符号），快速创建只需提供标题描述即可创建新项。false是 JavaScript 的语法，必须是小写字母。</li>
<li>class为渲染看板视图的根元素添加 CSS 类。相关类是_kanban_small_column，让列比默认的更加紧湊。其它类可由我们模块的 CSS 文件来进行提供。</li>
<li> group_create, group_edit, group_delete和quick_create_view可设置为 false 来禁用看板列上对应的操作。如group_create&#x3D;”false”删除右侧添加新列的按钮。</li>
<li>on_create用于创建用户点击左上角 Create 按钮时弹出的自定义简单表单视图窗口。应为相应的表单视图添加<code>&lt;module&gt;.&lt;xml_id&gt;</code>值。</li>
</ul>
<p>然后我们的模板中使用了一组字段。确切地说，只有在 QWeb 表达式中明确使用的字段才需要在这里声明，用以保证从服务端抓取它们的数据。QWeb引擎在处理模板前，仅会在视图中查找 <code>&lt;field name=&quot;...&quot;&gt;</code>来从模型中获取数据。QWeb的属性通常使用不会被检测到的record.field引用方式。正因为如此，需在<code>&lt;templates&gt;</code>之前包含这些字段来让模板处理时有相应字段值可以使用。</p>
<blockquote>
<p>ℹ️<strong>Odoo 11中的修改</strong><br>引入了进度条组件。使用的时候在看板列的上方会出现一个颜色条，来提供该列各项的状态数据。在本文前面CRM Pipeline的示例图中可以查看。</p>
</blockquote>
<p><code>&lt;progressbar&gt;</code>有如下属性：</p>
<ul>
<li>field是对列中各项进行颜色分组的字段名</li>
<li>colors是一个字典，将分组字段值与以下三种颜色分别进行映射：danger (红色), warning (黄色)或success (绿色)。</li>
<li>sum_field是一个可选项，用于选取整列汇总的字段名。如未设置，会使用各项的计数值。</li>
</ul>
<p>然后我们的<code>&lt;templates&gt;</code>元素包含一个或多个QWeb模板来生成要使用的 HTML 片断。必须要有一个名为kanban-box的模板，它渲染看板卡片。还可以添加其它模板，通常用于定义主模板中复用到的 HTML 片断。这些模板使用标准的 HTML 和 QWeb 模板语言。QWeb提供了一些特殊指令，用于处理动态生成最终展示的 HTML。</p>
<blockquote>
<p>ℹ️<strong>Odoo 12中的修改</strong><br>Odoo 现在使用 Twitter Bootstrap 4，此前版本中使用Bootstrap 3。这些样式在渲染 HTML 的地方通常都可使用，有关Bootstrap更多知识请见<a target="_blank" rel="noopener" href="https://getbootstrap.com/">官方网站</a>。</p>
</blockquote>
<p>下面就来详细了解看板视图中所使用的QWeb模板设计。</p>
<h3 id="看板卡片布局"><a href="#看板卡片布局" class="headerlink" title="看板卡片布局"></a>看板卡片布局</h3><p>看板卡片主内容区域在kanban-box模板内定义。这个内容区也可以有一个 footer 底部子容器。卡片右上角还可以添加按钮，点击后打开操作菜单的功能。对于footer区域，应在看板盒子模型底部使用<div>并添加oe_kanban_bottom CSS 类。还可以通过oe_kanban_bottom_left和oe_kanban_bottom_right CSS 类进一步分割为左、右 footer 区。此外，可通过Bootstrap的pull-left和pull-right类在卡片的任意位置（包括oe_kanban_bottom底部区域）添加向左或向右对齐元素。</p>
<p>以下是对看板卡片中QWeb模板的第一次迭代：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;t t-name=&quot;kanban-box&quot;&gt;</span><br><span class="line">    &lt;!-- Set the Kanban Card color --&gt;</span><br><span class="line">    &lt;div t-attf-class=&quot;</span><br><span class="line">        oe_kanban_color_#&#123;kanban_getcolor(record.color.raw_value)&#125;</span><br><span class="line">        oe_kanban_global_click&quot;&gt;</span><br><span class="line">        &lt;div class=&quot;o_dropdown_kanban dropdown&quot;&gt;</span><br><span class="line">            &lt;!-- Top-right drop down menu here... --&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">        &lt;div class=&quot;oe_kanban_body&quot;&gt;</span><br><span class="line">            &lt;!-- Content elements and fields go here... --&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">        &lt;div class=&quot;oe_kanban_footer&quot;&gt;</span><br><span class="line">            &lt;div class=&quot;oe_kanban_footer_left&quot;&gt;</span><br><span class="line">                &lt;!-- Left hand footer... --&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">            &lt;div class=&quot;oe_kanban_footer_right&quot;&gt;</span><br><span class="line">                &lt;!-- Right hand footer... --&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">        &lt;div class=&quot;oe_clear&quot; /&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/t&gt;</span><br></pre></td></tr></table></figure>

<p>这就是看板卡片的整体结构。你可能注意到了在顶部<code>&lt;div&gt;</code>元素中使用了color字段来动态设置卡片颜色。在后面的部分中我们会讲解t-attf QWeb指令的细节。现在来为主内容区域添加内容：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;oe_kanban_body&quot;&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;strong&gt;</span><br><span class="line">            &lt;a type=&quot;open&quot;&gt;&lt;field name=&quot;member_id&quot; /&gt;&lt;/a&gt;</span><br><span class="line">        &lt;/strong&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;ul&gt;</span><br><span class="line">        &lt;li&gt;&lt;field name=&quot;user_id&quot; /&gt;&lt;/li&gt;</span><br><span class="line">        &lt;li&gt;&lt;field name=&quot;request_date&quot; /&gt;&lt;/li&gt;</span><br><span class="line">    &lt;/ul&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<p>这个模板中大部分都是常规 HTML，但也有渲染字段值的<code>&lt;field&gt;</code>元素和在常规表单视图按钮中使用的 type 属性，此处用在锚文本标签中。</p>
<p>在左部 footer 中插入优先级组件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">                            &lt;div class=&quot;o_kanban_record_bottom&quot;&gt;</span><br><span class="line">                                &lt;div class=&quot;oe_kanban_bottom_left&quot;&gt;</span><br><span class="line">                                    &lt;field name=&quot;priority&quot; widget=&quot;priority&quot; /&gt;</span><br><span class="line">                                    &lt;field name=&quot;activity_ids&quot; widget=&quot;kanban_activity&quot; /&gt;</span><br><span class="line">                                &lt;/div&gt;</span><br><span class="line">...</span><br><span class="line">                            &lt;/div&gt;</span><br></pre></td></tr></table></figure>

<p>这里像我们在表单视图中做的那样添加了priority字段。还添加了一个计划活动的字段，使用kanban_activity特殊组件来显示即将开始活动的指示。</p>
<p>在右部footer中，放入看板状态组件和请求借阅的会员头像：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;oe_kanban_bottom_right&quot;&gt;</span><br><span class="line">    &lt;field name=&quot;kanban_state&quot;</span><br><span class="line">        widget=&quot;kanban_state_selection&quot; /&gt;</span><br><span class="line">    &lt;img t-att-src=&quot;kanban_image(</span><br><span class="line">            &#x27;library.checkout&#x27;,</span><br><span class="line">            &#x27;member_image&#x27;,</span><br><span class="line">            record.id.raw_value)&quot;</span><br><span class="line">        t-att-title=&quot;record.member_id.value&quot;</span><br><span class="line">        t-att-alt=&quot;record.member_id.value&quot;</span><br><span class="line">        width=&quot;24&quot;</span><br><span class="line">        height=&quot;24&quot;</span><br><span class="line">        class=&quot;oe_kanban_avatar&quot;</span><br><span class="line">    /&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<p>补充：原文件使用的 CSS 类oe_kanban_footer，oe_kanban_footer_left和oe_kanban_footer_right经测试不会进行左右对齐，参照 CRM 进行了如上修改</p>
<p>看板状态通过<code>&lt;field&gt;</code>元素和kanban_state_selection组件来进行添加。用户头像使用 HTML <code>&lt;img&gt;</code>标签插入。图像内容使用QWeb t-att-命令动态生成，后面会详细讲解。这里使用了kanban_image()帮助函数来获取src属性的值。kanban_image() Javascript函数从 Odoo 模型中获取表单并在网页中渲染。有以下属性：</p>
<ul>
<li>获取图像的模型</li>
<li>包含图像的字段</li>
<li>获取的记录 ID</li>
</ul>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b3ad0d808c6d4afd9fc5eea7d201eaa9~tplv-k3u1fbpfcp-zoom-1.image" alt="Odoo 12看板 footer 添加"></p>
<h3 id="为看板卡片添加选项菜单"><a href="#为看板卡片添加选项菜单" class="headerlink" title="为看板卡片添加选项菜单"></a>为看板卡片添加选项菜单</h3><p>看板卡片可在右上角带有一个选项菜单。通常的操作有编辑或删除记录，但也可以为其添加和按钮调用的同样操作。还有一个设置卡片颜色的组件。以下是oe_kanban_content顶部添加的选项菜单的基础代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;o_dropdown_kanban dropdown&quot;&gt;</span><br><span class="line">    &lt;a class=&quot;dropdown-toggle btn&quot;</span><br><span class="line">        data-toggle=&quot;dropdown&quot; role=&quot;button&quot;</span><br><span class="line">        aria-label=&quot;Dropdown menu&quot;</span><br><span class="line">        title=&quot;Dropdown menu&quot;</span><br><span class="line">        href=&quot;#&quot;&gt;</span><br><span class="line">        &lt;span class=&quot;fa fa-ellipsis-v&quot; /&gt;</span><br><span class="line">    &lt;/a&gt;</span><br><span class="line">    &lt;div class=&quot;dropdown-menu&quot; role=&quot;menu&quot;&gt;</span><br><span class="line">        &lt;!-- Edit and Delete actions, if available: --&gt;</span><br><span class="line">        &lt;t t-if=&quot;widget.editable&quot;&gt;</span><br><span class="line">            &lt;a role=&quot;menuitem&quot; type=&quot;edit&quot; class=&quot;dropdown-item&quot;&gt;Edit&lt;/a&gt;</span><br><span class="line">        &lt;/t&gt;</span><br><span class="line">        &lt;t t-if=&quot;widget.deletable&quot;&gt;</span><br><span class="line">            &lt;a role=&quot;menuitem&quot; type=&quot;delete&quot; class=&quot;dropdown-item&quot;&gt;Delete&lt;/a&gt;</span><br><span class="line">        &lt;/t&gt;</span><br><span class="line">        &lt;!-- Color picker option --&gt;</span><br><span class="line">        &lt;ul class=&quot;oe_kanban_colorpicker&quot; data-field=&quot;color&quot; /&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<p>下拉菜单基本上是由带有<code>&lt;a&gt;</code>标签的<code>&lt;li&gt;</code> HTML 列表元素组成。Edit 和 Delete 这类选项需要满足指定条件下才会出现。这通过<a href="">QWeb的</a><a href="">t-if命令来实现。本文后续会详细讲解</a><a href="">QWeb的命令。widget全局变量表示一个KanbanRecord()  JS 对象，负责渲染当前看板卡片。有两个非常有用的属性：widget.editable和widget.deletable，让我们可以检查相应的操作是否可用。</a></p>
<p>可以看到如何根据记录字段值来显示或隐藏选项，Set as Done仅在未设置is_done 字段时才会显示。最后一个选项添加颜色拾取器组件来使用 color 数据字段选择或修改卡片背景色。因此，除<button>元素外，<code>&lt;a&gt;</code>也可用于运行Odoo 操作。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a970e9acfd144d05bdc69c10e05e285c~tplv-k3u1fbpfcp-zoom-1.image" alt="Odoo 12看板视图下拉选项"></p>
<h3 id="看板视图中的操作"><a href="#看板视图中的操作" class="headerlink" title="看板视图中的操作"></a>看板视图中的操作</h3><p>在QWeb模板中，用于超链的<code>&lt;a&gt;</code>标签可带有一个 type 属性。它设置链接执行的操作类型，这样链接和常规表单中的按钮可进行同样的操作。和表单视图一样，操作类型可以是action或object，并应带有一个 name 属性来标识所要执行的具体操作。此外，还有以下操作类型可以使用：</p>
<ul>
<li>open打开相应的表单视图</li>
<li>edit在编辑模式下直接打开相应的表单视图</li>
<li>delete删除记录并从看板视图中删除该项</li>
</ul>
<h2 id="QWeb-模板语言"><a href="#QWeb-模板语言" class="headerlink" title="QWeb 模板语言"></a>QWeb 模板语言</h2><p>QWeb会查找模板中的特殊指令并替换为动态生成的 HTML。这些指令是 XML 元素属性，可以用在<code>&lt;div&gt;</code>, <code>&lt;span&gt;</code>或<code>&lt;field&gt;</code>等有效标签或元素中。有时我们要使用QWeb指令但不希望放在模板的 XML 元素中。对这种情况，可以使用能带有 QWeb 指令（如t-if或t-foreach）的特殊元素<code>&lt;t&gt;</code>，该元组不会在最终产生的XML&#x2F;HTML有任何输出。</p>
<p>QWeb指令常使用运算的表达式来根据当前记录值生成不同的结果。有两种不同的QWeb实现：客户端JavaScript和服务端Python。报表和网页使用服务端QWeb的 Python 实现。看板视图使用客户端JavaScript实现。也就是说看板视图中的QWeb表达式应使用JavaScript语法书写，而不是 Python。</p>
<p>在显示看板视图时，内部的步骤大致如下：</p>
<ol>
<li>获取模板的XML进行渲染</li>
<li>调用服务端read()方法来获取模板中所涉及的字段数据</li>
<li>定位kanban-boxs模板并使用QWeb解析它来输出最终的HTML片断</li>
<li>在浏览器显示(DOM)中注入 HTML</li>
</ol>
<p>以上在技术上并不精确，仅是用于理解看板视图中如何运作的脑图。下面我们将学习QWeb表达式运行并探讨可用的QWeb指令，通过示例改进借阅看板卡片。</p>
<h3 id="QWeb-JavaScript-运行上下文"><a href="#QWeb-JavaScript-运行上下文" class="headerlink" title="QWeb JavaScript 运行上下文"></a>QWeb JavaScript 运行上下文</h3><p>许多QWeb指令使用表达式的运行来生成结果。在看板视图这类客户端的应用中，表达式应使用JavaScript书写。表达式在带有几个有用变量的上下文中进行运行。可用record 对象带有从服务端请求的字段来表示当前记录。字段值可通过raw_value或value属性来获取：</p>
<ul>
<li>raw_value是由服务端read()方法返回的值，因此在条件表达式中更适用</li>
<li>value根据用户设置来格式化，用于在用户界面中的显示。常用于date&#x2F;datetime, float&#x2F;monetary和关联字段。</li>
</ul>
<p>QWeb运行上下文还可在JavaScript网页客户端中引用。要擅用这些需要对网页客户端结构有很好的理解，但这里我们不会进行深入介绍。要进行引用 ，QWeb表达式运行中有以下标识符可以使用：</p>
<ul>
<li>widget是对当前KanbanRecord() 组件对象的引用 ，用于在看板卡片中渲染当前记录。它会暴露一些帮助函数供我们使用。</li>
<li>record是widget.record的简写形式，使用点号标记来提供对可用字段的访问。</li>
<li>read_only_mode表示当前视图是否为读模式（而非编辑模式）。它是widget.view.options.read_only_mode的简写形式。</li>
<li>instance是对全部网页客户端实例的一个引用 。</li>
</ul>
<p>值得一提的是有些字符是不能在表达式中使用的，比如小于号(<code>&lt;</code>) 。这是因为在 XML 标准中，这些字符具有特殊含义，不应在 XML 内容中使用。反向的<code>&gt;=</code>是一个有效替代方式，但通常是使用以下替代符号来进行不等式运算：</p>
<ul>
<li>lt是小于</li>
<li>lte是小于等于</li>
<li>gt是大于</li>
<li>gte是大于等于</li>
</ul>
<blockquote>
<p>ℹ️前述的比较符号仅用于 Odoo，是引入来解决 XML 格式中的限制的。它们不是 XML 标准的一部分。</p>
</blockquote>
<h3 id="字符串替换动态属性–-t-attf"><a href="#字符串替换动态属性–-t-attf" class="headerlink" title="字符串替换动态属性– t-attf"></a>字符串替换动态属性– t-attf</h3><p>我们的看板卡片使用t-attf QWeb指令来为顶级<code>&lt;div&gt;</code>元素动态设置一个类，这样卡片可根据 color 字段值来显示颜色。为此使用了t-attf- QWeb指令。t-attf-指令使用字符串替换动态生成标签属性。这让像 URL 地址或 CSS 类名这类较大字符串中的部分内容可动态生成。</p>
<p>该指令查找表达式代码块进行运行并替换结果。它们通过 或#{和}来进行分隔。代码块的内容可以是任意JavaScript表达式并使用QWeb表达式中的任意可用变量，如record和widget。本例中我们还使用了专门提供的kanban_color() JS 函数，用于映射索引值到类颜色名。</p>
<p>作为一个更复杂的示例，我们使用这个指令来动态生成用户的颜色，红色字体表示优先级很高。下面替换看板卡片中的相应代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;li t-attf-class=&quot;oe_kanban_text_&#123;&#123;</span><br><span class="line">    record.priority.raw_value lt &#x27;2&#x27;</span><br><span class="line">    ? &#x27;black&#x27; : &#x27;red&#x27;&#125;&#125;&quot;&gt;</span><br><span class="line">    &lt;field name=&quot;user_id&quot; /&gt;</span><br><span class="line">&lt;/li&gt;</span><br></pre></td></tr></table></figure>

<p>这将会根据借阅优先级的值生成class&#x3D;”oe_kanban_text_red”或class&#x3D;”oe_kanban_text_black”。请注意看板视图中是有oe_kanban_text_red这个 CSS 类的，但oe_kanban_text_black仅用于演示，实际并不存在。</p>
<blockquote>
<p>ℹ️注意JavaScript表达式中使用的lt符号，是<code>&lt;</code>的转义表达式，并不能在XML中使用。</p>
</blockquote>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bbb868371a0c4abca20de08364d4a513~tplv-k3u1fbpfcp-zoom-1.image" alt="Odoo 12字符串替换动态属性"></p>
<h3 id="表达式动态属性-t-att"><a href="#表达式动态属性-t-att" class="headerlink" title="表达式动态属性 - t-att"></a>表达式动态属性 - t-att</h3><p>t-att- QWeb指令通过运行表达式动态生成属性值。我们的看板卡片中使用它来为<code>&lt;img&gt;</code>标签动态生成属性，title 属性使用以下表达式动态渲染：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">t-att-title=&quot;record.member_id.value&quot;</span><br></pre></td></tr></table></figure>

<p>.value字段返回在屏幕上显示的值。对于many-to-one字段，这通常是相关记录的 name 值。对于用户则是用户名。运行之后在鼠标悬停于图像上时会显示相应的用户名。</p>
<p>在表达式运行的结果值为假时，就不会渲染该属性。这对于特殊的 HTML 属性非常重要，比如 input 字段中的 checked，即便在没有属性值时也会有显示效果。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/84a431fa9e4849ff8c848cc377f2a8ca~tplv-k3u1fbpfcp-zoom-1.image" alt="Odoo 12表达式动态属性 "></p>
<h3 id="循环-t-foreach"><a href="#循环-t-foreach" class="headerlink" title="循环 - t-foreach"></a>循环 - t-foreach</h3><p>通过循环遍历来重复同一 HTML 代码块。我们可使用它来添加记录 follower 的头像。让我们先来仅渲染记录的partner ID：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;t t-foreach=&quot;record.message_partner_ids.raw_value&quot; t-as=&quot;rec&quot;&gt;</span><br><span class="line">    &lt;t t-esc=&quot;rec&quot; /&gt;;</span><br><span class="line">&lt;/t&gt;</span><br></pre></td></tr></table></figure>

<p>t-foreach指令接收一个JavaScript表达式，运行来遍历集合。在大多数情况下，这会是 一个to-many关联字段的名称。与t-as指令一同使用来设置用于引用遍历各项的名称。下面使用的t-esc指令运行所提供的表达式，本处仅为 rec 变量名，将其渲染为已转译的安全 HTML。</p>
<p>在上例中，我们遍历了存储在message_partner_ids 字段中的 follower。因为在看板卡片上的空间有限，我们使用JS 的slice()函数来限定所显示的follower数量，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">t-foreach=&quot;record.message_partner_ids.raw_value.slice(0, 3)&quot;</span><br></pre></td></tr></table></figure>

<p>rec变量存储每个遍历值，本例中为partner ID。这样我们可以将循环改写为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;t t-foreach=&quot;record.message_partner_ids.raw_value.slice(0,3)&quot; t-as=&quot;rec&quot;&gt;</span><br><span class="line">    &lt;img t-att-src=&quot;kanban_image(&#x27;res.partner&#x27;, &#x27;image_small&#x27;, rec)&quot;</span><br><span class="line">        class=&quot;oe_avatar&quot; width=&quot;24&quot; height=&quot;24&quot; alt=&quot;&quot; /&gt;</span><br><span class="line">&lt;/t&gt;</span><br></pre></td></tr></table></figure>

<p>比如可将其添加在右侧 footer 的用户头像旁。还包含一些帮助变量，它们的名称以t_as 中定义的变量名为前缀。本例中使用了rec，因此可用的帮助变量如下：</p>
<ul>
<li>rec_index是迭代索引，从0开始</li>
<li>rec_size是集合中的元素数量</li>
<li>rec_first在迭代的第一个元素中为真</li>
<li>rec_last在迭代的最后一个元素中为真</li>
<li>rec_even在索引为偶数时为真</li>
<li>rec_odd在索引为奇数时为真</li>
<li>rec_parity根据当前索引为odd或even</li>
<li>rec_all表示进行迭代的对象</li>
<li>rec_value在迭代{key:value} 字典时，存储value (rec存储键名)</li>
</ul>
<p>例如可通过如下代码去除ID 列表最后逗号：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;t t-foreach=&quot;record.message_parter_ids.raw_value.slice(0, 3)&quot;</span><br><span class="line">    t-as=&quot;rec&quot;&gt;</span><br><span class="line">    &lt;t t-esc=&quot;rec&quot; /&gt;</span><br><span class="line">    &lt;t t-if=&quot;!rec_last&quot;&gt;;&lt;/t&gt;</span><br><span class="line">&lt;/t&gt;</span><br></pre></td></tr></table></figure>

<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/62b207944c9240ef9580c2e0dd46ae33~tplv-k3u1fbpfcp-zoom-1.image" alt="Odoo 12 循环遍历"></p>
<h3 id="条件判断-t-if"><a href="#条件判断-t-if" class="headerlink" title="条件判断 - t-if"></a>条件判断 - t-if</h3><p>我们的看板视图在卡片选项菜单中使用了t-if指令来根据不同条件显示不同选项。t-if指令在客户端渲染看板视图时需传入在 JS 中运行的表达式。标签和其内容仅在条件运行值为true 时才会渲染。作为示例，仅在借出有值时显示图书借出数量，在request_date字段后加入如下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;t t-if=&quot;record.num_books.raw_value gt 0&quot;&gt;</span><br><span class="line">    &lt;li&gt;&lt;field name=&quot;num_books&quot; /&gt; books&lt;/li&gt;</span><br><span class="line">&lt;/t&gt;</span><br></pre></td></tr></table></figure>

<p>我们使用了<code>&lt;t t-if=&quot;...&quot;&gt;</code>元素，这样在条件为 false 时，元素不会有任何输出。在为 true 时，仅会渲染其所包含的<code>&lt;li&gt;</code>元素来进行输出。注意条件表达式中使用gt符号来替代<code>&gt;</code>以表示大于运算符。可通过t-elif和t-else来支持else if和else条件语句，使用示例如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;t t-if=&quot;record.num_books.raw_value == 0&quot;&gt;</span><br><span class="line">    &lt;li&gt;No books.&lt;/li&gt;</span><br><span class="line">&lt;/t&gt;</span><br><span class="line">&lt;t t-elif=&quot;record.num_books.raw_value gt 9&quot;&gt;</span><br><span class="line">    &lt;li&gt;A lot of books!&lt;/li&gt;</span><br><span class="line">&lt;/t&gt;</span><br><span class="line">&lt;t t-else=&quot;&quot;&gt;</span><br><span class="line">    &lt;li&gt;&lt;field name=&quot;num_books&quot; /&gt; books.&lt;/li&gt;</span><br><span class="line">&lt;/t&gt;</span><br></pre></td></tr></table></figure>

<p>Javascript表达式中，AND和OR的运算符分别为&amp;&amp;和 ||。但在 XML 中不支持&amp;符号，我们可以使用 and 和 or 运算符来规避这一问题。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dd2823f9036f4465a39c5e956b743fd9~tplv-k3u1fbpfcp-zoom-1.image" alt="Odoo 12 QWeb 条件判断"></p>
<h3 id="渲染值-t-esc和t-raw"><a href="#渲染值-t-esc和t-raw" class="headerlink" title="渲染值 - t-esc和t-raw"></a>渲染值 - t-esc和t-raw</h3><p>我们使用了<code>&lt;field&gt;</code>元素来渲染值，但也可以无需<code>&lt;field&gt;</code>标签直接显示字段值。t-esc指令运行表达式并将其渲染为转义后的 HTML 值，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;t t-esc=&quot;record.message_partner_ids.raw_value&quot; /&gt;</span><br></pre></td></tr></table></figure>

<p>有些情况下，如果确定源数据是安全的，可以无需转义使用t-raw 来渲染原始值，如下例所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;t t-raw=&quot;record.message_partner_ids.raw_value&quot; /&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>小贴士：</strong> 出于安全考虑，应尽量避免使用t-raw。它应严格用于输出特别准备不包含用户数据的HTML 数据，或者是已明确对 HTML 特殊字符转义的用户数据。</p>
</blockquote>
<h3 id="为变量设置值-t-set"><a href="#为变量设置值-t-set" class="headerlink" title="为变量设置值 - t-set"></a>为变量设置值 - t-set</h3><p>对于更复杂的逻辑，我们可以将表达式结果存储在变量中，在模板中随后使用。这通过t-set指令来实现，它设置变量名，紧接着使用t-value指令来添加表达式计算分配的值。作为示例，以下代码将优先级较高的和前面一节一样渲染为红色，但使用red_or_black 变量来作为 CSS 类使用的变量，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;t t-set=&quot;red_or_black&quot;</span><br><span class="line">    t-value=&quot;record.priority.raw_value gte &#x27;2&#x27; ? &#x27;oe_kanban_text_red&#x27; :&#x27;&#x27;&quot; /&gt;</span><br><span class="line">&lt;li t-att-class=&quot;red_or_black&quot;&gt;</span><br><span class="line">    &lt;field name=&quot;user_id&quot; /&gt;</span><br><span class="line">&lt;/li&gt;</span><br></pre></td></tr></table></figure>

<p>变量中也可分配 HTML内容，示例如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;t t-set=&quot;calendar_sign&quot;&gt;</span><br><span class="line">    &lt;i class=&quot;fa fa-calendar&quot; /&gt;</span><br><span class="line">&lt;/t&gt;</span><br><span class="line">&lt;t t-raw=&quot;calendar_sign&quot; /&gt;</span><br></pre></td></tr></table></figure>

<p> </p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/30566f47384743f99269d8d535f13e98~tplv-k3u1fbpfcp-zoom-1.image" alt="Odoo 12为变量设置值"></p>
<h3 id="调用和复用其它模板-t-call"><a href="#调用和复用其它模板-t-call" class="headerlink" title="调用和复用其它模板 - t-call"></a>调用和复用其它模板 - t-call</h3><p>QWeb模板可作为可复用的 HTML 片段插入到其它模板中。我们无需重复相同的 HTML 代码块，可以设计构成部分来组成更为复杂的用户界面视图，可复用的模板在<code>&lt;templates&gt;</code>标签中定义，通过顶级元素中 kanban-box 以外的 t-name值进行标识。这些模板可通过t-call来进行包含，在当前看板视图、相同模块的其它地方以及其它插件模块中均可。</p>
<p>follower头像列表可以通过可复用代码段来进行分离，下面通过子模板重写代码。首先应在 XML 文件中添加另一个模板，在<code>&lt;templates&gt;</code>元素内，<code>&lt;t t-name=&quot;kanban-box&quot;&gt;</code>节点之后，添加如下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;t t-name=&quot;follower_avatars&quot;&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;t t-foreach=&quot;record.message_partner_ids.raw_value.slice(0,3)&quot;</span><br><span class="line">            t-as=&quot;rec&quot;&gt;</span><br><span class="line">            &lt;img t-att-src=&quot;kanban_image(&#x27;res.partner&#x27;, &#x27;image_small&#x27;, rec)&quot;</span><br><span class="line">                class=&quot;oe_avatar&quot; width=&quot;24&quot; height=&quot;24&quot; alt=&quot;&quot; /&gt;</span><br><span class="line">        &lt;/t&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/t&gt;</span><br></pre></td></tr></table></figure>

<p>在kanban-box主模板调用它就简单明了了，将原来包含 for each 指令的<div>元素修改为如下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;t t-call=&quot;follower_avatars&quot; /&gt;</span><br></pre></td></tr></table></figure>

<p>调用其它插件模块中定义的模板，和视图类似，我们需要使用完整的module.name标识符。比如，以上代码片断可使用library_checkout.follower_avatars完整标识符来进行引用 。调用的模板和调用者运行在同一上下文中，所以调用方中的变量名在处理调用模板时同样可用。</p>
<p>一种更优雅的实现方式是向调用模板传递参数，这通过在 t-call 标签中设置变量来完成。这些仅在子模板上下文中运行和使用，在调用方上下文中并不存在。我们将使用这个方法来让调用方设置follower 头像的最大数，而不是在子模板中硬编码。首先，我们将原固定值3修改为一个变量 arg_max：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;t t-name=&quot;follower_avatars&quot;&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;t t-foreach=&quot;record.message_partner_ids.raw_value.slice(0, arg_max)&quot;</span><br><span class="line">            t-as=&quot;rec&quot;&gt;</span><br><span class="line">            &lt;img t-att-src=&quot;kanban_image(&#x27;res.partner&#x27;, &#x27;image_small&#x27;, rec)&quot;</span><br><span class="line">                class=&quot;oe_avatar&quot; width=&quot;24&quot; height=&quot;24&quot; alt=&quot;&quot; /&gt;</span><br><span class="line">        &lt;/t&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/t&gt;</span><br></pre></td></tr></table></figure>

<p>然后像下面这样在执行子模板调用时定义该变量：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;t t-call=&quot;follower_avatars&quot;&gt;</span><br><span class="line">    &lt;t t-set=&quot;arg_max&quot; t-value=&quot;3&quot; /&gt;</span><br><span class="line">&lt;/t&gt;</span><br></pre></td></tr></table></figure>

<p>t-call元素内的整个内容可通过0（数字零）这个魔法变量在子模板中使用。不使用参数变量，我们还可以定义代码片断并在子模板中通过<code>&lt;t t-raw=&quot;0&quot; /&gt;</code>使用。这对以模块化的方式创建布局、合并&#x2F;嵌套 QWeb 模板尤为有用。</p>
<h3 id="字典和列表动态属性"><a href="#字典和列表动态属性" class="headerlink" title="字典和列表动态属性"></a>字典和列表动态属性</h3><p>我们已经学习最重要的那些QWeb指令，但还有一部分我们也应该了解。下面简短地进行讲解。</p>
<p>前面我们看到t-att-NAME和t-attf-NAME样式的动态标签属性，此外还可以使用固定的t-att指令。它接收键值对字典或pair（两个元素的列表）。</p>
<p>使用如下映射：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;p t-att=&quot;&#123;&#x27;class&#x27;: &#x27;oe_bold&#x27;, &#x27;name&#x27;: &#x27;Hello&#x27;&#125;&quot; /&gt;</span><br></pre></td></tr></table></figure>

<p>将生成如下结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;p class=&quot;oe_bold&quot; name=&quot;Hello&quot; /&gt;</span><br></pre></td></tr></table></figure>

<p>使用如下 pair：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;p t-att=&quot;[&#x27;class&#x27;, &#x27;oe_bold&#x27;]&quot; /&gt;</span><br></pre></td></tr></table></figure>

<p>将生成如下结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;p class=&quot;oe_bold&quot; /&gt;</span><br></pre></td></tr></table></figure>

<h2 id="看板视图的继承"><a href="#看板视图的继承" class="headerlink" title="看板视图的继承"></a>看板视图的继承</h2><p>看板视图和报表中使用的模板可通过视图相同的常规方法来进行继承，例如，使用XPath表达式，参见第四章 <a target="_blank" rel="noopener" href="https://alanhou.org/odoo12-extending-modules/">Odoo 12 开发之模块继承</a>。</p>
<p>常见的情况是使用<code>&lt;field&gt;</code>元素作为选择器，然后在其前或后添加其它元素。对于看板视图，同一字段可声明多次，例如在模板前和模板内分别声明。这时，选择器将匹配第一个字段元素，不会将修改我们希望修改的模板内的字段。要规避这一问题，我们需使用XPath来确保匹配的是模板内的字段，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;record id=&quot;res_partner_kanban_inherit&quot; model=&quot;ir.ui.view&quot;&gt;</span><br><span class="line">	&lt;field name=&quot;name&quot;&gt;Contact Kanban modification&lt;/field&gt;</span><br><span class="line">	&lt;field name=&quot;model&quot;&gt;res.partner&lt;/field&gt;</span><br><span class="line">	&lt;field name=&quot;inherit_id&quot; ref=&quot;base.res_partner_kanban_view&quot; /&gt;</span><br><span class="line">	&lt;field name=&quot;arch&quot; type=&quot;xml&quot;&gt;</span><br><span class="line">		&lt;xpath expr=&quot;//t[@t-name=&#x27;kanban-box&#x27;]//field[@name=&#x27;display_name&#x27;]&quot;</span><br><span class="line">			position=&quot;before&quot;&gt;</span><br><span class="line">			&lt;span&gt;Name:&lt;/span&gt;</span><br><span class="line">		&lt;/xpath&gt;</span><br><span class="line">	&lt;/field&gt;</span><br><span class="line">&lt;/record&gt;</span><br></pre></td></tr></table></figure>

<p>在上例中，XPath 查找<code>&lt;t t-name=&quot;kanban-box&quot;&gt;</code>元素内的<code>&lt;field name=&quot;display_name&quot;&gt;</code>元素。这条规则会排除掉<code>&lt;templates&gt;</code>版块之外的相同字段元素。对于更 复杂的XPath表达式，我们可以使用命令行工具来研究出正确的语法。你的 Linux 系统中可能已有安装了xmllint工具（sudo apt install libxml2-utils），它有一个–xpath 选项可对 XML 文件执行查询。</p>
<p>另一个输出更好看的选项是Debian&#x2F;Ubuntu包中的libxml-xpath-perl，带有一个xpath 命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get install libxml-xpath-perl</span><br><span class="line">$ xpath -e &quot;//record[@id=&#x27;res_partner_kanban_view&#x27;]&quot; -e &quot;//field[@name=&#x27;display_name&#x27;]]&quot; /path/to/myfile.xml</span><br></pre></td></tr></table></figure>

<h2 id="自定义-CSS-和-JavaScript"><a href="#自定义-CSS-和-JavaScript" class="headerlink" title="自定义 CSS 和 JavaScript"></a>自定义 CSS 和 JavaScript</h2><p>如前所见，看板视图大多数为 HTML 并重度使用了 CSS 类。我们介绍了标准产品中提供的一些常用 CSS 类，但要实现最佳效果，我们还可以为模块添加自己的 CSS。我们这里不会详细讲解 CSS 代码的写法，但相应地需要讲解如何为模块添加自己的 CSS (JavaScript)这些前端资源。Odoo 中后台的前端资源在assets_backend模块中声明。要在模块中添加前端资源，需要对模块进行继承。进行这一操作的 XML 文件通常放在views&#x2F; 模块子目录内。</p>
<p>以下是在library_checkout模块中添加一个 CSS 和 JavaScript文件的示例，对应文件为library_checkout&#x2F;views&#x2F;checkout_kanban_assets.xml：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;odoo&gt;</span><br><span class="line">    &lt;template id=&quot;assets_backend&quot; inherit_id=&quot;web.assets_backend&quot;</span><br><span class="line">        name=&quot;Library Checkout Kanban Assets&quot;&gt;</span><br><span class="line">        &lt;xpath expr=&quot;.&quot; position=&quot;inside&quot;&gt;</span><br><span class="line">            &lt;link rel=&quot;stylesheet&quot;</span><br><span class="line">                href=&quot;/library_checkout/static/src/css/checkout_kanban.css&quot; /&gt;</span><br><span class="line">            &lt;script type=&quot;text/javascript&quot;</span><br><span class="line">                src=&quot;/library_checkout/static/src/js/checkout_kanban.js&quot;&gt;</span><br><span class="line">            &lt;/script&gt;</span><br><span class="line">        &lt;/xpath&gt;</span><br><span class="line">    &lt;/template&gt;</span><br><span class="line">&lt;/odoo&gt;</span><br></pre></td></tr></table></figure>

<p>和平常一样，需要在__manifest__.py描述文件中对其进引用，注意这些前端文件放在&#x2F;static&#x2F;src 子目录中，这不是强制要求，但是约定俗成如此。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我们学习了看板和如何创建看板视图来实现这些看板。我们还介绍了QWeb模板以及使用它来设计看板卡片。QWeb同时还是 CMS 网站的渲染引擎，因此它在 Odoo 工具集中的重要性越来越高。</p>
<p>看板视图可通过其它视图中使用的相同XML语法来进行继承。看板的 XML 结构可能会更为复杂，我们经常需要使用XPath表达式来定义需继承的元素。</p>
<p>最后，高级看板视图可以使用独有的 CSS 和 JavaScript 文件。可作为模块文件来进行添加，然后应在web.assets_backend QWeb模板中添加这些文件，以在客户端页面中包含。</p>
<p>在下一篇文章中，我们将继续使用QWeb，但是是在服务端创建自定义报表 。</p>
<p> </p>
<p>☞☞☞第十二章 <a target="_blank" rel="noopener" href="https://alanhou.org/odoo12-reports-qweb/">Odoo 12开发之报表和服务端 QWeb</a></p>
<p> </p>
<h2 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h2><p>以下参考材料是对本文所学习课题的补充：</p>
<ul>
<li>Odoo<a target="_blank" rel="noopener" href="https://www.odoo.com/documentation/12.0/reference/qweb.html">官方文档</a>QWeb的介绍</li>
<li>Bootstrap<a target="_blank" rel="noopener" href="https://getbootstrap.com/docs/4.1/getting-started/introduction/">样式文档</a></li>
<li>Font Awesome<a target="_blank" rel="noopener" href="https://fontawesome.com/v4.7.0/icons/">图标索引</a></li>
</ul>
<p> </p>
<p>☞☞☞第十一章 <a target="_blank" rel="noopener" href="https://alanhou.org/odoo12-kanban-qweb/">Odoo 12开发之看板视图和用户端 QWeb</a></p>
<p> </p>
<h2 id="扩展阅读-1"><a href="#扩展阅读-1" class="headerlink" title="扩展阅读"></a>扩展阅读</h2><p>以下本文中所讨论的话题的附加参考和补充材料：</p>
<ul>
<li><p>Odoo 官方文档</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.odoo.com/documentation/12.0/reference/actions.html">有关actions</a></li>
<li><a target="_blank" rel="noopener" href="https://www.odoo.com/documentation/12.0/reference/views.html">有关视图</a></li>
</ul>
</li>
<li><p>Font Awesome<a target="_blank" rel="noopener" href="https://fontawesome.com/v4.7.0/icons/">图标索引</a></p>
</li>
</ul>
<p>本文首发地址：<a target="_blank" rel="noopener" href="https://alanhou.org/developer-mode-odoo12/">Alan Hou 的个人博客</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://alanhou.github.io/2019/01/17/odoo-essentials-12-chapter10/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Alan Hou">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Alan Hou的个人博客">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Alan Hou的个人博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2019/01/17/odoo-essentials-12-chapter10/" class="post-title-link" itemprop="url">第十章 Odoo 12开发之后台视图 – 设计用户界面</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2019-01-17 00:00:00" itemprop="dateCreated datePublished" datetime="2019-01-17T00:00:00+08:00">2019-01-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2023-02-03 14:19:36" itemprop="dateModified" datetime="2023-02-03T14:19:36+08:00">2023-02-03</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>本文为<a target="_blank" rel="noopener" href="https://alanhou.org/odoo-12-development/">最好用的免费ERP系统Odoo 12开发手册</a>系列文章第十篇。</p>
<p>本文将学习如何为用户创建图形化界面来与图书应用交互。我们将了解不同视图类型和小组件(widgets)之间的差别，以及如何使用它们来提供更优的用户体验。</p>
<p>本文主要内容有：</p>
<ul>
<li>菜单项</li>
<li>窗口操作(Window Actions)</li>
<li>表单视图结构</li>
<li>字段</li>
<li>按钮和智能按钮</li>
<li>动态视图元素</li>
<li>列表视图</li>
<li>搜索视图</li>
<li>其它视图类型</li>
</ul>
<h2 id="开发准备"><a href="#开发准备" class="headerlink" title="开发准备"></a>开发准备</h2><p>我们将继续使用library_checkout插件模块，它已经有了模型层，现在需要视图层来实现用户界面。本文中的代码基于第八章 <a target="_blank" rel="noopener" href="https://alanhou.org/odoo12-business-logic/">Odoo 12开发之业务逻辑 - 业务流程的支持</a>，相关代码请参见 <a target="_blank" rel="noopener" href="https://github.com/alanhou/odoo12-development/tree/master/chapter8">GitHub 仓库</a>，本章完成后代码也请参见 <a target="_blank" rel="noopener" href="https://github.com/alanhou/odoo12-development/tree/master/chapter10">GitHub仓库</a>。</p>
<h2 id="菜单项"><a href="#菜单项" class="headerlink" title="菜单项"></a>菜单项</h2><p>用户界面的入口是菜单项，菜单项形成一个层级结构，最顶级项为应用，其下一级为每个应用的主菜单。还可以添加更深的子菜单。可操作菜单与窗口操作关联，它告诉客户端在点击了菜单项后应执行什么操作。</p>
<p>菜单项存储在ir.ui.menu模型中，可通过Settings &gt; Technical &gt; User Interface &gt; Menu Items菜单进行查看。</p>
<p>library_app模块为图书创建了一个顶级菜单，library_checkout插件模块添加了借阅和借阅阶段的菜单项。在library_checkout&#x2F;views&#x2F;library_menu.xml文件中，借阅的菜单项 XML 代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;menuitem id=&quot;menu_library_checkout&quot;</span><br><span class="line">    name=&quot;Checkout&quot;</span><br><span class="line">    action=&quot;action_library_checkout&quot;</span><br><span class="line">    parent=&quot;library_app.menu_library&quot; /&gt;</span><br></pre></td></tr></table></figure>

<p>这里有一个<menuitem>快捷元素，提供了一种定义菜单项的简写方式，比原生的<record model="ir.ui.view">元素要更为便捷。以上使用的属性有：</p>
<ul>
<li>name是展示在用户界面中的菜单项标题</li>
<li>action是点击菜单项时运行的窗口操作的XML ID</li>
<li>parent是父级菜单项的XML ID。本例中父级项由其它模块创建，因此们使用了完整的XML ID, <module>.<XML ID>进行引用。</li>
</ul>
<p>还有以下可用属性：</p>
<ul>
<li>sequence设置一个数字来在展示菜单项时进行排序，如sequence&#x3D;”10”</li>
<li>groups是一个逗号分隔的可访问菜单项安全组的XML ID列表，如groups&#x3D;”library_app.library_group_user, library_app.library_group_manager”</li>
<li>web_icon是菜单项的图标，仅用于企业版的顶级菜单项，如web_icon&#x3D;”library_app,static&#x2F;description&#x2F;icon.png”</li>
</ul>
<h2 id="窗口操作-Window-Actions"><a href="#窗口操作-Window-Actions" class="headerlink" title="窗口操作(Window Actions)"></a>窗口操作(Window Actions)</h2><p>窗口操作给 GUI（图形化用户界面）客户端操作指令，通常用于菜单项或视图中的按钮。它告诉 GUI 所作用的模型以及要显示的视图。这些操作可以通过域过滤器过滤出可用记录，设置默认值以及从上下文属性中过滤。窗口操作存储在ir.actions.act_window模型中，可通过Settings &gt; Technical &gt; Actions &gt; Window Actions菜单进行查看。</p>
<p>在library_checkout&#x2F;views&#x2F;library_menu.xml文件中，我们可以找到借阅菜单项中使用的窗口操作，我们需要对其进行修改来启用本文中将添加的视图类型：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;act_window id=&quot;action_library_checkout&quot;</span><br><span class="line">    name=&quot;Checkouts&quot;</span><br><span class="line">    res_model=&quot;library.checkout&quot;</span><br><span class="line">    view_mode=&quot;tree,form,activity,calendar,graph,pivot&quot; /&gt;</span><br></pre></td></tr></table></figure>

<p>窗口操作通常像以上这样使用<act_window>快捷标签创建。这里修改”tree, form”为更大的列表”tree, form, activity, calendar, graph, pivot”。以上使用的窗口操作属性有：</p>
<ul>
<li>name是通过操作打开的视图中显示的标题</li>
<li>res_model是目标模型的标识符</li>
<li>view_mode是一个逗号分隔的可用视图类型列表。第一项为默认打开时的视图。</li>
</ul>
<p>窗口操作还有一些其它属性：</p>
<ul>
<li>target：如果设置为 new,会在弹出的对话框窗口中打开视图，例如target&#x3D;”new”。默认值是current，在主内容区行内打开视图。</li>
<li>context：为目标视图设置上下文信息，可设置默认值或启用过滤器等，例如context&#x3D;”{‘default_user_id’: uid}”。</li>
<li>domain：是对可在打开视图中浏览的记录强制过滤的域表达式，例如domain&#x3D;”[(‘user_id’, ‘&#x3D;’, uid)]”。</li>
<li>limit：列表视图中每页显示的记录数，例如limit&#x3D;”80”。</li>
</ul>
<p>做了这些修改后，在选择Checkouts菜单项并浏览相应的列表视图时，右上角在列表和表单按钮后会增加一些按钮。但在我们创建对应视图前并不能使用，本文将一一学习。窗口操作还可在列表和表单视图的上方的 Action 菜单按钮中使用，它在 Fitlers 按钮旁。要使用这个，我们需要在元素中添加以下两个属性：</p>
<ul>
<li>src_model设置Action所作用的模型，例如src_model&#x3D;”library.checkout”</li>
<li>multi&#x3D;”true”也启用列表视图中的Action，这样它可以作用于多个已选记录。否则仅在表单视图中可用，并且一次只能应用于一条记录。</li>
</ul>
<p>补充：此时打开借阅表单会提示Insufficient fields for Calendar View!，在编写日历视图前最好选视图模式里删除 calendar 来进行效果查看</p>
<h2 id="表单视图结构"><a href="#表单视图结构" class="headerlink" title="表单视图结构"></a>表单视图结构</h2><p>表单视图要么按照简单布局，要么按与纸质文档相似的业务文档布局。我们将学习如何设计这些业务文档布局以及使用可用的元素和组件。要进行这一学习，我们重新查看并扩展第八章 <a target="_blank" rel="noopener" href="https://alanhou.org/odoo12-business-logic/">Odoo 12开发之业务逻辑 - 业务流程的支持</a>中创建的图书借阅表单。</p>
<h3 id="业务文档视图"><a href="#业务文档视图" class="headerlink" title="业务文档视图"></a>业务文档视图</h3><p>业务应用中记录的很多数据可以按纸质文档那样展示。表单视图可模仿这些纸质文档来提供更直观的用户界面。例如，在我们的应用中，可以把一次借阅看作填写一张纸，我们将编写一个遵循这一设计的表单视图。编辑library_checkout&#x2F;views&#x2F;chceckout_view.xml文件并修改表单视图记录来带有业务文档视图的基本框架：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">    &lt;record id=&quot;view_form_checkout&quot; model=&quot;ir.ui.view&quot;&gt;</span><br><span class="line">        &lt;field name=&quot;model&quot;&gt;library.checkout&lt;/field&gt;</span><br><span class="line">        &lt;field name=&quot;arch&quot; type=&quot;xml&quot;&gt;</span><br><span class="line">            &lt;form&gt;</span><br><span class="line">                &lt;header&gt;</span><br><span class="line">                    &lt;!--以下仅供查看效果使用--&gt;</span><br><span class="line">                    &lt;field name=&quot;state&quot; widget=&quot;statusbar&quot; clickable=&quot;True&quot; /&gt;</span><br><span class="line">                &lt;/header&gt;</span><br><span class="line">                &lt;sheet&gt;</span><br><span class="line">...</span><br><span class="line">                &lt;/sheet&gt;</span><br><span class="line">                &lt;div class=&quot;oe_chatter&quot;&gt;</span><br><span class="line">                    &lt;field name=&quot;message_follower_ids&quot; widget=&quot;mail_followers&quot; /&gt;</span><br><span class="line">                    &lt;field name=&quot;activity_ids&quot; widget=&quot;mail_activity&quot; /&gt;</span><br><span class="line">                    &lt;field name=&quot;message_ids&quot; widget=&quot;mail_thread&quot; /&gt;</span><br><span class="line">                &lt;/div&gt;</span><br><span class="line">            &lt;/form&gt;</span><br><span class="line">        &lt;/field&gt;</span><br><span class="line">    &lt;/record&gt;</span><br></pre></td></tr></table></figure>

<p>视图名称是可选的，在不写时会自动生成。为简便以上利用了这一点，在视图记录中省略了<field name="name">元素。可以看到业务文件视图通常使用三大区域：</p>
<ul>
<li>header状态栏</li>
<li>sheet主内容</li>
<li>底部交流区，也称作chatter</li>
</ul>
<p>底部的交流区使用了 mail 插件模块中提供的社交网络组件。可使用这些，我们的模型需要继承mail.thread和mail.activity.mixin，可参见第八章 <a target="_blank" rel="noopener" href="https://alanhou.org/odoo12-business-logic/">Odoo 12开发之业务逻辑 - 业务流程的支持</a>。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5847c21dca184538a932d12d9d96e2cc~tplv-k3u1fbpfcp-zoom-1.image" alt="Odoo 12文档视图"></p>
<h3 id="头部-Header"><a href="#头部-Header" class="headerlink" title="头部 Header"></a>头部 Header</h3><p>头部header 通常用于文档所走过的生命周期或步骤，还包含相关的操作按钮。这些按钮是普通表单按钮，最重要的下一步可以高亮显示。</p>
<h3 id="头部按钮"><a href="#头部按钮" class="headerlink" title="头部按钮"></a>头部按钮</h3><p>编辑表单视图中的<header>版块，我们添加一个按钮来更易于设置归还的借阅为完成(done)：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;header&gt;</span><br><span class="line">    &lt;field name=&quot;state&quot; invisible=&quot;True&quot; /&gt;</span><br><span class="line">    &lt;button name=&quot;button_done&quot;</span><br><span class="line">        string=&quot;Return Books&quot;</span><br><span class="line">        attrs=&quot;&#123;&#x27;invisible&#x27;:</span><br><span class="line">            [(&#x27;state&#x27;, &#x27;in&#x27;, [&#x27;new&#x27;, &#x27;done&#x27;])]&#125;&quot;</span><br><span class="line">        class=&quot;oe_highlight&quot; /&gt;</span><br><span class="line">&lt;/header&gt;</span><br></pre></td></tr></table></figure>

<p>这里我们在头部添加了一个Return Books 按钮，在点击时调用button_done模型方法。注意可使用class&#x3D;”oe_highlight”来对用户高亮显示操作。例如，在有几个可选按钮时，我们可以高亮显示主操作或下一步要执行的“更多”操作。attrs用于在 New 和 Done 状态时隐藏该按钮。实现这点的条件使用了不会在表单显示的 state 字段。要使条件生效，我们需要将使用的所有值在网页客户端中加载。我们不打算向终端用户显示 state 字段，因此使用 invisible 将其添加为不可见字段。</p>
<blockquote>
<p>ℹ️domain 或 attrs 表达式中使用的字段必须在视图中加载，作用于它们的<field>元素。如果字段不对用户可见，则必须以不可见字段元素对其进行加载。</p>
</blockquote>
<p>本例中我们使用的是 state 字段，相同的效果可通过 states 字段属性实现。虽然没有 attrs 属性灵活，但它更为精简。可将 attrs 一段替换为如下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;button name=&quot;button_done&quot;</span><br><span class="line">    type=&quot;object&quot;</span><br><span class="line">    string=&quot;Returned&quot;</span><br><span class="line">    states=&quot;open,cancel&quot;</span><br><span class="line">    class=&quot;oe_highlight&quot; /&gt;</span><br></pre></td></tr></table></figure>

<p>attrs和states元素可见功能也可用于其它视图元素，如 field。本文后续会深入讨论。要让按钮可以运作，我们还需要实现调用的方法。在library_checkout&#x2F;models&#x2F;library_checkout.py file文件的借阅类里添加以下方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">def button_done(self):</span><br><span class="line">    Stage = self.env[&#x27;library.checkout.stage&#x27;]</span><br><span class="line">    done_stage = Stage.search(</span><br><span class="line">        [(&#x27;state&#x27;, &#x27;=&#x27;, &#x27;done&#x27;)],</span><br><span class="line">        limit=1)</span><br><span class="line">    for checkout in self:</span><br><span class="line">        checkout.stage_id = done_stage</span><br><span class="line">    return True</span><br></pre></td></tr></table></figure>

<p>该方法首先查找 done 阶段的记录来使用，然后对 self 记录集中的每条记录，设置其 stage_id 值为完成阶段。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6b7cf8c4e92748ac9980a00ab0047240~tplv-k3u1fbpfcp-zoom-1.image" alt="Odoo 12高亮显示按钮"></p>
<h3 id="阶段管道"><a href="#阶段管道" class="headerlink" title="阶段管道"></a>阶段管道</h3><p>下面我们为头部添加状态条组件，显示文档所在阶段。从代码层面说，是使用statusbar组件的stage_id字段的<field>元素:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">                &lt;header&gt;</span><br><span class="line">...</span><br><span class="line">                    &lt;field name=&quot;stage_id&quot;</span><br><span class="line">                        widget=&quot;statusbar&quot;</span><br><span class="line">                        clickable=&quot;True&quot;</span><br><span class="line">                        options=&quot;&#123;&#x27;fold_field&#x27;: &#x27;fold&#x27;&#125;&quot; /&gt;</span><br><span class="line">                &lt;/header&gt;</span><br></pre></td></tr></table></figure>

<p>这会在头部添加一个阶段管道组件，它在表示文档当前所在生命周期点的字段上使用了statusbar组件。通常是一个状态选项字段或阶段many-to-one字段。这两类字段在 Odoo 核心模块中多次出现。clickable属性让用户可通过点击状态条来修改文档阶段。一般需要开启它，但有时又不需要，比如需要对工作进行更强的控制，并且要求用户仅使用可用的操作按钮来进入下一步。这种方法允许在切换阶段时进行指定验证。</p>
<p>对阶段使用状态条组件时，我们可将很少使用的阶段隐藏(折叠)在 More 阶段组中。对应的阶段模型必须要有一个标记来配置需隐藏的阶段，通常命名为 fold。然后statusbar组件使用 options 属性来将这一字段名提供给fold_field选项，如以上代码所示。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b4d717160ef84b2eaa77c0738d0804b9~tplv-k3u1fbpfcp-zoom-1.image" alt="Odoo 12阶段折叠"></p>
<h3 id="使用状态代替阶段"><a href="#使用状态代替阶段" class="headerlink" title="使用状态代替阶段"></a>使用状态代替阶段</h3><p>阶段是一个使用了模型来设置进度步骤的many-to-one字段。因此终端用户可对其动态配置来符合他们具体的业务流程以及支持看板的完美展示。我们将在图书借阅中使用到state。</p>
<p>状态是一个包含了流程中相当稳定步骤的选择列表，如新建、处理中和完成。终端用户无法对其进行配置，因为它是静态的，更易于在业务逻辑中使用。视图字段对状态甚至还有特别的支持：状态字段属性仅在记录处理特定状态才对用户开放。</p>
<blockquote>
<p>ℹ️阶段引入的时间要晚于状态。两者现在共存，在 Odoo 内核的趋势是使用阶段来替代状态。但如前所述，状态仍提供一些阶段所不具备的功能。</p>
</blockquote>
<p>可通过将阶段映射到状态中来同时获得两者的优势。在借阅模型中我们通过向借阅阶段中添加一个状态字段来实现，借阅文档通过一个关联字段来使用状态。使用状态代替阶段的模型中，我们也可以使用进度条管道。这种情况下要在进度条中列出状态，需要使用statusbar_visible属性来替换fold_field选项。具体代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;field name=&quot;state&quot;</span><br><span class="line">    widget=&quot;statusbar&quot;</span><br><span class="line">    clickable=&quot;True&quot;</span><br><span class="line">    statusbar_visible=&quot;draft,open,done&quot; /&gt;</span><br></pre></td></tr></table></figure>

<p>注意在我们实际的图书借阅项目中并不能这么使用，因为它是阶段驱动的，而非状态驱动。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cebbcfc39e494c31be17ff4f6d3b7120~tplv-k3u1fbpfcp-zoom-1.image" alt="Odoo 12状态"></p>
<h3 id="文档表单"><a href="#文档表单" class="headerlink" title="文档表单"></a>文档表单</h3><p>表单画布是表单的主区域，这里放置实际的数据元素，设计上类似一张真实的纸质文档，通常 Odoo 中的这些记录也会被称为文档。通常文档表单结构包含如下区域：</p>
<ul>
<li>左上角文档标题和副标题</li>
<li>右上角按钮区</li>
<li>其它文档头部字段</li>
<li>底部笔记区，将附加字段组织成选项卡或页面</li>
</ul>
<p>文档各行通常在笔记区的第一页，在表单之后，通常有一个 chatter 组件，带有文档订阅者、讨论消息和活动规划。下面逐一了解这些区域。</p>
<p>补充：关于sheet的翻译Alan的理解sheet 仅为单(据)，但出于行文习惯一律使用表单</p>
<h4 id="标题和副标题"><a href="#标题和副标题" class="headerlink" title="标题和副标题"></a>标题和副标题</h4><p>一个元素之外的字段不会自动带有渲染它们的标签。对于标题元素就是如此，因此该元素应用来对其进行渲染。虽然要花费额外的工作量，但这样的好处是对标签显示控制有更好的灵活性。常规 HTML，包括 CSS 样式元素，可用于美化标题。一般标题放在oe_title类中。以下为扩展后的<sheet>元素，它包含标题以及一些额外字段如副标题：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;sheet&gt;</span><br><span class="line">    &lt;field name=&quot;member_image&quot; widget=&quot;image&quot; class=&quot;oe_avatar&quot; /&gt;</span><br><span class="line">    &lt;div class=&quot;oe_title&quot;&gt;</span><br><span class="line">        &lt;label for=&quot;member_id&quot; class=&quot;oe_edit_only&quot; /&gt;</span><br><span class="line">        &lt;h1&gt;&lt;field name=&quot;member_id&quot; /&gt;&lt;/h1&gt;</span><br><span class="line">        &lt;h3&gt;</span><br><span class="line">            &lt;span class=&quot;oe_read_only&quot;&gt;By &lt;/span&gt;</span><br><span class="line">            &lt;label for=&quot;user_id&quot; class=&quot;oe_edit_only&quot; /&gt;</span><br><span class="line">            &lt;field name=&quot;user_id&quot; class=&quot;oe_inline&quot; /&gt;</span><br><span class="line">        &lt;/h3&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;!-- More elements will be added from here... --&gt;</span><br><span class="line">&lt;/sheet&gt;</span><br></pre></td></tr></table></figure>

<p>此处可以看到我们使用了div, span, h1和h3这些常规 HTML 元素。<label>元素让我们可以控制字段标签在何时何处显示。for 属性标识了获取标签文件的字段。也可以使用 string 属性来为标签提供具体的文本。本例中还使用了class&#x3D;”oe_edit_only”属性让其仅在编辑模式下可用。</p>
<p>我们还可在表单左上角标题旁包含展示图像。它用在 parnter 或产品这类模型的表单视图中。作为示例，我们在标题区前添加了一个member_image字段，它使用图像组件widget&#x3D;”image”，以及特定的 CSS 类class&#x3D;”oe_avatar”。该字段尚未添加至模型中，下面我们就来添加，我们使用关联字段来将会员的图片显示在借阅文档中。编辑library_checkout&#x2F;models&#x2F;library_checkout.py文件并在借阅类中添加如下字段：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">member_image = fields.Binary(related=&#x27;member_id.partner_id.image&#x27;)</span><br></pre></td></tr></table></figure>

<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cb28aa0cb50e47a6a834ab6b656e981f~tplv-k3u1fbpfcp-zoom-1.image" alt="Odoo 12图片-标题"></p>
<h3 id="表单内容分组"><a href="#表单内容分组" class="headerlink" title="表单内容分组"></a>表单内容分组</h3><p>表单主内容区应通过<group>标签来进行组织。<group>标签在画布中插入了两列。默认在这些列中标签会在字段旁显示，因此又占据两列。字段加标签会占据 一行，下一个字段和标签又会另起一行，垂直排列。Odoo表单的常见布局是带标签的字段并排成两列。达到这一效果，我们只需要添加两个嵌入顶部的<group>标签。</p>
<p>继续修改表单视图，在主内容区标题<div>后添加如下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;group name=&quot;group_top&quot;&gt;</span><br><span class="line">    &lt;group name=&quot;group_col1&quot;&gt;</span><br><span class="line">        &lt;field name=&quot;user_id&quot; /&gt;</span><br><span class="line">        &lt;field name=&quot;checkout_date&quot; /&gt;</span><br><span class="line">    &lt;/group&gt;</span><br><span class="line">    &lt;group name=&quot;group_col2&quot;&gt;</span><br><span class="line">        &lt;field name=&quot;state&quot; /&gt;</span><br><span class="line">        &lt;field name=&quot;closed_date&quot; /&gt;</span><br><span class="line">    &lt;/group&gt;</span><br><span class="line">&lt;/group&gt;</span><br></pre></td></tr></table></figure>

<p>为 group 标签分配name是一个好的编码实践，这样在其它模块中继承时会更易于对它们进行引用。还可设置 string 属性，一旦设置将作为该部分的标题来显示。</p>
<blockquote>
<p>ℹ️<strong>Odoo 11中的修改</strong><br>string 属性不能作为继承的锚点，因为在应用继承前会对其进行翻译。这时应使用 name 属性来代替它。</p>
</blockquote>
<p>在 group 内，<newline>元素会强制在新的一行，下一个元素会渲染到组的第一列。附加的版块标题可通过组内<separator>元素添加，如果带有 string 属性也会显示标题标签。要更好地控制元素布局，我们可以使用col和colspan属性。</p>
<p>col 属性可用于<group>元素中来自定义包含的列数。如前所述，默认为两列，但可修改为任意其它数字。双数效果更佳，因为默认每个添加的字段会占据两列：字段标签和字段值。按照以下代码我们通过colspan&#x3D;”2” 来在一个组内将4个字段放在两列中显示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;group name=&quot;group_top&quot;&gt;</span><br><span class="line">    &lt;group name=&quot;group_col1&quot;</span><br><span class="line">        col=&quot;4&quot;</span><br><span class="line">        colspan=&quot;2&quot;</span><br><span class="line">        string=&quot;Group 1&quot;&gt;</span><br><span class="line">        &lt;field name=&quot;user_id&quot; /&gt;</span><br><span class="line">        &lt;field name=&quot;state&quot; /&gt;</span><br><span class="line">        &lt;field name=&quot;checkout_date&quot; /&gt;</span><br><span class="line">        &lt;field name=&quot;closed_date&quot; /&gt;</span><br><span class="line">    &lt;/group&gt;</span><br><span class="line">    &lt;group name=&quot;group_col2&quot; string=&quot;Group2&quot; /&gt;</span><br><span class="line">&lt;/group&gt;</span><br></pre></td></tr></table></figure>

<p>以上我们使用 string 属性为组添加了标题，来更清楚地看组所在位置。注意字段的顺序不同，它们先是从左到右，然后从上到下。<group>元素可以使用 colspan 属性来设置它所占用的具体列数。默认和带标签的字段一样为两列。可以修改以上代码中 col 和 colspan 的值来在表单中查看不同的效果。比如 col&#x3D;”6” colspan&#x3D;”4”的效果是什么样的？可以试一试(见下图)。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7e55449667304e39b7f551183081115e~tplv-k3u1fbpfcp-zoom-1.image" alt="Odoo 12 colspan 示例"></p>
<h3 id="选项卡笔记本-Tabbed-notebooks"><a href="#选项卡笔记本-Tabbed-notebooks" class="headerlink" title="选项卡笔记本(Tabbed notebooks)"></a>选项卡笔记本(Tabbed notebooks)</h3><p>另一种组织内容的方式是 notebook 元素，一个包含多个称为页面(page)的选项卡分区的容器。它们可以让不常用的内容在不使用时隐藏起来，或者用于按话题组织大量字段。</p>
<p>我们将在借阅表单中添加一个带有已借图书列表的notebook 元素。在前面的<group name="group_top">元素后可添加如下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;notebook&gt;</span><br><span class="line">    &lt;page string=&quot;Borrowed Books&quot; name=&quot;page_lines&quot;&gt;</span><br><span class="line">        &lt;field name=&quot;line_ids&quot; /&gt;</span><br><span class="line">    &lt;/page&gt;</span><br><span class="line">&lt;/notebook&gt;</span><br></pre></td></tr></table></figure>

<p>本例中笔记本仅有一个页面。添加更多，我们需在<section>元素内添加更多的<page>版块。页面画布默认不会渲染字段标签，如需显示，需像表单主画布那样将字段放在<group>版块内。本例中我们在页面中添加了one-to-many字段line_ids，我们已经有了页面标题，因此不需要标签。page支持以下属性：</p>
<ul>
<li>string：选项卡的标题（必填）</li>
<li>attrs：不可见属性与表达式映射的字典</li>
<li>accesskey：HTML访问密钥</li>
</ul>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7bc41790c5374bc38b607113a8fd9df6~tplv-k3u1fbpfcp-zoom-1.image" alt="Odoo 12选项卡笔记本"></p>
<h2 id="字段"><a href="#字段" class="headerlink" title="字段"></a>字段</h2><p>视图字段有一些可用属性。大部分从模型定义中获取值，但可在视图中覆盖。以下来快速查看字段的可用属性：</p>
<ul>
<li>name标识字段数据库中名称</li>
<li>string用于想要覆盖模型中标签文本的标签文本</li>
<li>help是鼠标悬停在字段上显示的提示文本，它允许我们覆盖模型定义中提供的帮助文本</li>
<li>placeholder是在字段中显示的提示文本</li>
<li>widget让我们可以覆盖字段的默认组件，一会儿我们就会讲到可用的组件</li>
<li>options是一个带有组件附加数据的JSON数据结构，值随各组件的不同支持而不同</li>
<li>class是用于字段 HTML 渲染的CSS类</li>
<li>nolabel&#x3D;”True”阻止自动字段标签的展示。仅对<group>元素内的字段有作用，通常与<label for="...">元素一起使用。</li>
<li>invisible&#x3D;”True”让字段不可见，但仍会从服务端获取数据并可在表单中使用</li>
<li>readonly&#x3D;”True”让表单中该字段不可编辑</li>
<li>required&#x3D;”True”让表单中该字段为必填</li>
</ul>
<p>一些特定字段的属性如下：</p>
<ul>
<li>password&#x3D;”True”用于文本字段。显示为密码项，隐藏所输入文字</li>
<li>filename用于二进制字段，它是用于存储上传文件名的模型字段的名称</li>
</ul>
<h3 id="字段标签"><a href="#字段标签" class="headerlink" title="字段标签"></a>字段标签</h3><p><label>元素可用于更好地控制字段标签的展示。一个使用示例是仅在表单为编辑模式时展示标签：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;label for=&quot;name&quot; class=&quot;oe_edit_only&quot; /&gt;</span><br></pre></td></tr></table></figure>

<p>这么做时，如果字段在<group>元素内部，我们通常还要对其设置nolabel&#x3D;”True”。class&#x3D;”oe_edit_only”可用于应用 CSS 样式，让标签仅在编辑模式下可见。</p>
<h3 id="字段组件"><a href="#字段组件" class="headerlink" title="字段组件"></a>字段组件</h3><p>每个字段类型都会使用相应的默认组件在表单中显示。但还有一些替代组件可以使用。对于文本字段，有如下组件：</p>
<ul>
<li>email用于让 email 文本成为可操作的”mail-to”地址</li>
<li>url用于将文本格式化为可点击的URL</li>
<li>html用于将文本渲染为HTML内容；在编辑模式下，它显示为一个WYSIWYG(所见即所得)编辑器，可在不使用 HTML 代码的情况下格式化内容。</li>
</ul>
<p>对于数字字段，有以下组件：</p>
<ul>
<li>handle在列表视图中作为一个排序字段，显示一个句柄来让我们可以拖放进行自定义排序</li>
<li>float_time将一个浮点型字段格式化为带有小时和分钟的值</li>
<li>monetary将一个浮点型字段显示为货币金额。它与currency_id字段一起使用，还可以通过options&#x3D;”{‘currency_field’: ‘currency_id’}”来使用另一个字段名</li>
<li>progressbar将一个浮点值显示为进度条百分比，有助于将字段展示为完成率</li>
<li>percentage和percentpie组件可用于浮点型字段</li>
</ul>
<p>对于关联和选择项字段，有以下附加组件：</p>
<ul>
<li>many2many_tags将值显示为按钮标签列表</li>
<li>many2many_checkboxes将选项值显示为一个复选框列表</li>
<li>selection对many-to-one字段使用选择字段组件</li>
<li>radio以单选按钮显示选择字段选项</li>
<li>priority将选项字段显示为一个可点击星形列表。选择项目通常是数值。</li>
<li>state_selection将看板状态选择列表显示为信号灯。普通状态显示为灰色，完成显示为绿色，其它状态显示为红色。</li>
<li>pdf_viewer是一个二进制字段(在 Odoo 12中引入)。</li>
</ul>
<blockquote>
<p>ℹ️<strong>Odoo 11中的修改</strong><br>state_selection在 Odoo11中引入来替换掉kanban_state_selection。后者被淘汰，但为保持向后兼容性，还支持使用。</p>
</blockquote>
<h3 id="关联字段"><a href="#关联字段" class="headerlink" title="关联字段"></a>关联字段</h3><p>在关联字段中，我们可让用户操作做一些额外控制。默认用户从这些字段中创建新记录（也称作“快速创建”）并打开关联记录表单。可通过options字段属性来关闭：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">options=&quot;&#123;&#x27;no_open&#x27;: True, &#x27;no_create&#x27;: True&#125;&quot;</span><br></pre></td></tr></table></figure>

<p>context和domain也是字段属性并对于关联字段特别有用。context可定义关联字记录默认值，domain 可限制可选记录。常见的示例为让一个字段依赖其它字段值来产生选择项。domain可在模型中直接定义，但也可在视图中进行覆盖。</p>
<p>在to-many字段中，我们还可使用 mode 属性来更改用于显示记录的视图类型。默认为 tree，但还有其它选项：form, kanban或graph。关联字段可定义行内指定视图来使用。这些视图在元素中的嵌套视图定义中声明。例如，在line_ids借阅中，我们可以为这些线路定义特定的列表和表单视图：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;notebook&gt;</span><br><span class="line">    &lt;page string=&quot;Borrowed Books&quot; name=&quot;page_lines&quot;&gt;</span><br><span class="line">        &lt;field name=&quot;line_ids&quot;&gt;</span><br><span class="line">            &lt;tree&gt;</span><br><span class="line">                &lt;field name=&quot;book_id&quot; /&gt;</span><br><span class="line">            &lt;/tree&gt;</span><br><span class="line">            &lt;!--form&gt;</span><br><span class="line">                &lt;field name=&quot;book_id&quot; /&gt;</span><br><span class="line">            &lt;/form--&gt;</span><br><span class="line">        &lt;/field&gt;</span><br><span class="line">    &lt;/page&gt;</span><br><span class="line">&lt;/notebook&gt;</span><br></pre></td></tr></table></figure>

<p>线路列表将带有给定的<tree>定义。当我们与线路交互时，弹出一个表单对话框，在<form>定义中包含该结构。</p>
<blockquote>
<p><strong>小贴士：</strong> 如果想要在列表视图的表单弹出窗口中直接编辑one-to-many路线，应使用<tree editable="top">或<tree editable="bottom"></p>
</blockquote>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/73975940065e4dab91d83e3b2fd8adef~tplv-k3u1fbpfcp-zoom-1.image" alt="Odoo 12内联列表、表单视图"></p>
<h2 id="按钮"><a href="#按钮" class="headerlink" title="按钮"></a>按钮</h2><p>按钮支持这些属性：</p>
<ul>
<li><p>string是按钮文本标签或使用图标时的 HTML alt 文本</p>
</li>
<li><p>type是执行操作的类型，有以下值：</p>
<ul>
<li>object用于调用 Python 方法</li>
<li>action用于运行窗口操作</li>
</ul>
</li>
<li><p>name标识按所选类型要操作的具体的操作，要么是模型方法名，要么是要运行的窗口操作的数据库 ID。可使用%(xmlid)d方程式来将XML ID转换成加载视图时所需的数据库 ID。</p>
</li>
<li><p>args在类型为 object 时用于向方法传递额外的参数，须是在形成方法调用参数的记录 ID 之后所添加的纯静态 JSON 参数。</p>
</li>
<li><p>context在上下文中添加值，可在窗口操作或 Python 代码方法调用之后产生效果。</p>
</li>
<li><p>confirm在运行相关操作之前显示确认消息框，显示的内容是属性中分配的文本。special&#x3D;”cancel”用于向导表单。</p>
</li>
<li><p>icon是按钮所显示的图标。可用的按钮来自Font Awesome图标集，版本为4.7.0，应通过对应的 CSS 类来指定，如icon&#x3D;”fa-question”。更多信息可访问<a target="_blank" rel="noopener" href="https://fontawesome.com/v4.7.0/icons/">Font Awesome</a>。</p>
</li>
</ul>
<blockquote>
<p>ℹ️<strong>Odoo 11中的修改</strong><br>在 Odoo 11之前，按钮图标是来自GTK客户端库的图片，并且仅限于addons&#x2F;web&#x2F;static&#x2F;src&#x2F;img&#x2F;icons中所保存图片。</p>
<p>ℹ️<strong>Odoo 11中的修改</strong><br>在 Odoo 11中工作流引擎被淘汰并删除。此前的版本中，在支持工作流的地方，按钮可通过type&#x3D;”workflow”来触发工作流引擎信号。这时name属性用于工作流的信号名。</p>
</blockquote>
<h3 id="智能按钮"><a href="#智能按钮" class="headerlink" title="智能按钮"></a>智能按钮</h3><p>在右上角版块中带有智能按钮(smart button)也很常见。智能按钮显示为带有数据指示的矩形，在点击时可进入。</p>
<p>Odoo 中使用的 UI样式是在放置智能按钮的地方带有一个隐藏框，按钮框通常是<sheet>的第一个元素，在<div class="oe_title">元素前(以及头像)，类似这样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div name=&quot;button_box&quot; class=&quot;oe_button_box&quot;&gt;</span><br><span class="line">    &lt;!-- Smart buttons will go here... --&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<p>按钮的容器是一个带有oe_button_box类的 div 元素。在 Odoo 11.0以前，可能需要添加一个oe_right类来确保按钮框在表单中右对齐。在我们的应用中，我们将在按钮中显示图书会员待归还的其它借阅的总数，点击按钮会进入这些项的列表中。</p>
<p>所以我们需要该会员处于 open 状态的借阅记录，排除掉当前借阅。对于按钮统计，我们应创建一个计算字段来在library_checkout&#x2F;models&#x2F;library_checkout.py文件的借阅类中进行计数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">num_other_checkouts = fields.Integer(</span><br><span class="line">    compute=&#x27;_compute_num_other_checkouts&#x27;)</span><br><span class="line"></span><br><span class="line">def _compute_num_other_checkouts(self):</span><br><span class="line">    for rec in self:</span><br><span class="line">        domain = [</span><br><span class="line">            (&#x27;member_id&#x27;, &#x27;=&#x27;, rec.member_id.id),</span><br><span class="line">            (&#x27;state&#x27;, &#x27;in&#x27;, [&#x27;open&#x27;]),</span><br><span class="line">            (&#x27;id&#x27;, &#x27;!=&#x27;, rec.id)]</span><br><span class="line">        rec.num_other_checkouts = self.search_count(domain)</span><br></pre></td></tr></table></figure>

<p>下一步我们可以添加按钮框并在其中添加按钮。在<sheet>版块的上方，替换上面的按钮框占位符为以下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;div name=&quot;button_box&quot; class=&quot;oe_button_box&quot;&gt;</span><br><span class="line">    &lt;button class=&quot;oe_stat_button&quot;</span><br><span class="line">        icon=&quot;fa-tasks&quot;</span><br><span class="line">        help=&quot;Other checkouts pending return.&quot;</span><br><span class="line">        type=&quot;action&quot;</span><br><span class="line">        name=&quot;%(action_other_checkouts_button)d&quot;</span><br><span class="line">        context=&quot;&#123;&#x27;default_member_id&#x27;: member_id&#125;&quot;&gt;</span><br><span class="line">        &lt;field string=&quot;To Return&quot;</span><br><span class="line">            name=&quot;num_other_checkouts&quot;</span><br><span class="line">            widget=&quot;statinfo&quot; /&gt;</span><br><span class="line">    &lt;/button&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<p>按钮元素本身是一个带有显示数据字段的容器。这些数据是使用statinfo特定组件的普通字段。该字段通常是作用于模型中定义的计算字段。除字段外，在按钮中还可以使用静态文本，如<div>Other Checkouts</div>。其它待借阅的数量展示在按钮定义中的num_other借阅字段中。</p>
<p>智能按钮必须带有class&#x3D;”oe_stat_button” CSS样式，并应使用 icon 属性来带有一个图标。它有一个type&#x3D;”action”，表示点击按钮时将运行通过 name 属性标识的窗口操作。%(action_other_checkouts_button)d表达式返回要运行的操作的数据库 ID。</p>
<p>在点击按钮时，我们要查看当前会员的其它借阅列表。这可通过action_other_checkouts_button窗口操作来实现。该操作会使用合适的域过滤器打开一个图书借阅列表。操作和相应的域过滤器在表单上下文之外处理，无法访问表单数据。因此按钮必须在上下文中设置当前member_id 来供窗口操作随后使用。使用的窗口操作必须在表单之前定义，因此我们应在 XML 文件根元素<odoo>中的最上方添加以下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;act_window id=&quot;action_other_checkouts_button&quot;</span><br><span class="line">    name=&quot;Open Other Checkouts&quot;</span><br><span class="line">    res_model=&quot;library.checkout&quot;</span><br><span class="line">    view_mode=&quot;tree,form&quot;</span><br><span class="line">    domain=&quot;[(&#x27;member_id&#x27;, &#x27;=&#x27;, default_member_id),</span><br><span class="line">        (&#x27;state&#x27;, &#x27;in&#x27;, [&#x27;open&#x27;]),</span><br><span class="line">        (&#x27;id&#x27;, &#x27;!=&#x27;, active_id)]&quot;/&gt;</span><br></pre></td></tr></table></figure>

<p>注意我们在域过滤器中如何使用default_member_id上下文键。该键还会点击按钮链接创建新任务时为member_id字段设置默认值。域过滤器也需要当前 ID。这无需在上下文中明确设置，因为网页客户端会在active_id上下文键中自动进行设置。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/df35196c7ba64de1882c2996570030f2~tplv-k3u1fbpfcp-zoom-1.image" alt="Odoo 12智能按钮"></p>
<p>以下是可在智能按钮中添加的属性，供您参考：</p>
<ul>
<li>class&#x3D;”oe_stat_button”渲染的不是普通按钮而是一个矩形</li>
<li>icon从Font Awesome图标集中选择图标来使用。访问<a target="_blank" rel="noopener" href="http://fontawesome.io/">Font Awesome</a>查看有哪些图标。</li>
<li>type和name是按钮类型以及触发的操作名。对于智能按钮，类型通常是 action，指定窗口操作，名称为所要执行操作的 ID。应传入真实数据库 ID，因此我们要使用方程式来将XML ID转换为数据库 ID：”%(actionxmlid)d”。这一操作应该会打开带有关联记录的视图。</li>
<li>string为按钮添加标签文本，这里没有使用因为所包含的字段中已经提供了文本。</li>
<li>context应用于为目标视图设置默认值，用于点击按钮后视图上新建的记录。</li>
<li>help在鼠标悬停在按钮上显示帮助提示信息</li>
</ul>
<h2 id="动态视图元素"><a href="#动态视图元素" class="headerlink" title="动态视图元素"></a>动态视图元素</h2><p>视图元素还支持一些允许视图按字段值动态变更外观或行为的属性。我们可以有onchange 事件来在编辑表单数据时修改其它字段值，或在满足特定条件时让字段为必填或显示。</p>
<h3 id="onchange-事件"><a href="#onchange-事件" class="headerlink" title="onchange 事件"></a>onchange 事件</h3><p>onchange机制允许我在某一特定字段变更时修改其它表单字段。例如一个商品字段的 onchange可以在商品被修改时设置价格字段为默认值。在老版本中，onchange 事件在视图级别定义，但8.0之后直接在模型层中定义，无需在视图上做任何特定标记。这通过使用@api.onchange(‘field1’, ‘field2’, …) 装饰器创建模型，来对一些字段绑定 onchange 逻辑。onchange 模型方法在第八章 <a target="_blank" rel="noopener" href="https://alanhou.org/odoo12-business-logic/">Odoo 12开发之业务逻辑 - 业务流程的支持</a>中详细讨论过，其中还有相关示例。</p>
<p>onchange 机制还可以在用户输入时即时反馈进行计算字段的自动重算。继续使用商品来举例，如果在修改商品时价格字段变化了，它还会根据新的价格自动更新计算后的总金额字段。</p>
<h3 id="动态属性"><a href="#动态属性" class="headerlink" title="动态属性"></a>动态属性</h3><p>一些属性允许我们根据记录的值来动态变更视图元素的显示。指定用户界面元素的可见性可通过如下属性很方便地控制：</p>
<ul>
<li>groups可根据当前用户所属安全组来让元素可见。仅指定组的成员可看到该元素。它的值应为一个逗号分隔的XML ID列表</li>
<li>states可根据记录的状态字段来让元素可见。它的值为一个逗号分隔的状态列表，仅对带有state 字段的模型生效。</li>
</ul>
<p>除这些以外，我们有一些灵活的方法来根据客户端动态生成的表达式设置元素可见性。它是一个特别属性 attrs，它的值为一个映射invisible属性值与表达式结果的字典。例如，要让closed_date字段在new和open状态时不可见，可使用如下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;field name=&quot;closed_date&quot;</span><br><span class="line">     attrs=&quot;&#123;&#x27;invisible&#x27;:[(&#x27;state&#x27;, &#x27;in&#x27;, [&#x27;new&#x27;, &#x27;open&#x27;])]&#125;&quot;/&gt;</span><br></pre></td></tr></table></figure>

<p>invisible不只在字段中可用，在任意元素中均可用。例如，它可用于 notebook 页面和group元素中。attrs属性也可为其它两个属性设置值：readonly和required。它们仅对数据字段有意义，通过二者来让字段可编辑或为必填。这让我们可以实现一些基础客户端逻辑，如根据其它字段值(如 state)来让字段设为必填。</p>
<h2 id="列表视图"><a href="#列表视图" class="headerlink" title="列表视图"></a>列表视图</h2><p>学到这里可能不太需要介绍列表视图了，但它还一些有趣的额外属性可以讨论。下面我们修改library_checkout&#x2F;views&#x2F;checkout_view.xml文件来改进第八章 <a target="_blank" rel="noopener" href="https://alanhou.org/odoo12-business-logic/">Odoo 12开发之业务逻辑 - 业务流程的支持</a>中的版本：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;record id=&quot;view_tree_checkout&quot; model=&quot;ir.ui.view&quot;&gt;</span><br><span class="line">    &lt;field name=&quot;name&quot;&gt;Checkout Tree&lt;/field&gt;</span><br><span class="line">    &lt;field name=&quot;model&quot;&gt;library.checkout&lt;/field&gt;</span><br><span class="line">    &lt;field name=&quot;arch&quot; type=&quot;xml&quot;&gt;</span><br><span class="line">        &lt;tree</span><br><span class="line">            decoration-muted=&quot;state in [&#x27;done&#x27;, &#x27;cancel&#x27;]&quot;</span><br><span class="line">            decoration-bf=&quot;state==&#x27;open&#x27;&quot;&gt;</span><br><span class="line">            &lt;field name=&quot;state&quot; invisible=&quot;True&quot; /&gt;</span><br><span class="line">            &lt;field name=&quot;request_date&quot; /&gt;</span><br><span class="line">            &lt;field name=&quot;member_id&quot; /&gt;</span><br><span class="line">            &lt;field name=&quot;checkout_date&quot; /&gt;</span><br><span class="line">            &lt;field name=&quot;stage_id&quot; /&gt;</span><br><span class="line">            &lt;field name=&quot;num_books&quot; sum=&quot;# Books&quot; /&gt;</span><br><span class="line">        &lt;/tree&gt;</span><br><span class="line">    &lt;/field&gt;</span><br><span class="line">&lt;/record&gt;</span><br></pre></td></tr></table></figure>

<p>行文本颜色和字体可根据 Python 表达式计算结果来动态变化。这通过decoration–NAME属性带上计算字段属性的表达式来实现。NAME可以是bf或it，分别表示粗体和斜体，也可以是其它Bootstrap文本上下文颜色：danger, info, muted, primary, success或warning。<a target="_blank" rel="noopener" href="https://getbootstrap.com/docs/3.3/css/#helper-classes">Bootstrap文档</a>中有相关显示示例。</p>
<blockquote>
<p>ℹ️<strong>Odoo 9中的修改</strong><br>decoration-NAME 属性在 Odoo 9中引入。在 Odoo 8中使用是 colors 和 fonts 属性。</p>
</blockquote>
<p>记住表达式中使用的字段必须要在<field>字段中声明，这样网页客户端才知道要从服务端获取该列。如果不想对用户显示，应对其使用invisible&#x3D;”1”属性。其它 tree 元素的相关属性有：</p>
<ul>
<li>default_order让我们可以覆盖模型中的默认排序，它的值和模型中定义的排序格式相同。</li>
<li>create, delete和edit，如果设为 false（字母小写），会禁用列表视图中的相应操作。</li>
<li>editable让记录在列表视图中可直接被编辑。可用值有 top 和 bottom，表示新记录添加的位置。</li>
</ul>
<p>列表视图可包含字段和按钮，表单中的大部分属性对它们也有效。在列表视图中，数值字段可显示为对应列的汇总值。为字段添加一个累加属性(sum, avg, min或max)会为其分配汇总值的标签文本。我们在 num_books 字段中添加了一个示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;field name=&quot;num_books&quot; sum=&quot;# Books&quot; /</span><br></pre></td></tr></table></figure>

<p>num_books字段计算每个借阅中的图书数量，它是一个计算字段，我们需要在模型进行添加：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">num_books = fields.Integer(compute=&#x27;_compute_num_books&#x27;)</span><br><span class="line"></span><br><span class="line">@api.depends(&#x27;line_ids&#x27;)</span><br><span class="line">def _compute_num_books(self):</span><br><span class="line">    for book in self:</span><br><span class="line">        book.num_books = len(book.line_ids)</span><br></pre></td></tr></table></figure>

<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6de19e2e7d5c4e0da1111266197680d4~tplv-k3u1fbpfcp-zoom-1.image" alt="Odoo 12列表视图数量累加"></p>
<h2 id="搜索视图"><a href="#搜索视图" class="headerlink" title="搜索视图"></a>搜索视图</h2><p>可用的搜索选项通过<search>视图类型来定义。我们可以选择在搜索框中输入时自动搜索的字段。还可以预置过滤器，通过点击启用，以及在列表视图中的预置分组选项。图书借阅的搜索视图可设置如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;record id=&quot;view_filter_checkout&quot; model=&quot;ir.ui.view&quot;&gt;</span><br><span class="line">    &lt;field name=&quot;model&quot;&gt;library.checkout&lt;/field&gt;</span><br><span class="line">    &lt;field name=&quot;arch&quot; type=&quot;xml&quot;&gt;</span><br><span class="line">        &lt;search&gt;</span><br><span class="line">            &lt;field name=&quot;member_id&quot; /&gt;</span><br><span class="line">            &lt;field name=&quot;user_id&quot; /&gt;</span><br><span class="line">            &lt;filter name=&quot;filter_not_done&quot;</span><br><span class="line">                string=&quot;To Return&quot;</span><br><span class="line">                domain=&quot;[(&#x27;state&#x27;,&#x27;=&#x27;,&#x27;open&#x27;)]&quot; /&gt;</span><br><span class="line">            &lt;filter name=&quot;filter_my_checkouts&quot;</span><br><span class="line">                string=&quot;My Checkouts&quot;</span><br><span class="line">                domain=&quot;[&#x27;user_id&#x27;, &#x27;=&#x27;, uid]&quot; /&gt;</span><br><span class="line">            &lt;filter name=&quot;group_user&quot;</span><br><span class="line">                string=&quot;By Member&quot;</span><br><span class="line">                context=&quot;&#123;&#x27;group_by&#x27;: &#x27;member_id&#x27;&#125;&quot; /&gt;</span><br><span class="line">        &lt;/search&gt;</span><br><span class="line">    &lt;/field&gt;</span><br><span class="line">&lt;/record&gt;</span><br></pre></td></tr></table></figure>

<p>在<search>视图定义中，可以看到两个member_id和user_id的简单元素，当用户在搜索框中输入时，推荐下拉框中会显示对这些字段的匹配。然后有两个使用域过滤器的预置过滤器。可在搜索框下方的 Filter 按钮下选择。第一个过滤器是 To Return 图书，也就还处于 open 状态的图书。第二个过滤器是当前图书管理员处理的图书，通过当前用户的 user_id （可在上下文的 uid 键中获取）过滤。</p>
<p>这两个过滤器可以分别被启用并以 OR运算符连接。以<separator />元素分隔的整块过滤器以 AND 运算符连接。</p>
<p>第三个过滤器仅设置 group by 上下文键，它让视图按照字段来对记录分组，本例中为 member_id 字段。</p>
<p>字段元素可使用如下属性：</p>
<ul>
<li>name标识要使用的字段</li>
<li>string用作标签文本，它会替换默认值</li>
<li>operator用于修改默认的运算符(默认值：数值字段&#x3D;，其它字段类型ilike)</li>
<li>filter_domain设置搜索使用的特定域表达式，为 operator 属性提供一种灵活的替代方式。搜索文本在表达式中通过 self 引用。一个简单示例：filter_domain&#x3D;”[(‘name’, ‘ilike’, self)]”</li>
<li>groups让对该字段的搜索仅向安全组内成员开发，它的值是一个逗号分隔的XML ID列表</li>
</ul>
<p>过滤元素有以下可用属性：</p>
<ul>
<li>name用作后续继承&#x2F;扩展或通过窗口操作启用的标识符。这不是必填项，但包含该属性是一个不错的编码习惯。</li>
<li>string是过滤器显示的标签文本，必填</li>
<li>domain是加入当前域的域表达式</li>
<li>context是加入当前上下文的上下文字典。通常使用group_id作为键，用于对记录分组的字段名作为值</li>
<li>groups让该字段的搜索仅对安全组列表(XML IDs)成员开放</li>
</ul>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d4e3f1cca7cf402c87947dc438b6bb46~tplv-k3u1fbpfcp-zoom-1.image" alt="Odoo 12搜索过滤"></p>
<h2 id="其它视图类型"><a href="#其它视图类型" class="headerlink" title="其它视图类型"></a>其它视图类型</h2><p>表单、列表和搜索视图是最常用的视图类型。但还有一些其它的视图类型可用于设计用户界面。对于前述三种基本视图类型我们已经很熟悉了，在第十一章 <a target="_blank" rel="noopener" href="https://alanhou.org/odoo12-kanban-qweb/">Odoo 12开发之看板视图和用户端 QWeb</a>中将详细介绍看板视图，它会将记录可视化为卡片形式，甚至会按列组织为看板。下面我们将学习一些其它视图类型：</p>
<ul>
<li>activity将计划活动显示为有组织的汇总</li>
<li>calendar基于所选日期字段以日历格式展示数据</li>
<li>diagram展示记录间的关系，当前不在 Odoo 中使用</li>
</ul>
<p>以下两种视图类型用于显示累加数据：</p>
<ul>
<li>graph用于图表展示</li>
<li>pivot用于交互的数据透视表</li>
</ul>
<p>还有更多的视图类型，但仅在 Odoo 企业版中可用。因为我们整个系列的文章是基于社区版的，所以无法为这些视图提供示例：</p>
<ul>
<li>dashboard使用透视表和图表这类子视图展示累加数据</li>
<li>cohort用于显示在不同时期数据如何变化</li>
<li>gantt以甘特图显示日期计划信息，常用于项目管理</li>
<li>grid通过行和列网格组织数据进行展示</li>
</ul>
<p>官方文档中提供了对所有视图和可用属性很好的参考，这里就不再重复。我们集中于提供一些基础使用示例，这样可以对这些视图入门。这样应该可以提供一个很好的基础，然后可进一步探索每个视图的所有功能。</p>
<blockquote>
<p><strong>小贴士：</strong> 可通过社区插件模块查看其它视图类型。OCA 管理的网页客户端插件请见 <a target="_blank" rel="noopener" href="https://github.com/OCA/web">GitHub 仓库</a>。例如，web_timeline模块提供了一个时间线视图类型，也可像甘特图那样展示计划信息，它是社区版的 gantt 视图类型。</p>
</blockquote>
<h3 id="活动视图"><a href="#活动视图" class="headerlink" title="活动视图"></a>活动视图</h3><p>活动视图类型是内置的计划活动汇总板，帮助用于可视化活动任务。由 mail 模块提供，因此需要先安装该模块才能使用这一视图类型。要使用这一类型，只需在窗口操作的 view_code 属性的视图列表中添加活动视图类型即可。实际的视图定义会自动生成，我们也可以手动进行添加，唯一的选项是修改 string 属性，但在UI 中并不使用。</p>
<p>作为参考，活动视图的定义类似这样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;activity string=&quot;Activities&quot;/&gt;</span><br></pre></td></tr></table></figure>

<h3 id="日历视图"><a href="#日历视图" class="headerlink" title="日历视图"></a>日历视图</h3><p>从名称可以看出，该视图类型在日历中展示记录，可通过不同时间区间浏览：按月、按周或按日。以下是我们图书借阅的日历视图，根据请求日期在日历上显示各项：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;record id=&quot;view_calendar_checkout&quot; model=&quot;ir.ui.view&quot;&gt;</span><br><span class="line">    &lt;field name=&quot;model&quot;&gt;library.checkout&lt;/field&gt;</span><br><span class="line">    &lt;field name=&quot;arch&quot; type=&quot;xml&quot;&gt;</span><br><span class="line">        &lt;calendar date_start=&quot;request_date&quot;</span><br><span class="line">            color=&quot;user_id&quot;&gt;</span><br><span class="line">            &lt;field name=&quot;member_id&quot; /&gt;</span><br><span class="line">            &lt;field name=&quot;stage_id&quot; /&gt;</span><br><span class="line">        &lt;/calendar&gt;</span><br><span class="line">    &lt;/field&gt;</span><br><span class="line">&lt;/record&gt;</span><br></pre></td></tr></table></figure>

<p>补充：请记得在菜单xml文件中加回前文删除的 calendar 类型</p>
<p>基础的日历属性有：</p>
<ul>
<li>date_start是开始日期字段（必填）</li>
<li>date_end是结束日期字段（可选）</li>
<li>date_delay是天数字段，用于代替date_end</li>
<li>all_day传入一个布尔字段名，用于标识全天活动。这类活动会忽略时长。</li>
<li>color用于为一组日历项添加颜色。每个不同值都会被分配一种颜色，它的所有项都会显示为相同颜色。</li>
<li>mode是日历视图的默认显示模块，可以是天、周或月。</li>
</ul>
<blockquote>
<p>ℹ️<strong>Odoo 11中的修改</strong><br>dipsplay 日历属性在 Odoo 11中删除。此前的版本中，它用于自定义日历项标题文本的格式，例如display&#x3D;”[name], Stage [stage_id]”。</p>
</blockquote>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c48747647f094de3ab40e649ee4bcec3~tplv-k3u1fbpfcp-zoom-1.image" alt="Odoo 12日历视图"></p>
<h3 id="透视表视图"><a href="#透视表视图" class="headerlink" title="透视表视图"></a>透视表视图</h3><p>还可通过透视表查看数据，它是一个动态分析矩阵。为此我们可使用透视表视图。</p>
<blockquote>
<p>ℹ️<strong>Odoo 9中的修改</strong><br>透视表在 Odoo 8中就已存在，作为一个图表视图功能。在 Odoo 9中，它成为一个独立的视图类型。同时也增强了透视表功能、优化了透视表数据的获取。</p>
</blockquote>
<p>数据累加仅对数据库中存储的字段可用。我们将使用num_books字段来展示一些借书数量的统计。它是一个计算字段，还没有存储在数据库中。要在这些视图中使用，需要通过添加store&#x3D;True属性先将其存储在数据库中：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">num_books = fields.Integer(</span><br><span class="line">    compute=&#x27;_compute_num_books&#x27;,</span><br><span class="line">    store=True)</span><br></pre></td></tr></table></figure>

<p>使用如下代码来为图书借阅添加数据透视表：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;record id=&quot;view_pivot_checkout&quot; model=&quot;ir.ui.view&quot;&gt;</span><br><span class="line">    &lt;field name=&quot;model&quot;&gt;library.checkout&lt;/field&gt;</span><br><span class="line">    &lt;field name=&quot;arch&quot; type=&quot;xml&quot;&gt;</span><br><span class="line">        &lt;pivot&gt;</span><br><span class="line">            &lt;field name=&quot;stage_id&quot; type=&quot;col&quot; /&gt;</span><br><span class="line">            &lt;field name=&quot;member_id&quot; /&gt;</span><br><span class="line">            &lt;field name=&quot;request_date&quot; interval=&quot;week&quot; /&gt;</span><br><span class="line">            &lt;field name=&quot;num_books&quot; type=&quot;measure&quot; /&gt;</span><br><span class="line">        &lt;/pivot&gt;</span><br><span class="line">    &lt;/field&gt;</span><br><span class="line">&lt;/record&gt;</span><br></pre></td></tr></table></figure>

<p>图表和透视表视图应包含描述轴和度量的字段元素，两者的属性大多数都通用：</p>
<ul>
<li>name像其它视图一样标识图表中使用的字段</li>
<li>type是指如何使用字段，行分组(默认)、度量(measure)或列（仅针对透视表，用于列分组）</li>
<li>interval用于日期字段，是对时间数据的分组间隔：按天、按周、按月、按季度或按年</li>
</ul>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d53862cd90d745d5a6acf65fecfa0bcd~tplv-k3u1fbpfcp-zoom-1.image" alt="Odoo 12透视表视图"></p>
<h3 id="图表视图"><a href="#图表视图" class="headerlink" title="图表视图"></a>图表视图</h3><p>图表视图将数据累加展示为图表，可以使用柱状图、线状图和饼图。下面来为图书借阅添加图表视图：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;record id=&quot;view_graph_checkout&quot; model=&quot;ir.ui.view&quot;&gt;</span><br><span class="line">    &lt;field name=&quot;model&quot;&gt;library.checkout&lt;/field&gt;</span><br><span class="line">    &lt;field name=&quot;arch&quot; type=&quot;xml&quot;&gt;</span><br><span class="line">        &lt;graph type=&quot;bar&quot;&gt;</span><br><span class="line">            &lt;field name=&quot;stage_id&quot; /&gt;</span><br><span class="line">            &lt;field name=&quot;num_books&quot; type=&quot;measure&quot; /&gt;</span><br><span class="line">        &lt;/graph&gt;</span><br><span class="line">    &lt;/field&gt;</span><br><span class="line">&lt;/record&gt;</span><br></pre></td></tr></table></figure>

<p>图表视图元素可带有一个type属性，值可为 bar(默认), pie或line。对于 bar，可使用额外的stacked&#x3D;”True”属性来让柱状图叠放起来。图表使用两种类型字段：</p>
<ul>
<li>type&#x3D;”row”是默认值，设置累加值的条件</li>
<li>type&#x3D;”measure”用于作为实际累加值的度量字段</li>
</ul>
<p>图表和透视表视图应包含描述需使用的轴和度量的字段元素。大多数图表视图中的属性同样可在透视表视图中使用。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/53de3260c991443eaf6a56d1b0fde94a~tplv-k3u1fbpfcp-zoom-1.image" alt="Odoo 12图表视图"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文中我们学习了更多创建用户界面的 Odoo 视图。我们深入讲解了表单视图，然后一起概览了其它视图类型，包括列表视图和搜索视图。我们还学习了如何向视图元素添加动态行为。</p>
<p>下一篇文章中，我们将学习本文中未涉及到的视图：看板视图以及它使用的模板语言 QWeb。</p>
<p> </p>
<p>☞☞☞第十一章 <a target="_blank" rel="noopener" href="https://alanhou.org/odoo12-kanban-qweb/">Odoo 12开发之看板视图和用户端 QWeb</a></p>
<p> </p>
<h2 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h2><p>以下本文中所讨论的话题的附加参考和补充材料：</p>
<ul>
<li><p>Odoo 官方文档</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.odoo.com/documentation/12.0/reference/actions.html">有关actions</a></li>
<li><a target="_blank" rel="noopener" href="https://www.odoo.com/documentation/12.0/reference/views.html">有关视图</a></li>
</ul>
</li>
<li><p>Font Awesome<a target="_blank" rel="noopener" href="https://fontawesome.com/v4.7.0/icons/">图标索引</a></p>
</li>
</ul>
<p>本文首发地址：<a target="_blank" rel="noopener" href="https://alanhou.org/developer-mode-odoo12/">Alan Hou 的个人博客</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" title="Next page" aria-label="Next page" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Alan Hou</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a>
  </div>

    </div>
  </footer>

  
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  




  





</body>
</html>
