<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.2.1/css/all.min.css" integrity="sha256-Z1K5uhUaJXA7Ll0XrZ/0JhX4lAtZFpT6jkKrEDT0drU=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"alanhou.github.io","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.14.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}}</script><script src="/js/config.js"></script>

    <meta property="og:type" content="website">
<meta property="og:title" content="Alan Hou的个人博客">
<meta property="og:url" content="https://alanhou.github.io/index.html">
<meta property="og:site_name" content="Alan Hou的个人博客">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Alan Hou">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://alanhou.github.io/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"en","comments":"","permalink":"","path":"index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Alan Hou的个人博客</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Alan Hou的个人博客</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">用行动赢得尊重</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="Search" role="button">
    </div>
  </div>
</div>







</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Alan Hou</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">11</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">1</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://alanhou.github.io/2019/01/19/odoo-essentials-12-chapter11/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Alan Hou">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Alan Hou的个人博客">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Alan Hou的个人博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2019/01/19/odoo-essentials-12-chapter11/" class="post-title-link" itemprop="url">第十一章 Odoo 12开发之看板视图和用户端 QWeb</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2019-01-19 00:00:00" itemprop="dateCreated datePublished" datetime="2019-01-19T00:00:00+08:00">2019-01-19</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2023-02-03 13:55:30" itemprop="dateModified" datetime="2023-02-03T13:55:30+08:00">2023-02-03</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>本文为<a target="_blank" rel="noopener" href="https://alanhou.org/odoo-12-development/">最好用的免费ERP系统Odoo 12开发手册</a>系列文章第十一篇。</p>
<p>QWeb 是 Odoo 使用的模板引擎，它基于 XML 来生成 HTML 片断和页面。通过 QWeb可生成内容丰富的看板(Kankan)视图、报表和 CMS 网页。本文中我们将学习QWeb 语法以及如何使用 QWeb 来创建我们自己的看板视图和自定义报表。</p>
<p>本文主要内容有：</p>
<ul>
<li>看板是什么？</li>
<li>设计看板视图</li>
<li>QWeb 模板语言</li>
<li>看板视图的继承</li>
<li>添加自定义 CSS 和 JavaScript</li>
</ul>
<h2 id="开发准备"><a href="#开发准备" class="headerlink" title="开发准备"></a>开发准备</h2><p>我们将继续使用第十章 <a target="_blank" rel="noopener" href="https://alanhou.org/odoo12-backend-views/">Odoo 12开发之后台视图 - 设计用户界面</a>完成的library_checkout插件模块。相应代码请见 <a target="_blank" rel="noopener" href="https://github.com/alanhou/odoo12-development/tree/master/chapter10">GitHub仓库</a>。本章完成后的代码也请参见<a target="_blank" rel="noopener" href="https://github.com/alanhou/odoo12-development/tree/master/chapter11">GitHub仓库</a>。</p>
<h2 id="了解看板"><a href="#了解看板" class="headerlink" title="了解看板"></a>了解看板</h2><p>Kanban 是一个日语词汇，字面意思榜单，与精益制造和准时化生产相关联，由丰田工业工程师大野耐一(Taiichi Ohno)引入。最近看板的概念应用于更多领域，并且随着敏捷方法的施行在软件工业内流行起来。</p>
<p>看板让我们能够可视化工作队列，它以列来进行组织，每列代表工作进程的一个阶段。工作项以放在看板对应列的卡片来表示。新的工作项从最左边的列开始，并开始向右移动直至最右边列，代表工作完成。</p>
<p>看板的简单化或视觉效果让其对简单的业务流程有着优异的支持。一个基本的看板示例包含三列，如下图所示：待办、在办和完成。当然它可以扩展为你需要的其它指定流程：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c5f76dc3b9984ba08e1738ce9bdfa848~tplv-k3u1fbpfcp-zoom-1.image" alt="看板示例"></p>
<p>对许多业务用例，看板都是管理相应流程的更有效方式，与 Odoo 11之前的更重的工作流引擎形成鲜明对比。Odoo 在支持经典的列表和表单视图的同时还支持看板视图，这易于我们实施这种类型的视图。下面就让我们一起来学习如何使用看板视图。</p>
<h3 id="看板视图"><a href="#看板视图" class="headerlink" title="看板视图"></a>看板视图</h3><p>现在我们要为借阅模型添加一个看板视图。每个借阅是一个卡片，看板将会被组织成阶段列。在前面的文章中，我们已经添加了stage_id阶段字段。</p>
<p>此前在表单视图我们大部分时候使用 Odoo 独有的 XML 元素，比如<code>&lt;field&gt;</code>和<code>&lt;group&gt;</code>，有时也会使用 HTML 元素，如<code>&lt;h1&gt;</code>或<code>&lt;div&gt;</code>，但用得较少。在看板视图中则恰恰相反，展示模板基于 HTML，仅支持两个 Odoo 独有的元素：<code>&lt;field&gt;</code>和<code>&lt;button&gt;</code>。</p>
<p>最终呈现在网页客户端中的内容是由 QWeb 模板动态生成的。QWeb 引擎处理特殊的 XML 标签和属性来进行生成。这样可以很好地控制如何渲染内容，但也让视图设计更为复杂。看板视图设计灵活性很强，我们将尽力以直接易懂地方式介绍快速创建看板视图的知识。查看与所需相似的看板视图来获取创意然后创建自己的看板是一种不错的方法。</p>
<p>我们将学习两种使用看板视图的方式。一种是卡片列表，它用于联系人、产品、雇员通讯录或应用等。联系人看板视图长这样：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f8c1e58e31084937a9081ce43334a3f7~tplv-k3u1fbpfcp-zoom-1.image" alt="Odoo 12联系人看板视图"></p>
<p>但这不是真正的看板，看板应是一个组织成不同列的卡片，当然看板视图也支持这种布局。可能过 CRM 或项目应用来查看示例。访问CRM &gt; Sales &gt; My Pipeline可得到如下结果：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/06649a94199b4b1a8203711086869147~tplv-k3u1fbpfcp-zoom-1.image" alt="Odoo 12 CRM看板视图"></p>
<p>这两种布局的最大区别是卡片按列的组织方式。这通过 Group By 功能实现，与列表视图中相似。通常分组是通过stage字段实现。看板视图的一个非常有用的功能是可以在列之间拖放卡片，自动分配分组视图字段的对应值。从两个示例中的卡片我们可以看到一些分别。其实它们的设计非常灵活，设计看板卡片不只有一种方式。这两个示例为我们提供设计的一些基础。</p>
<p>联系人卡片基本组成有左侧的图像，主区域的加粗标题和紧随其后的一系列值。CRM 管道卡片结构更为复杂些。卡片主区域也有一个标题以及相关信息紧随其后，还有 footer 区。在该区域中，可看到左侧有一个优先级组件，后面带有一个活动指示，在右侧是一个负责用户的头像。上图中看不到，在鼠标悬停在右上角时还会有一个选项菜单。这个菜单让我们可以修改卡片的颜色提示等。</p>
<p>我们将使用这种更复杂的结构来作为借阅看板卡片的参照。</p>
<h2 id="设计看板视图"><a href="#设计看板视图" class="headerlink" title="设计看板视图"></a>设计看板视图</h2><p>我们将改进一直以来开发的library_checkout模型，为图书借阅添加看板视图。为此我们使用一个新文件library_checkout&#x2F;views&#x2F;checkout_kanban_view.xml。需要在__manifest__.py文件的 data 键最下方添加这个文件。在library_checkout&#x2F;views&#x2F;library_menu.xml文件中，可以看到借阅菜单项使用的窗口操作。需要对其修改来启用本文中添加的视图类型：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;act_window id=&quot;action_library_checkout&quot;</span><br><span class="line">    name=&quot;Checkouts&quot;</span><br><span class="line">    res_model=&quot;library.checkout&quot;</span><br><span class="line">    view_mode=&quot;kanban,tree,form,activity,calendar,graph,pivot&quot; /&gt;</span><br></pre></td></tr></table></figure>

<p>这里我们修改了菜单操作来在view_mode列表的最前面添加了kanban，来让它成为默认的视图模式。然后我们来添加kanban视图记录。与其它视图基本相同，除了 arch 字段内，最外层 XML元素为<kanban>。下一步创建实际使用的 XML 文件library_checkout&#x2F;views&#x2F;checkout_kanban_view.xml来放置这个惊艳的看板视图：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot;?&gt;</span><br><span class="line">&lt;odoo&gt;</span><br><span class="line">    &lt;record id=&quot;library_checkout_kanban&quot; model=&quot;ir.ui.view&quot;&gt;</span><br><span class="line">        &lt;field name=&quot;model&quot;&gt;library.checkout&lt;/field&gt;</span><br><span class="line">        &lt;field name=&quot;arch&quot; type=&quot;xml&quot;&gt;</span><br><span class="line">            &lt;kanban&gt;</span><br><span class="line"></span><br><span class="line">            &lt;/kanban&gt;</span><br><span class="line">        &lt;/field&gt;</span><br><span class="line">    &lt;/record&gt;</span><br><span class="line">&lt;/odoo&gt;</span><br></pre></td></tr></table></figure>

<p>在使用看板视图前，我们需要为图书借阅模型添加几个字段。</p>
<h3 id="优先级、看板状态和颜色"><a href="#优先级、看板状态和颜色" class="headerlink" title="优先级、看板状态和颜色"></a>优先级、看板状态和颜色</h3><p>除阶段外，看板中还有一些常用和有用的字段：</p>
<ul>
<li>priority让用户组织他们的工作项，标记什么应优先处理</li>
<li>kanban_state标记是否应移向下一阶段或因某种原因原地不动。在模型定义层中两者都是选择项字段。在视图层，对它们有特别的组件用于表单和看板视图。</li>
<li>color用于存储看板卡片显示的颜色，并可通过看板视图中的颜色拾取器菜单设置</li>
</ul>
<p>编辑library_checkout&#x2F;models&#x2F;library_checkout.py文件来在我们的模型中添加这些字段：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Checkout(models.Model):</span><br><span class="line">...</span><br><span class="line">    priority = fields.Selection(</span><br><span class="line">        [(&#x27;0&#x27;, &#x27;Low&#x27;),</span><br><span class="line">        (&#x27;1&#x27;, &#x27;Normal&#x27;),</span><br><span class="line">        (&#x27;2&#x27;, &#x27;High&#x27;)],</span><br><span class="line">        &#x27;Priority&#x27;,</span><br><span class="line">        default=&#x27;1&#x27;)</span><br><span class="line">    kanban_state = fields.Selection(</span><br><span class="line">        [(&#x27;normal&#x27;, &#x27;In Progress&#x27;),</span><br><span class="line">        (&#x27;blocked&#x27;, &#x27;Blocked&#x27;),</span><br><span class="line">        (&#x27;done&#x27;, &#x27;Ready for next stage&#x27;)],</span><br><span class="line">        &#x27;Kanban State&#x27;,</span><br><span class="line">        default=&#x27;normal&#x27;)</span><br></pre></td></tr></table></figure>

<p>我们还应该在表单视图中添加这些字段，使用各自的特别组件。kanban_state字段就加在<code>&lt;div class=&quot;oe_title&quot;&gt;</code>之前并在按钮框之后：<code>&lt;field name=&quot;kanban_state&quot; widget=&quot;state_selection&quot; /&gt;</code>。priority应添加在name 字段之前，包裹在<code>&lt;h1&gt;</code>元素中：<code>&lt;field name=&quot;priority&quot; widget=&quot;priority&quot; /&gt;</code>。color字段一般不出现在表单视图中。</p>
<p>既然借阅模型已有我们所需使用的所有字段，我们可以来写看板视图了。</p>
<h3 id="看板卡片元素"><a href="#看板卡片元素" class="headerlink" title="看板卡片元素"></a>看板卡片元素</h3><p>看板视图框架包含一个<code>&lt;kanban&gt;</code>外层元素和以下基础结构：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;kanban default_group_by=&quot;stage_id&quot; class=&quot;o_kanban_small_column&quot;&gt;</span><br><span class="line">                &lt;!-- Fields --&gt;</span><br><span class="line">                &lt;field name=&quot;stage_id&quot; /&gt;</span><br><span class="line">                &lt;field name=&quot;id&quot; /&gt;</span><br><span class="line">                &lt;field name=&quot;color&quot; /&gt;</span><br><span class="line">                &lt;field name=&quot;kanban_state&quot; /&gt;</span><br><span class="line">                &lt;field name=&quot;priority&quot; /&gt;</span><br><span class="line">                &lt;field name=&quot;message_partner_ids&quot; /&gt;</span><br><span class="line"></span><br><span class="line">                &lt;!-- Optional progress bar --&gt;</span><br><span class="line">                &lt;progressbar</span><br><span class="line">                    field=&quot;kanban_state&quot;</span><br><span class="line">                    colors=&#x27;&#123;&quot;done&quot;: &quot;success&quot;, &quot;blocked&quot;: &quot;danger&quot;&#125;&#x27; /&gt;</span><br><span class="line">                &lt;!-- Templates with HTML snippets to use --&gt;</span><br><span class="line">                &lt;templates&gt;</span><br><span class="line">                    &lt;t t-name=&quot;kanban-box&quot;&gt;</span><br><span class="line">                        &lt;!-- HTML Qweb template --&gt;</span><br><span class="line">                    &lt;/t&gt;</span><br><span class="line">                &lt;/template&gt;</span><br><span class="line">            &lt;/kanban&gt;</span><br></pre></td></tr></table></figure>

<p>注意在元素中使用了default_group_by&#x3D;”stage_id”属性，我们用它来让看板默认以 stage 分组，这也是看板通常的分组方式。在简单卡片列表的看板中，如联系人，我们不需要添加该属性，只需使用<code>&lt;kanban&gt;</code>标签即可。<code>&lt;kanban&gt;</code>元素支持以下属性：</p>
<ul>
<li>default_group_by设置默认列分组使用的字段</li>
<li>default_order设置看板项默认使用的排序</li>
<li> quick_create&#x3D;”false”禁用了每列顶部的快速创建选项（大的加号符号），快速创建只需提供标题描述即可创建新项。false是 JavaScript 的语法，必须是小写字母。</li>
<li>class为渲染看板视图的根元素添加 CSS 类。相关类是_kanban_small_column，让列比默认的更加紧湊。其它类可由我们模块的 CSS 文件来进行提供。</li>
<li> group_create, group_edit, group_delete和quick_create_view可设置为 false 来禁用看板列上对应的操作。如group_create&#x3D;”false”删除右侧添加新列的按钮。</li>
<li>on_create用于创建用户点击左上角 Create 按钮时弹出的自定义简单表单视图窗口。应为相应的表单视图添加<code>&lt;module&gt;.&lt;xml_id&gt;</code>值。</li>
</ul>
<p>然后我们的模板中使用了一组字段。确切地说，只有在 QWeb 表达式中明确使用的字段才需要在这里声明，用以保证从服务端抓取它们的数据。QWeb引擎在处理模板前，仅会在视图中查找 <code>&lt;field name=&quot;...&quot;&gt;</code>来从模型中获取数据。QWeb的属性通常使用不会被检测到的record.field引用方式。正因为如此，需在<code>&lt;templates&gt;</code>之前包含这些字段来让模板处理时有相应字段值可以使用。</p>
<blockquote>
<p>ℹ️<strong>Odoo 11中的修改</strong><br>引入了进度条组件。使用的时候在看板列的上方会出现一个颜色条，来提供该列各项的状态数据。在本文前面CRM Pipeline的示例图中可以查看。</p>
</blockquote>
<p><code>&lt;progressbar&gt;</code>有如下属性：</p>
<ul>
<li>field是对列中各项进行颜色分组的字段名</li>
<li>colors是一个字典，将分组字段值与以下三种颜色分别进行映射：danger (红色), warning (黄色)或success (绿色)。</li>
<li>sum_field是一个可选项，用于选取整列汇总的字段名。如未设置，会使用各项的计数值。</li>
</ul>
<p>然后我们的<code>&lt;templates&gt;</code>元素包含一个或多个QWeb模板来生成要使用的 HTML 片断。必须要有一个名为kanban-box的模板，它渲染看板卡片。还可以添加其它模板，通常用于定义主模板中复用到的 HTML 片断。这些模板使用标准的 HTML 和 QWeb 模板语言。QWeb提供了一些特殊指令，用于处理动态生成最终展示的 HTML。</p>
<blockquote>
<p>ℹ️<strong>Odoo 12中的修改</strong><br>Odoo 现在使用 Twitter Bootstrap 4，此前版本中使用Bootstrap 3。这些样式在渲染 HTML 的地方通常都可使用，有关Bootstrap更多知识请见<a target="_blank" rel="noopener" href="https://getbootstrap.com/">官方网站</a>。</p>
</blockquote>
<p>下面就来详细了解看板视图中所使用的QWeb模板设计。</p>
<h3 id="看板卡片布局"><a href="#看板卡片布局" class="headerlink" title="看板卡片布局"></a>看板卡片布局</h3><p>看板卡片主内容区域在kanban-box模板内定义。这个内容区也可以有一个 footer 底部子容器。卡片右上角还可以添加按钮，点击后打开操作菜单的功能。对于footer区域，应在看板盒子模型底部使用<div>并添加oe_kanban_bottom CSS 类。还可以通过oe_kanban_bottom_left和oe_kanban_bottom_right CSS 类进一步分割为左、右 footer 区。此外，可通过Bootstrap的pull-left和pull-right类在卡片的任意位置（包括oe_kanban_bottom底部区域）添加向左或向右对齐元素。</p>
<p>以下是对看板卡片中QWeb模板的第一次迭代：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;t t-name=&quot;kanban-box&quot;&gt;</span><br><span class="line">    &lt;!-- Set the Kanban Card color --&gt;</span><br><span class="line">    &lt;div t-attf-class=&quot;</span><br><span class="line">        oe_kanban_color_#&#123;kanban_getcolor(record.color.raw_value)&#125;</span><br><span class="line">        oe_kanban_global_click&quot;&gt;</span><br><span class="line">        &lt;div class=&quot;o_dropdown_kanban dropdown&quot;&gt;</span><br><span class="line">            &lt;!-- Top-right drop down menu here... --&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">        &lt;div class=&quot;oe_kanban_body&quot;&gt;</span><br><span class="line">            &lt;!-- Content elements and fields go here... --&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">        &lt;div class=&quot;oe_kanban_footer&quot;&gt;</span><br><span class="line">            &lt;div class=&quot;oe_kanban_footer_left&quot;&gt;</span><br><span class="line">                &lt;!-- Left hand footer... --&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">            &lt;div class=&quot;oe_kanban_footer_right&quot;&gt;</span><br><span class="line">                &lt;!-- Right hand footer... --&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">        &lt;div class=&quot;oe_clear&quot; /&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/t&gt;</span><br></pre></td></tr></table></figure>

<p>这就是看板卡片的整体结构。你可能注意到了在顶部<code>&lt;div&gt;</code>元素中使用了color字段来动态设置卡片颜色。在后面的部分中我们会讲解t-attf QWeb指令的细节。现在来为主内容区域添加内容：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;oe_kanban_body&quot;&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;strong&gt;</span><br><span class="line">            &lt;a type=&quot;open&quot;&gt;&lt;field name=&quot;member_id&quot; /&gt;&lt;/a&gt;</span><br><span class="line">        &lt;/strong&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;ul&gt;</span><br><span class="line">        &lt;li&gt;&lt;field name=&quot;user_id&quot; /&gt;&lt;/li&gt;</span><br><span class="line">        &lt;li&gt;&lt;field name=&quot;request_date&quot; /&gt;&lt;/li&gt;</span><br><span class="line">    &lt;/ul&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<p>这个模板中大部分都是常规 HTML，但也有渲染字段值的<code>&lt;field&gt;</code>元素和在常规表单视图按钮中使用的 type 属性，此处用在锚文本标签中。</p>
<p>在左部 footer 中插入优先级组件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">                            &lt;div class=&quot;o_kanban_record_bottom&quot;&gt;</span><br><span class="line">                                &lt;div class=&quot;oe_kanban_bottom_left&quot;&gt;</span><br><span class="line">                                    &lt;field name=&quot;priority&quot; widget=&quot;priority&quot; /&gt;</span><br><span class="line">                                    &lt;field name=&quot;activity_ids&quot; widget=&quot;kanban_activity&quot; /&gt;</span><br><span class="line">                                &lt;/div&gt;</span><br><span class="line">...</span><br><span class="line">                            &lt;/div&gt;</span><br></pre></td></tr></table></figure>

<p>这里像我们在表单视图中做的那样添加了priority字段。还添加了一个计划活动的字段，使用kanban_activity特殊组件来显示即将开始活动的指示。</p>
<p>在右部footer中，放入看板状态组件和请求借阅的会员头像：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;oe_kanban_bottom_right&quot;&gt;</span><br><span class="line">    &lt;field name=&quot;kanban_state&quot;</span><br><span class="line">        widget=&quot;kanban_state_selection&quot; /&gt;</span><br><span class="line">    &lt;img t-att-src=&quot;kanban_image(</span><br><span class="line">            &#x27;library.checkout&#x27;,</span><br><span class="line">            &#x27;member_image&#x27;,</span><br><span class="line">            record.id.raw_value)&quot;</span><br><span class="line">        t-att-title=&quot;record.member_id.value&quot;</span><br><span class="line">        t-att-alt=&quot;record.member_id.value&quot;</span><br><span class="line">        width=&quot;24&quot;</span><br><span class="line">        height=&quot;24&quot;</span><br><span class="line">        class=&quot;oe_kanban_avatar&quot;</span><br><span class="line">    /&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<p>补充：原文件使用的 CSS 类oe_kanban_footer，oe_kanban_footer_left和oe_kanban_footer_right经测试不会进行左右对齐，参照 CRM 进行了如上修改</p>
<p>看板状态通过<code>&lt;field&gt;</code>元素和kanban_state_selection组件来进行添加。用户头像使用 HTML <code>&lt;img&gt;</code>标签插入。图像内容使用QWeb t-att-命令动态生成，后面会详细讲解。这里使用了kanban_image()帮助函数来获取src属性的值。kanban_image() Javascript函数从 Odoo 模型中获取表单并在网页中渲染。有以下属性：</p>
<ul>
<li>获取图像的模型</li>
<li>包含图像的字段</li>
<li>获取的记录 ID</li>
</ul>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b3ad0d808c6d4afd9fc5eea7d201eaa9~tplv-k3u1fbpfcp-zoom-1.image" alt="Odoo 12看板 footer 添加"></p>
<h3 id="为看板卡片添加选项菜单"><a href="#为看板卡片添加选项菜单" class="headerlink" title="为看板卡片添加选项菜单"></a>为看板卡片添加选项菜单</h3><p>看板卡片可在右上角带有一个选项菜单。通常的操作有编辑或删除记录，但也可以为其添加和按钮调用的同样操作。还有一个设置卡片颜色的组件。以下是oe_kanban_content顶部添加的选项菜单的基础代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;o_dropdown_kanban dropdown&quot;&gt;</span><br><span class="line">    &lt;a class=&quot;dropdown-toggle btn&quot;</span><br><span class="line">        data-toggle=&quot;dropdown&quot; role=&quot;button&quot;</span><br><span class="line">        aria-label=&quot;Dropdown menu&quot;</span><br><span class="line">        title=&quot;Dropdown menu&quot;</span><br><span class="line">        href=&quot;#&quot;&gt;</span><br><span class="line">        &lt;span class=&quot;fa fa-ellipsis-v&quot; /&gt;</span><br><span class="line">    &lt;/a&gt;</span><br><span class="line">    &lt;div class=&quot;dropdown-menu&quot; role=&quot;menu&quot;&gt;</span><br><span class="line">        &lt;!-- Edit and Delete actions, if available: --&gt;</span><br><span class="line">        &lt;t t-if=&quot;widget.editable&quot;&gt;</span><br><span class="line">            &lt;a role=&quot;menuitem&quot; type=&quot;edit&quot; class=&quot;dropdown-item&quot;&gt;Edit&lt;/a&gt;</span><br><span class="line">        &lt;/t&gt;</span><br><span class="line">        &lt;t t-if=&quot;widget.deletable&quot;&gt;</span><br><span class="line">            &lt;a role=&quot;menuitem&quot; type=&quot;delete&quot; class=&quot;dropdown-item&quot;&gt;Delete&lt;/a&gt;</span><br><span class="line">        &lt;/t&gt;</span><br><span class="line">        &lt;!-- Color picker option --&gt;</span><br><span class="line">        &lt;ul class=&quot;oe_kanban_colorpicker&quot; data-field=&quot;color&quot; /&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<p>下拉菜单基本上是由带有<code>&lt;a&gt;</code>标签的<code>&lt;li&gt;</code> HTML 列表元素组成。Edit 和 Delete 这类选项需要满足指定条件下才会出现。这通过<a href="">QWeb的</a><a href="">t-if命令来实现。本文后续会详细讲解</a><a href="">QWeb的命令。widget全局变量表示一个KanbanRecord()  JS 对象，负责渲染当前看板卡片。有两个非常有用的属性：widget.editable和widget.deletable，让我们可以检查相应的操作是否可用。</a></p>
<p>可以看到如何根据记录字段值来显示或隐藏选项，Set as Done仅在未设置is_done 字段时才会显示。最后一个选项添加颜色拾取器组件来使用 color 数据字段选择或修改卡片背景色。因此，除<button>元素外，<code>&lt;a&gt;</code>也可用于运行Odoo 操作。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a970e9acfd144d05bdc69c10e05e285c~tplv-k3u1fbpfcp-zoom-1.image" alt="Odoo 12看板视图下拉选项"></p>
<h3 id="看板视图中的操作"><a href="#看板视图中的操作" class="headerlink" title="看板视图中的操作"></a>看板视图中的操作</h3><p>在QWeb模板中，用于超链的<code>&lt;a&gt;</code>标签可带有一个 type 属性。它设置链接执行的操作类型，这样链接和常规表单中的按钮可进行同样的操作。和表单视图一样，操作类型可以是action或object，并应带有一个 name 属性来标识所要执行的具体操作。此外，还有以下操作类型可以使用：</p>
<ul>
<li>open打开相应的表单视图</li>
<li>edit在编辑模式下直接打开相应的表单视图</li>
<li>delete删除记录并从看板视图中删除该项</li>
</ul>
<h2 id="QWeb-模板语言"><a href="#QWeb-模板语言" class="headerlink" title="QWeb 模板语言"></a>QWeb 模板语言</h2><p>QWeb会查找模板中的特殊指令并替换为动态生成的 HTML。这些指令是 XML 元素属性，可以用在<code>&lt;div&gt;</code>, <code>&lt;span&gt;</code>或<code>&lt;field&gt;</code>等有效标签或元素中。有时我们要使用QWeb指令但不希望放在模板的 XML 元素中。对这种情况，可以使用能带有 QWeb 指令（如t-if或t-foreach）的特殊元素<code>&lt;t&gt;</code>，该元组不会在最终产生的XML&#x2F;HTML有任何输出。</p>
<p>QWeb指令常使用运算的表达式来根据当前记录值生成不同的结果。有两种不同的QWeb实现：客户端JavaScript和服务端Python。报表和网页使用服务端QWeb的 Python 实现。看板视图使用客户端JavaScript实现。也就是说看板视图中的QWeb表达式应使用JavaScript语法书写，而不是 Python。</p>
<p>在显示看板视图时，内部的步骤大致如下：</p>
<ol>
<li>获取模板的XML进行渲染</li>
<li>调用服务端read()方法来获取模板中所涉及的字段数据</li>
<li>定位kanban-boxs模板并使用QWeb解析它来输出最终的HTML片断</li>
<li>在浏览器显示(DOM)中注入 HTML</li>
</ol>
<p>以上在技术上并不精确，仅是用于理解看板视图中如何运作的脑图。下面我们将学习QWeb表达式运行并探讨可用的QWeb指令，通过示例改进借阅看板卡片。</p>
<h3 id="QWeb-JavaScript-运行上下文"><a href="#QWeb-JavaScript-运行上下文" class="headerlink" title="QWeb JavaScript 运行上下文"></a>QWeb JavaScript 运行上下文</h3><p>许多QWeb指令使用表达式的运行来生成结果。在看板视图这类客户端的应用中，表达式应使用JavaScript书写。表达式在带有几个有用变量的上下文中进行运行。可用record 对象带有从服务端请求的字段来表示当前记录。字段值可通过raw_value或value属性来获取：</p>
<ul>
<li>raw_value是由服务端read()方法返回的值，因此在条件表达式中更适用</li>
<li>value根据用户设置来格式化，用于在用户界面中的显示。常用于date&#x2F;datetime, float&#x2F;monetary和关联字段。</li>
</ul>
<p>QWeb运行上下文还可在JavaScript网页客户端中引用。要擅用这些需要对网页客户端结构有很好的理解，但这里我们不会进行深入介绍。要进行引用 ，QWeb表达式运行中有以下标识符可以使用：</p>
<ul>
<li>widget是对当前KanbanRecord() 组件对象的引用 ，用于在看板卡片中渲染当前记录。它会暴露一些帮助函数供我们使用。</li>
<li>record是widget.record的简写形式，使用点号标记来提供对可用字段的访问。</li>
<li>read_only_mode表示当前视图是否为读模式（而非编辑模式）。它是widget.view.options.read_only_mode的简写形式。</li>
<li>instance是对全部网页客户端实例的一个引用 。</li>
</ul>
<p>值得一提的是有些字符是不能在表达式中使用的，比如小于号(<code>&lt;</code>) 。这是因为在 XML 标准中，这些字符具有特殊含义，不应在 XML 内容中使用。反向的<code>&gt;=</code>是一个有效替代方式，但通常是使用以下替代符号来进行不等式运算：</p>
<ul>
<li>lt是小于</li>
<li>lte是小于等于</li>
<li>gt是大于</li>
<li>gte是大于等于</li>
</ul>
<blockquote>
<p>ℹ️前述的比较符号仅用于 Odoo，是引入来解决 XML 格式中的限制的。它们不是 XML 标准的一部分。</p>
</blockquote>
<h3 id="字符串替换动态属性–-t-attf"><a href="#字符串替换动态属性–-t-attf" class="headerlink" title="字符串替换动态属性– t-attf"></a>字符串替换动态属性– t-attf</h3><p>我们的看板卡片使用t-attf QWeb指令来为顶级<code>&lt;div&gt;</code>元素动态设置一个类，这样卡片可根据 color 字段值来显示颜色。为此使用了t-attf- QWeb指令。t-attf-指令使用字符串替换动态生成标签属性。这让像 URL 地址或 CSS 类名这类较大字符串中的部分内容可动态生成。</p>
<p>该指令查找表达式代码块进行运行并替换结果。它们通过 或#{和}来进行分隔。代码块的内容可以是任意JavaScript表达式并使用QWeb表达式中的任意可用变量，如record和widget。本例中我们还使用了专门提供的kanban_color() JS 函数，用于映射索引值到类颜色名。</p>
<p>作为一个更复杂的示例，我们使用这个指令来动态生成用户的颜色，红色字体表示优先级很高。下面替换看板卡片中的相应代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;li t-attf-class=&quot;oe_kanban_text_&#123;&#123;</span><br><span class="line">    record.priority.raw_value lt &#x27;2&#x27;</span><br><span class="line">    ? &#x27;black&#x27; : &#x27;red&#x27;&#125;&#125;&quot;&gt;</span><br><span class="line">    &lt;field name=&quot;user_id&quot; /&gt;</span><br><span class="line">&lt;/li&gt;</span><br></pre></td></tr></table></figure>

<p>这将会根据借阅优先级的值生成class&#x3D;”oe_kanban_text_red”或class&#x3D;”oe_kanban_text_black”。请注意看板视图中是有oe_kanban_text_red这个 CSS 类的，但oe_kanban_text_black仅用于演示，实际并不存在。</p>
<blockquote>
<p>ℹ️注意JavaScript表达式中使用的lt符号，是<code>&lt;</code>的转义表达式，并不能在XML中使用。</p>
</blockquote>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bbb868371a0c4abca20de08364d4a513~tplv-k3u1fbpfcp-zoom-1.image" alt="Odoo 12字符串替换动态属性"></p>
<h3 id="表达式动态属性-t-att"><a href="#表达式动态属性-t-att" class="headerlink" title="表达式动态属性 - t-att"></a>表达式动态属性 - t-att</h3><p>t-att- QWeb指令通过运行表达式动态生成属性值。我们的看板卡片中使用它来为<code>&lt;img&gt;</code>标签动态生成属性，title 属性使用以下表达式动态渲染：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">t-att-title=&quot;record.member_id.value&quot;</span><br></pre></td></tr></table></figure>

<p>.value字段返回在屏幕上显示的值。对于many-to-one字段，这通常是相关记录的 name 值。对于用户则是用户名。运行之后在鼠标悬停于图像上时会显示相应的用户名。</p>
<p>在表达式运行的结果值为假时，就不会渲染该属性。这对于特殊的 HTML 属性非常重要，比如 input 字段中的 checked，即便在没有属性值时也会有显示效果。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/84a431fa9e4849ff8c848cc377f2a8ca~tplv-k3u1fbpfcp-zoom-1.image" alt="Odoo 12表达式动态属性 "></p>
<h3 id="循环-t-foreach"><a href="#循环-t-foreach" class="headerlink" title="循环 - t-foreach"></a>循环 - t-foreach</h3><p>通过循环遍历来重复同一 HTML 代码块。我们可使用它来添加记录 follower 的头像。让我们先来仅渲染记录的partner ID：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;t t-foreach=&quot;record.message_partner_ids.raw_value&quot; t-as=&quot;rec&quot;&gt;</span><br><span class="line">    &lt;t t-esc=&quot;rec&quot; /&gt;;</span><br><span class="line">&lt;/t&gt;</span><br></pre></td></tr></table></figure>

<p>t-foreach指令接收一个JavaScript表达式，运行来遍历集合。在大多数情况下，这会是 一个to-many关联字段的名称。与t-as指令一同使用来设置用于引用遍历各项的名称。下面使用的t-esc指令运行所提供的表达式，本处仅为 rec 变量名，将其渲染为已转译的安全 HTML。</p>
<p>在上例中，我们遍历了存储在message_partner_ids 字段中的 follower。因为在看板卡片上的空间有限，我们使用JS 的slice()函数来限定所显示的follower数量，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">t-foreach=&quot;record.message_partner_ids.raw_value.slice(0, 3)&quot;</span><br></pre></td></tr></table></figure>

<p>rec变量存储每个遍历值，本例中为partner ID。这样我们可以将循环改写为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;t t-foreach=&quot;record.message_partner_ids.raw_value.slice(0,3)&quot; t-as=&quot;rec&quot;&gt;</span><br><span class="line">    &lt;img t-att-src=&quot;kanban_image(&#x27;res.partner&#x27;, &#x27;image_small&#x27;, rec)&quot;</span><br><span class="line">        class=&quot;oe_avatar&quot; width=&quot;24&quot; height=&quot;24&quot; alt=&quot;&quot; /&gt;</span><br><span class="line">&lt;/t&gt;</span><br></pre></td></tr></table></figure>

<p>比如可将其添加在右侧 footer 的用户头像旁。还包含一些帮助变量，它们的名称以t_as 中定义的变量名为前缀。本例中使用了rec，因此可用的帮助变量如下：</p>
<ul>
<li>rec_index是迭代索引，从0开始</li>
<li>rec_size是集合中的元素数量</li>
<li>rec_first在迭代的第一个元素中为真</li>
<li>rec_last在迭代的最后一个元素中为真</li>
<li>rec_even在索引为偶数时为真</li>
<li>rec_odd在索引为奇数时为真</li>
<li>rec_parity根据当前索引为odd或even</li>
<li>rec_all表示进行迭代的对象</li>
<li>rec_value在迭代{key:value} 字典时，存储value (rec存储键名)</li>
</ul>
<p>例如可通过如下代码去除ID 列表最后逗号：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;t t-foreach=&quot;record.message_parter_ids.raw_value.slice(0, 3)&quot;</span><br><span class="line">    t-as=&quot;rec&quot;&gt;</span><br><span class="line">    &lt;t t-esc=&quot;rec&quot; /&gt;</span><br><span class="line">    &lt;t t-if=&quot;!rec_last&quot;&gt;;&lt;/t&gt;</span><br><span class="line">&lt;/t&gt;</span><br></pre></td></tr></table></figure>

<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/62b207944c9240ef9580c2e0dd46ae33~tplv-k3u1fbpfcp-zoom-1.image" alt="Odoo 12 循环遍历"></p>
<h3 id="条件判断-t-if"><a href="#条件判断-t-if" class="headerlink" title="条件判断 - t-if"></a>条件判断 - t-if</h3><p>我们的看板视图在卡片选项菜单中使用了t-if指令来根据不同条件显示不同选项。t-if指令在客户端渲染看板视图时需传入在 JS 中运行的表达式。标签和其内容仅在条件运行值为true 时才会渲染。作为示例，仅在借出有值时显示图书借出数量，在request_date字段后加入如下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;t t-if=&quot;record.num_books.raw_value gt 0&quot;&gt;</span><br><span class="line">    &lt;li&gt;&lt;field name=&quot;num_books&quot; /&gt; books&lt;/li&gt;</span><br><span class="line">&lt;/t&gt;</span><br></pre></td></tr></table></figure>

<p>我们使用了<code>&lt;t t-if=&quot;...&quot;&gt;</code>元素，这样在条件为 false 时，元素不会有任何输出。在为 true 时，仅会渲染其所包含的<code>&lt;li&gt;</code>元素来进行输出。注意条件表达式中使用gt符号来替代<code>&gt;</code>以表示大于运算符。可通过t-elif和t-else来支持else if和else条件语句，使用示例如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;t t-if=&quot;record.num_books.raw_value == 0&quot;&gt;</span><br><span class="line">    &lt;li&gt;No books.&lt;/li&gt;</span><br><span class="line">&lt;/t&gt;</span><br><span class="line">&lt;t t-elif=&quot;record.num_books.raw_value gt 9&quot;&gt;</span><br><span class="line">    &lt;li&gt;A lot of books!&lt;/li&gt;</span><br><span class="line">&lt;/t&gt;</span><br><span class="line">&lt;t t-else=&quot;&quot;&gt;</span><br><span class="line">    &lt;li&gt;&lt;field name=&quot;num_books&quot; /&gt; books.&lt;/li&gt;</span><br><span class="line">&lt;/t&gt;</span><br></pre></td></tr></table></figure>

<p>Javascript表达式中，AND和OR的运算符分别为&amp;&amp;和 ||。但在 XML 中不支持&amp;符号，我们可以使用 and 和 or 运算符来规避这一问题。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dd2823f9036f4465a39c5e956b743fd9~tplv-k3u1fbpfcp-zoom-1.image" alt="Odoo 12 QWeb 条件判断"></p>
<h3 id="渲染值-t-esc和t-raw"><a href="#渲染值-t-esc和t-raw" class="headerlink" title="渲染值 - t-esc和t-raw"></a>渲染值 - t-esc和t-raw</h3><p>我们使用了<code>&lt;field&gt;</code>元素来渲染值，但也可以无需<code>&lt;field&gt;</code>标签直接显示字段值。t-esc指令运行表达式并将其渲染为转义后的 HTML 值，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;t t-esc=&quot;record.message_partner_ids.raw_value&quot; /&gt;</span><br></pre></td></tr></table></figure>

<p>有些情况下，如果确定源数据是安全的，可以无需转义使用t-raw 来渲染原始值，如下例所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;t t-raw=&quot;record.message_partner_ids.raw_value&quot; /&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>小贴士：</strong> 出于安全考虑，应尽量避免使用t-raw。它应严格用于输出特别准备不包含用户数据的HTML 数据，或者是已明确对 HTML 特殊字符转义的用户数据。</p>
</blockquote>
<h3 id="为变量设置值-t-set"><a href="#为变量设置值-t-set" class="headerlink" title="为变量设置值 - t-set"></a>为变量设置值 - t-set</h3><p>对于更复杂的逻辑，我们可以将表达式结果存储在变量中，在模板中随后使用。这通过t-set指令来实现，它设置变量名，紧接着使用t-value指令来添加表达式计算分配的值。作为示例，以下代码将优先级较高的和前面一节一样渲染为红色，但使用red_or_black 变量来作为 CSS 类使用的变量，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;t t-set=&quot;red_or_black&quot;</span><br><span class="line">    t-value=&quot;record.priority.raw_value gte &#x27;2&#x27; ? &#x27;oe_kanban_text_red&#x27; :&#x27;&#x27;&quot; /&gt;</span><br><span class="line">&lt;li t-att-class=&quot;red_or_black&quot;&gt;</span><br><span class="line">    &lt;field name=&quot;user_id&quot; /&gt;</span><br><span class="line">&lt;/li&gt;</span><br></pre></td></tr></table></figure>

<p>变量中也可分配 HTML内容，示例如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;t t-set=&quot;calendar_sign&quot;&gt;</span><br><span class="line">    &lt;i class=&quot;fa fa-calendar&quot; /&gt;</span><br><span class="line">&lt;/t&gt;</span><br><span class="line">&lt;t t-raw=&quot;calendar_sign&quot; /&gt;</span><br></pre></td></tr></table></figure>

<p> </p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/30566f47384743f99269d8d535f13e98~tplv-k3u1fbpfcp-zoom-1.image" alt="Odoo 12为变量设置值"></p>
<h3 id="调用和复用其它模板-t-call"><a href="#调用和复用其它模板-t-call" class="headerlink" title="调用和复用其它模板 - t-call"></a>调用和复用其它模板 - t-call</h3><p>QWeb模板可作为可复用的 HTML 片段插入到其它模板中。我们无需重复相同的 HTML 代码块，可以设计构成部分来组成更为复杂的用户界面视图，可复用的模板在<code>&lt;templates&gt;</code>标签中定义，通过顶级元素中 kanban-box 以外的 t-name值进行标识。这些模板可通过t-call来进行包含，在当前看板视图、相同模块的其它地方以及其它插件模块中均可。</p>
<p>follower头像列表可以通过可复用代码段来进行分离，下面通过子模板重写代码。首先应在 XML 文件中添加另一个模板，在<code>&lt;templates&gt;</code>元素内，<code>&lt;t t-name=&quot;kanban-box&quot;&gt;</code>节点之后，添加如下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;t t-name=&quot;follower_avatars&quot;&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;t t-foreach=&quot;record.message_partner_ids.raw_value.slice(0,3)&quot;</span><br><span class="line">            t-as=&quot;rec&quot;&gt;</span><br><span class="line">            &lt;img t-att-src=&quot;kanban_image(&#x27;res.partner&#x27;, &#x27;image_small&#x27;, rec)&quot;</span><br><span class="line">                class=&quot;oe_avatar&quot; width=&quot;24&quot; height=&quot;24&quot; alt=&quot;&quot; /&gt;</span><br><span class="line">        &lt;/t&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/t&gt;</span><br></pre></td></tr></table></figure>

<p>在kanban-box主模板调用它就简单明了了，将原来包含 for each 指令的<div>元素修改为如下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;t t-call=&quot;follower_avatars&quot; /&gt;</span><br></pre></td></tr></table></figure>

<p>调用其它插件模块中定义的模板，和视图类似，我们需要使用完整的module.name标识符。比如，以上代码片断可使用library_checkout.follower_avatars完整标识符来进行引用 。调用的模板和调用者运行在同一上下文中，所以调用方中的变量名在处理调用模板时同样可用。</p>
<p>一种更优雅的实现方式是向调用模板传递参数，这通过在 t-call 标签中设置变量来完成。这些仅在子模板上下文中运行和使用，在调用方上下文中并不存在。我们将使用这个方法来让调用方设置follower 头像的最大数，而不是在子模板中硬编码。首先，我们将原固定值3修改为一个变量 arg_max：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;t t-name=&quot;follower_avatars&quot;&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;t t-foreach=&quot;record.message_partner_ids.raw_value.slice(0, arg_max)&quot;</span><br><span class="line">            t-as=&quot;rec&quot;&gt;</span><br><span class="line">            &lt;img t-att-src=&quot;kanban_image(&#x27;res.partner&#x27;, &#x27;image_small&#x27;, rec)&quot;</span><br><span class="line">                class=&quot;oe_avatar&quot; width=&quot;24&quot; height=&quot;24&quot; alt=&quot;&quot; /&gt;</span><br><span class="line">        &lt;/t&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/t&gt;</span><br></pre></td></tr></table></figure>

<p>然后像下面这样在执行子模板调用时定义该变量：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;t t-call=&quot;follower_avatars&quot;&gt;</span><br><span class="line">    &lt;t t-set=&quot;arg_max&quot; t-value=&quot;3&quot; /&gt;</span><br><span class="line">&lt;/t&gt;</span><br></pre></td></tr></table></figure>

<p>t-call元素内的整个内容可通过0（数字零）这个魔法变量在子模板中使用。不使用参数变量，我们还可以定义代码片断并在子模板中通过<code>&lt;t t-raw=&quot;0&quot; /&gt;</code>使用。这对以模块化的方式创建布局、合并&#x2F;嵌套 QWeb 模板尤为有用。</p>
<h3 id="字典和列表动态属性"><a href="#字典和列表动态属性" class="headerlink" title="字典和列表动态属性"></a>字典和列表动态属性</h3><p>我们已经学习最重要的那些QWeb指令，但还有一部分我们也应该了解。下面简短地进行讲解。</p>
<p>前面我们看到t-att-NAME和t-attf-NAME样式的动态标签属性，此外还可以使用固定的t-att指令。它接收键值对字典或pair（两个元素的列表）。</p>
<p>使用如下映射：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;p t-att=&quot;&#123;&#x27;class&#x27;: &#x27;oe_bold&#x27;, &#x27;name&#x27;: &#x27;Hello&#x27;&#125;&quot; /&gt;</span><br></pre></td></tr></table></figure>

<p>将生成如下结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;p class=&quot;oe_bold&quot; name=&quot;Hello&quot; /&gt;</span><br></pre></td></tr></table></figure>

<p>使用如下 pair：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;p t-att=&quot;[&#x27;class&#x27;, &#x27;oe_bold&#x27;]&quot; /&gt;</span><br></pre></td></tr></table></figure>

<p>将生成如下结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;p class=&quot;oe_bold&quot; /&gt;</span><br></pre></td></tr></table></figure>

<h2 id="看板视图的继承"><a href="#看板视图的继承" class="headerlink" title="看板视图的继承"></a>看板视图的继承</h2><p>看板视图和报表中使用的模板可通过视图相同的常规方法来进行继承，例如，使用XPath表达式，参见第四章 <a target="_blank" rel="noopener" href="https://alanhou.org/odoo12-extending-modules/">Odoo 12 开发之模块继承</a>。</p>
<p>常见的情况是使用<code>&lt;field&gt;</code>元素作为选择器，然后在其前或后添加其它元素。对于看板视图，同一字段可声明多次，例如在模板前和模板内分别声明。这时，选择器将匹配第一个字段元素，不会将修改我们希望修改的模板内的字段。要规避这一问题，我们需使用XPath来确保匹配的是模板内的字段，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;record id=&quot;res_partner_kanban_inherit&quot; model=&quot;ir.ui.view&quot;&gt;</span><br><span class="line">	&lt;field name=&quot;name&quot;&gt;Contact Kanban modification&lt;/field&gt;</span><br><span class="line">	&lt;field name=&quot;model&quot;&gt;res.partner&lt;/field&gt;</span><br><span class="line">	&lt;field name=&quot;inherit_id&quot; ref=&quot;base.res_partner_kanban_view&quot; /&gt;</span><br><span class="line">	&lt;field name=&quot;arch&quot; type=&quot;xml&quot;&gt;</span><br><span class="line">		&lt;xpath expr=&quot;//t[@t-name=&#x27;kanban-box&#x27;]//field[@name=&#x27;display_name&#x27;]&quot;</span><br><span class="line">			position=&quot;before&quot;&gt;</span><br><span class="line">			&lt;span&gt;Name:&lt;/span&gt;</span><br><span class="line">		&lt;/xpath&gt;</span><br><span class="line">	&lt;/field&gt;</span><br><span class="line">&lt;/record&gt;</span><br></pre></td></tr></table></figure>

<p>在上例中，XPath 查找<code>&lt;t t-name=&quot;kanban-box&quot;&gt;</code>元素内的<code>&lt;field name=&quot;display_name&quot;&gt;</code>元素。这条规则会排除掉<code>&lt;templates&gt;</code>版块之外的相同字段元素。对于更 复杂的XPath表达式，我们可以使用命令行工具来研究出正确的语法。你的 Linux 系统中可能已有安装了xmllint工具（sudo apt install libxml2-utils），它有一个–xpath 选项可对 XML 文件执行查询。</p>
<p>另一个输出更好看的选项是Debian&#x2F;Ubuntu包中的libxml-xpath-perl，带有一个xpath 命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get install libxml-xpath-perl</span><br><span class="line">$ xpath -e &quot;//record[@id=&#x27;res_partner_kanban_view&#x27;]&quot; -e &quot;//field[@name=&#x27;display_name&#x27;]]&quot; /path/to/myfile.xml</span><br></pre></td></tr></table></figure>

<h2 id="自定义-CSS-和-JavaScript"><a href="#自定义-CSS-和-JavaScript" class="headerlink" title="自定义 CSS 和 JavaScript"></a>自定义 CSS 和 JavaScript</h2><p>如前所见，看板视图大多数为 HTML 并重度使用了 CSS 类。我们介绍了标准产品中提供的一些常用 CSS 类，但要实现最佳效果，我们还可以为模块添加自己的 CSS。我们这里不会详细讲解 CSS 代码的写法，但相应地需要讲解如何为模块添加自己的 CSS (JavaScript)这些前端资源。Odoo 中后台的前端资源在assets_backend模块中声明。要在模块中添加前端资源，需要对模块进行继承。进行这一操作的 XML 文件通常放在views&#x2F; 模块子目录内。</p>
<p>以下是在library_checkout模块中添加一个 CSS 和 JavaScript文件的示例，对应文件为library_checkout&#x2F;views&#x2F;checkout_kanban_assets.xml：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;odoo&gt;</span><br><span class="line">    &lt;template id=&quot;assets_backend&quot; inherit_id=&quot;web.assets_backend&quot;</span><br><span class="line">        name=&quot;Library Checkout Kanban Assets&quot;&gt;</span><br><span class="line">        &lt;xpath expr=&quot;.&quot; position=&quot;inside&quot;&gt;</span><br><span class="line">            &lt;link rel=&quot;stylesheet&quot;</span><br><span class="line">                href=&quot;/library_checkout/static/src/css/checkout_kanban.css&quot; /&gt;</span><br><span class="line">            &lt;script type=&quot;text/javascript&quot;</span><br><span class="line">                src=&quot;/library_checkout/static/src/js/checkout_kanban.js&quot;&gt;</span><br><span class="line">            &lt;/script&gt;</span><br><span class="line">        &lt;/xpath&gt;</span><br><span class="line">    &lt;/template&gt;</span><br><span class="line">&lt;/odoo&gt;</span><br></pre></td></tr></table></figure>

<p>和平常一样，需要在__manifest__.py描述文件中对其进引用，注意这些前端文件放在&#x2F;static&#x2F;src 子目录中，这不是强制要求，但是约定俗成如此。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我们学习了看板和如何创建看板视图来实现这些看板。我们还介绍了QWeb模板以及使用它来设计看板卡片。QWeb同时还是 CMS 网站的渲染引擎，因此它在 Odoo 工具集中的重要性越来越高。</p>
<p>看板视图可通过其它视图中使用的相同XML语法来进行继承。看板的 XML 结构可能会更为复杂，我们经常需要使用XPath表达式来定义需继承的元素。</p>
<p>最后，高级看板视图可以使用独有的 CSS 和 JavaScript 文件。可作为模块文件来进行添加，然后应在web.assets_backend QWeb模板中添加这些文件，以在客户端页面中包含。</p>
<p>在下一篇文章中，我们将继续使用QWeb，但是是在服务端创建自定义报表 。</p>
<p> </p>
<p>☞☞☞第十二章 <a target="_blank" rel="noopener" href="https://alanhou.org/odoo12-reports-qweb/">Odoo 12开发之报表和服务端 QWeb</a></p>
<p> </p>
<h2 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h2><p>以下参考材料是对本文所学习课题的补充：</p>
<ul>
<li>Odoo<a target="_blank" rel="noopener" href="https://www.odoo.com/documentation/12.0/reference/qweb.html">官方文档</a>QWeb的介绍</li>
<li>Bootstrap<a target="_blank" rel="noopener" href="https://getbootstrap.com/docs/4.1/getting-started/introduction/">样式文档</a></li>
<li>Font Awesome<a target="_blank" rel="noopener" href="https://fontawesome.com/v4.7.0/icons/">图标索引</a></li>
</ul>
<p> </p>
<p>☞☞☞第十一章 <a target="_blank" rel="noopener" href="https://alanhou.org/odoo12-kanban-qweb/">Odoo 12开发之看板视图和用户端 QWeb</a></p>
<p> </p>
<h2 id="扩展阅读-1"><a href="#扩展阅读-1" class="headerlink" title="扩展阅读"></a>扩展阅读</h2><p>以下本文中所讨论的话题的附加参考和补充材料：</p>
<ul>
<li><p>Odoo 官方文档</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.odoo.com/documentation/12.0/reference/actions.html">有关actions</a></li>
<li><a target="_blank" rel="noopener" href="https://www.odoo.com/documentation/12.0/reference/views.html">有关视图</a></li>
</ul>
</li>
<li><p>Font Awesome<a target="_blank" rel="noopener" href="https://fontawesome.com/v4.7.0/icons/">图标索引</a></p>
</li>
</ul>
<p>本文首发地址：<a target="_blank" rel="noopener" href="https://alanhou.org/developer-mode-odoo12/">Alan Hou 的个人博客</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://alanhou.github.io/2019/01/17/odoo-essentials-12-chapter10/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Alan Hou">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Alan Hou的个人博客">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Alan Hou的个人博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2019/01/17/odoo-essentials-12-chapter10/" class="post-title-link" itemprop="url">第十章 Odoo 12开发之后台视图 – 设计用户界面</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2019-01-17 00:00:00" itemprop="dateCreated datePublished" datetime="2019-01-17T00:00:00+08:00">2019-01-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2023-02-03 13:46:26" itemprop="dateModified" datetime="2023-02-03T13:46:26+08:00">2023-02-03</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>本文为<a target="_blank" rel="noopener" href="https://alanhou.org/odoo-12-development/">最好用的免费ERP系统Odoo 12开发手册</a>系列文章第十篇。</p>
<p>本文将学习如何为用户创建图形化界面来与图书应用交互。我们将了解不同视图类型和小组件(widgets)之间的差别，以及如何使用它们来提供更优的用户体验。</p>
<p>本文主要内容有：</p>
<ul>
<li>菜单项</li>
<li>窗口操作(Window Actions)</li>
<li>表单视图结构</li>
<li>字段</li>
<li>按钮和智能按钮</li>
<li>动态视图元素</li>
<li>列表视图</li>
<li>搜索视图</li>
<li>其它视图类型</li>
</ul>
<h2 id="开发准备"><a href="#开发准备" class="headerlink" title="开发准备"></a>开发准备</h2><p>我们将继续使用library_checkout插件模块，它已经有了模型层，现在需要视图层来实现用户界面。本文中的代码基于第八章 <a target="_blank" rel="noopener" href="https://alanhou.org/odoo12-business-logic/">Odoo 12开发之业务逻辑 - 业务流程的支持</a>，相关代码请参见 <a target="_blank" rel="noopener" href="https://github.com/alanhou/odoo12-development/tree/master/chapter8">GitHub 仓库</a>，本章完成后代码也请参见 <a target="_blank" rel="noopener" href="https://github.com/alanhou/odoo12-development/tree/master/chapter10">GitHub仓库</a>。</p>
<h2 id="菜单项"><a href="#菜单项" class="headerlink" title="菜单项"></a>菜单项</h2><p>用户界面的入口是菜单项，菜单项形成一个层级结构，最顶级项为应用，其下一级为每个应用的主菜单。还可以添加更深的子菜单。可操作菜单与窗口操作关联，它告诉客户端在点击了菜单项后应执行什么操作。</p>
<p>菜单项存储在ir.ui.menu模型中，可通过Settings &gt; Technical &gt; User Interface &gt; Menu Items菜单进行查看。</p>
<p>library_app模块为图书创建了一个顶级菜单，library_checkout插件模块添加了借阅和借阅阶段的菜单项。在library_checkout&#x2F;views&#x2F;library_menu.xml文件中，借阅的菜单项 XML 代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;menuitem id=&quot;menu_library_checkout&quot;</span><br><span class="line">    name=&quot;Checkout&quot;</span><br><span class="line">    action=&quot;action_library_checkout&quot;</span><br><span class="line">    parent=&quot;library_app.menu_library&quot; /&gt;</span><br></pre></td></tr></table></figure>

<p>这里有一个<menuitem>快捷元素，提供了一种定义菜单项的简写方式，比原生的<record model="ir.ui.view">元素要更为便捷。以上使用的属性有：</p>
<ul>
<li>name是展示在用户界面中的菜单项标题</li>
<li>action是点击菜单项时运行的窗口操作的XML ID</li>
<li>parent是父级菜单项的XML ID。本例中父级项由其它模块创建，因此们使用了完整的XML ID, <module>.<XML ID>进行引用。</li>
</ul>
<p>还有以下可用属性：</p>
<ul>
<li>sequence设置一个数字来在展示菜单项时进行排序，如sequence&#x3D;”10”</li>
<li>groups是一个逗号分隔的可访问菜单项安全组的XML ID列表，如groups&#x3D;”library_app.library_group_user, library_app.library_group_manager”</li>
<li>web_icon是菜单项的图标，仅用于企业版的顶级菜单项，如web_icon&#x3D;”library_app,static&#x2F;description&#x2F;icon.png”</li>
</ul>
<h2 id="窗口操作-Window-Actions"><a href="#窗口操作-Window-Actions" class="headerlink" title="窗口操作(Window Actions)"></a>窗口操作(Window Actions)</h2><p>窗口操作给 GUI（图形化用户界面）客户端操作指令，通常用于菜单项或视图中的按钮。它告诉 GUI 所作用的模型以及要显示的视图。这些操作可以通过域过滤器过滤出可用记录，设置默认值以及从上下文属性中过滤。窗口操作存储在ir.actions.act_window模型中，可通过Settings &gt; Technical &gt; Actions &gt; Window Actions菜单进行查看。</p>
<p>在library_checkout&#x2F;views&#x2F;library_menu.xml文件中，我们可以找到借阅菜单项中使用的窗口操作，我们需要对其进行修改来启用本文中将添加的视图类型：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;act_window id=&quot;action_library_checkout&quot;</span><br><span class="line">    name=&quot;Checkouts&quot;</span><br><span class="line">    res_model=&quot;library.checkout&quot;</span><br><span class="line">    view_mode=&quot;tree,form,activity,calendar,graph,pivot&quot; /&gt;</span><br></pre></td></tr></table></figure>

<p>窗口操作通常像以上这样使用<act_window>快捷标签创建。这里修改”tree, form”为更大的列表”tree, form, activity, calendar, graph, pivot”。以上使用的窗口操作属性有：</p>
<ul>
<li>name是通过操作打开的视图中显示的标题</li>
<li>res_model是目标模型的标识符</li>
<li>view_mode是一个逗号分隔的可用视图类型列表。第一项为默认打开时的视图。</li>
</ul>
<p>窗口操作还有一些其它属性：</p>
<ul>
<li>target：如果设置为 new,会在弹出的对话框窗口中打开视图，例如target&#x3D;”new”。默认值是current，在主内容区行内打开视图。</li>
<li>context：为目标视图设置上下文信息，可设置默认值或启用过滤器等，例如context&#x3D;”{‘default_user_id’: uid}”。</li>
<li>domain：是对可在打开视图中浏览的记录强制过滤的域表达式，例如domain&#x3D;”[(‘user_id’, ‘&#x3D;’, uid)]”。</li>
<li>limit：列表视图中每页显示的记录数，例如limit&#x3D;”80”。</li>
</ul>
<p>做了这些修改后，在选择Checkouts菜单项并浏览相应的列表视图时，右上角在列表和表单按钮后会增加一些按钮。但在我们创建对应视图前并不能使用，本文将一一学习。窗口操作还可在列表和表单视图的上方的 Action 菜单按钮中使用，它在 Fitlers 按钮旁。要使用这个，我们需要在元素中添加以下两个属性：</p>
<ul>
<li>src_model设置Action所作用的模型，例如src_model&#x3D;”library.checkout”</li>
<li>multi&#x3D;”true”也启用列表视图中的Action，这样它可以作用于多个已选记录。否则仅在表单视图中可用，并且一次只能应用于一条记录。</li>
</ul>
<p>补充：此时打开借阅表单会提示Insufficient fields for Calendar View!，在编写日历视图前最好选视图模式里删除 calendar 来进行效果查看</p>
<h2 id="表单视图结构"><a href="#表单视图结构" class="headerlink" title="表单视图结构"></a>表单视图结构</h2><p>表单视图要么按照简单布局，要么按与纸质文档相似的业务文档布局。我们将学习如何设计这些业务文档布局以及使用可用的元素和组件。要进行这一学习，我们重新查看并扩展第八章 <a target="_blank" rel="noopener" href="https://alanhou.org/odoo12-business-logic/">Odoo 12开发之业务逻辑 - 业务流程的支持</a>中创建的图书借阅表单。</p>
<h3 id="业务文档视图"><a href="#业务文档视图" class="headerlink" title="业务文档视图"></a>业务文档视图</h3><p>业务应用中记录的很多数据可以按纸质文档那样展示。表单视图可模仿这些纸质文档来提供更直观的用户界面。例如，在我们的应用中，可以把一次借阅看作填写一张纸，我们将编写一个遵循这一设计的表单视图。编辑library_checkout&#x2F;views&#x2F;chceckout_view.xml文件并修改表单视图记录来带有业务文档视图的基本框架：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">    &lt;record id=&quot;view_form_checkout&quot; model=&quot;ir.ui.view&quot;&gt;</span><br><span class="line">        &lt;field name=&quot;model&quot;&gt;library.checkout&lt;/field&gt;</span><br><span class="line">        &lt;field name=&quot;arch&quot; type=&quot;xml&quot;&gt;</span><br><span class="line">            &lt;form&gt;</span><br><span class="line">                &lt;header&gt;</span><br><span class="line">                    &lt;!--以下仅供查看效果使用--&gt;</span><br><span class="line">                    &lt;field name=&quot;state&quot; widget=&quot;statusbar&quot; clickable=&quot;True&quot; /&gt;</span><br><span class="line">                &lt;/header&gt;</span><br><span class="line">                &lt;sheet&gt;</span><br><span class="line">...</span><br><span class="line">                &lt;/sheet&gt;</span><br><span class="line">                &lt;div class=&quot;oe_chatter&quot;&gt;</span><br><span class="line">                    &lt;field name=&quot;message_follower_ids&quot; widget=&quot;mail_followers&quot; /&gt;</span><br><span class="line">                    &lt;field name=&quot;activity_ids&quot; widget=&quot;mail_activity&quot; /&gt;</span><br><span class="line">                    &lt;field name=&quot;message_ids&quot; widget=&quot;mail_thread&quot; /&gt;</span><br><span class="line">                &lt;/div&gt;</span><br><span class="line">            &lt;/form&gt;</span><br><span class="line">        &lt;/field&gt;</span><br><span class="line">    &lt;/record&gt;</span><br></pre></td></tr></table></figure>

<p>视图名称是可选的，在不写时会自动生成。为简便以上利用了这一点，在视图记录中省略了<field name="name">元素。可以看到业务文件视图通常使用三大区域：</p>
<ul>
<li>header状态栏</li>
<li>sheet主内容</li>
<li>底部交流区，也称作chatter</li>
</ul>
<p>底部的交流区使用了 mail 插件模块中提供的社交网络组件。可使用这些，我们的模型需要继承mail.thread和mail.activity.mixin，可参见第八章 <a target="_blank" rel="noopener" href="https://alanhou.org/odoo12-business-logic/">Odoo 12开发之业务逻辑 - 业务流程的支持</a>。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5847c21dca184538a932d12d9d96e2cc~tplv-k3u1fbpfcp-zoom-1.image" alt="Odoo 12文档视图"></p>
<h3 id="头部-Header"><a href="#头部-Header" class="headerlink" title="头部 Header"></a>头部 Header</h3><p>头部header 通常用于文档所走过的生命周期或步骤，还包含相关的操作按钮。这些按钮是普通表单按钮，最重要的下一步可以高亮显示。</p>
<h3 id="头部按钮"><a href="#头部按钮" class="headerlink" title="头部按钮"></a>头部按钮</h3><p>编辑表单视图中的<header>版块，我们添加一个按钮来更易于设置归还的借阅为完成(done)：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;header&gt;</span><br><span class="line">    &lt;field name=&quot;state&quot; invisible=&quot;True&quot; /&gt;</span><br><span class="line">    &lt;button name=&quot;button_done&quot;</span><br><span class="line">        string=&quot;Return Books&quot;</span><br><span class="line">        attrs=&quot;&#123;&#x27;invisible&#x27;:</span><br><span class="line">            [(&#x27;state&#x27;, &#x27;in&#x27;, [&#x27;new&#x27;, &#x27;done&#x27;])]&#125;&quot;</span><br><span class="line">        class=&quot;oe_highlight&quot; /&gt;</span><br><span class="line">&lt;/header&gt;</span><br></pre></td></tr></table></figure>

<p>这里我们在头部添加了一个Return Books 按钮，在点击时调用button_done模型方法。注意可使用class&#x3D;”oe_highlight”来对用户高亮显示操作。例如，在有几个可选按钮时，我们可以高亮显示主操作或下一步要执行的“更多”操作。attrs用于在 New 和 Done 状态时隐藏该按钮。实现这点的条件使用了不会在表单显示的 state 字段。要使条件生效，我们需要将使用的所有值在网页客户端中加载。我们不打算向终端用户显示 state 字段，因此使用 invisible 将其添加为不可见字段。</p>
<blockquote>
<p>ℹ️domain 或 attrs 表达式中使用的字段必须在视图中加载，作用于它们的<field>元素。如果字段不对用户可见，则必须以不可见字段元素对其进行加载。</p>
</blockquote>
<p>本例中我们使用的是 state 字段，相同的效果可通过 states 字段属性实现。虽然没有 attrs 属性灵活，但它更为精简。可将 attrs 一段替换为如下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;button name=&quot;button_done&quot;</span><br><span class="line">    type=&quot;object&quot;</span><br><span class="line">    string=&quot;Returned&quot;</span><br><span class="line">    states=&quot;open,cancel&quot;</span><br><span class="line">    class=&quot;oe_highlight&quot; /&gt;</span><br></pre></td></tr></table></figure>

<p>attrs和states元素可见功能也可用于其它视图元素，如 field。本文后续会深入讨论。要让按钮可以运作，我们还需要实现调用的方法。在library_checkout&#x2F;models&#x2F;library_checkout.py file文件的借阅类里添加以下方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">def button_done(self):</span><br><span class="line">    Stage = self.env[&#x27;library.checkout.stage&#x27;]</span><br><span class="line">    done_stage = Stage.search(</span><br><span class="line">        [(&#x27;state&#x27;, &#x27;=&#x27;, &#x27;done&#x27;)],</span><br><span class="line">        limit=1)</span><br><span class="line">    for checkout in self:</span><br><span class="line">        checkout.stage_id = done_stage</span><br><span class="line">    return True</span><br></pre></td></tr></table></figure>

<p>该方法首先查找 done 阶段的记录来使用，然后对 self 记录集中的每条记录，设置其 stage_id 值为完成阶段。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6b7cf8c4e92748ac9980a00ab0047240~tplv-k3u1fbpfcp-zoom-1.image" alt="Odoo 12高亮显示按钮"></p>
<h3 id="阶段管道"><a href="#阶段管道" class="headerlink" title="阶段管道"></a>阶段管道</h3><p>下面我们为头部添加状态条组件，显示文档所在阶段。从代码层面说，是使用statusbar组件的stage_id字段的<field>元素:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">                &lt;header&gt;</span><br><span class="line">...</span><br><span class="line">                    &lt;field name=&quot;stage_id&quot;</span><br><span class="line">                        widget=&quot;statusbar&quot;</span><br><span class="line">                        clickable=&quot;True&quot;</span><br><span class="line">                        options=&quot;&#123;&#x27;fold_field&#x27;: &#x27;fold&#x27;&#125;&quot; /&gt;</span><br><span class="line">                &lt;/header&gt;</span><br></pre></td></tr></table></figure>

<p>这会在头部添加一个阶段管道组件，它在表示文档当前所在生命周期点的字段上使用了statusbar组件。通常是一个状态选项字段或阶段many-to-one字段。这两类字段在 Odoo 核心模块中多次出现。clickable属性让用户可通过点击状态条来修改文档阶段。一般需要开启它，但有时又不需要，比如需要对工作进行更强的控制，并且要求用户仅使用可用的操作按钮来进入下一步。这种方法允许在切换阶段时进行指定验证。</p>
<p>对阶段使用状态条组件时，我们可将很少使用的阶段隐藏(折叠)在 More 阶段组中。对应的阶段模型必须要有一个标记来配置需隐藏的阶段，通常命名为 fold。然后statusbar组件使用 options 属性来将这一字段名提供给fold_field选项，如以上代码所示。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b4d717160ef84b2eaa77c0738d0804b9~tplv-k3u1fbpfcp-zoom-1.image" alt="Odoo 12阶段折叠"></p>
<h3 id="使用状态代替阶段"><a href="#使用状态代替阶段" class="headerlink" title="使用状态代替阶段"></a>使用状态代替阶段</h3><p>阶段是一个使用了模型来设置进度步骤的many-to-one字段。因此终端用户可对其动态配置来符合他们具体的业务流程以及支持看板的完美展示。我们将在图书借阅中使用到state。</p>
<p>状态是一个包含了流程中相当稳定步骤的选择列表，如新建、处理中和完成。终端用户无法对其进行配置，因为它是静态的，更易于在业务逻辑中使用。视图字段对状态甚至还有特别的支持：状态字段属性仅在记录处理特定状态才对用户开放。</p>
<blockquote>
<p>ℹ️阶段引入的时间要晚于状态。两者现在共存，在 Odoo 内核的趋势是使用阶段来替代状态。但如前所述，状态仍提供一些阶段所不具备的功能。</p>
</blockquote>
<p>可通过将阶段映射到状态中来同时获得两者的优势。在借阅模型中我们通过向借阅阶段中添加一个状态字段来实现，借阅文档通过一个关联字段来使用状态。使用状态代替阶段的模型中，我们也可以使用进度条管道。这种情况下要在进度条中列出状态，需要使用statusbar_visible属性来替换fold_field选项。具体代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;field name=&quot;state&quot;</span><br><span class="line">    widget=&quot;statusbar&quot;</span><br><span class="line">    clickable=&quot;True&quot;</span><br><span class="line">    statusbar_visible=&quot;draft,open,done&quot; /&gt;</span><br></pre></td></tr></table></figure>

<p>注意在我们实际的图书借阅项目中并不能这么使用，因为它是阶段驱动的，而非状态驱动。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cebbcfc39e494c31be17ff4f6d3b7120~tplv-k3u1fbpfcp-zoom-1.image" alt="Odoo 12状态"></p>
<h3 id="文档表单"><a href="#文档表单" class="headerlink" title="文档表单"></a>文档表单</h3><p>表单画布是表单的主区域，这里放置实际的数据元素，设计上类似一张真实的纸质文档，通常 Odoo 中的这些记录也会被称为文档。通常文档表单结构包含如下区域：</p>
<ul>
<li>左上角文档标题和副标题</li>
<li>右上角按钮区</li>
<li>其它文档头部字段</li>
<li>底部笔记区，将附加字段组织成选项卡或页面</li>
</ul>
<p>文档各行通常在笔记区的第一页，在表单之后，通常有一个 chatter 组件，带有文档订阅者、讨论消息和活动规划。下面逐一了解这些区域。</p>
<p>补充：关于sheet的翻译Alan的理解sheet 仅为单(据)，但出于行文习惯一律使用表单</p>
<h4 id="标题和副标题"><a href="#标题和副标题" class="headerlink" title="标题和副标题"></a>标题和副标题</h4><p>一个元素之外的字段不会自动带有渲染它们的标签。对于标题元素就是如此，因此该元素应用来对其进行渲染。虽然要花费额外的工作量，但这样的好处是对标签显示控制有更好的灵活性。常规 HTML，包括 CSS 样式元素，可用于美化标题。一般标题放在oe_title类中。以下为扩展后的<sheet>元素，它包含标题以及一些额外字段如副标题：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;sheet&gt;</span><br><span class="line">    &lt;field name=&quot;member_image&quot; widget=&quot;image&quot; class=&quot;oe_avatar&quot; /&gt;</span><br><span class="line">    &lt;div class=&quot;oe_title&quot;&gt;</span><br><span class="line">        &lt;label for=&quot;member_id&quot; class=&quot;oe_edit_only&quot; /&gt;</span><br><span class="line">        &lt;h1&gt;&lt;field name=&quot;member_id&quot; /&gt;&lt;/h1&gt;</span><br><span class="line">        &lt;h3&gt;</span><br><span class="line">            &lt;span class=&quot;oe_read_only&quot;&gt;By &lt;/span&gt;</span><br><span class="line">            &lt;label for=&quot;user_id&quot; class=&quot;oe_edit_only&quot; /&gt;</span><br><span class="line">            &lt;field name=&quot;user_id&quot; class=&quot;oe_inline&quot; /&gt;</span><br><span class="line">        &lt;/h3&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;!-- More elements will be added from here... --&gt;</span><br><span class="line">&lt;/sheet&gt;</span><br></pre></td></tr></table></figure>

<p>此处可以看到我们使用了div, span, h1和h3这些常规 HTML 元素。<label>元素让我们可以控制字段标签在何时何处显示。for 属性标识了获取标签文件的字段。也可以使用 string 属性来为标签提供具体的文本。本例中还使用了class&#x3D;”oe_edit_only”属性让其仅在编辑模式下可用。</p>
<p>我们还可在表单左上角标题旁包含展示图像。它用在 parnter 或产品这类模型的表单视图中。作为示例，我们在标题区前添加了一个member_image字段，它使用图像组件widget&#x3D;”image”，以及特定的 CSS 类class&#x3D;”oe_avatar”。该字段尚未添加至模型中，下面我们就来添加，我们使用关联字段来将会员的图片显示在借阅文档中。编辑library_checkout&#x2F;models&#x2F;library_checkout.py文件并在借阅类中添加如下字段：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">member_image = fields.Binary(related=&#x27;member_id.partner_id.image&#x27;)</span><br></pre></td></tr></table></figure>

<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cb28aa0cb50e47a6a834ab6b656e981f~tplv-k3u1fbpfcp-zoom-1.image" alt="Odoo 12图片-标题"></p>
<h3 id="表单内容分组"><a href="#表单内容分组" class="headerlink" title="表单内容分组"></a>表单内容分组</h3><p>表单主内容区应通过<group>标签来进行组织。<group>标签在画布中插入了两列。默认在这些列中标签会在字段旁显示，因此又占据两列。字段加标签会占据 一行，下一个字段和标签又会另起一行，垂直排列。Odoo表单的常见布局是带标签的字段并排成两列。达到这一效果，我们只需要添加两个嵌入顶部的<group>标签。</p>
<p>继续修改表单视图，在主内容区标题<div>后添加如下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;group name=&quot;group_top&quot;&gt;</span><br><span class="line">    &lt;group name=&quot;group_col1&quot;&gt;</span><br><span class="line">        &lt;field name=&quot;user_id&quot; /&gt;</span><br><span class="line">        &lt;field name=&quot;checkout_date&quot; /&gt;</span><br><span class="line">    &lt;/group&gt;</span><br><span class="line">    &lt;group name=&quot;group_col2&quot;&gt;</span><br><span class="line">        &lt;field name=&quot;state&quot; /&gt;</span><br><span class="line">        &lt;field name=&quot;closed_date&quot; /&gt;</span><br><span class="line">    &lt;/group&gt;</span><br><span class="line">&lt;/group&gt;</span><br></pre></td></tr></table></figure>

<p>为 group 标签分配name是一个好的编码实践，这样在其它模块中继承时会更易于对它们进行引用。还可设置 string 属性，一旦设置将作为该部分的标题来显示。</p>
<blockquote>
<p>ℹ️<strong>Odoo 11中的修改</strong><br>string 属性不能作为继承的锚点，因为在应用继承前会对其进行翻译。这时应使用 name 属性来代替它。</p>
</blockquote>
<p>在 group 内，<newline>元素会强制在新的一行，下一个元素会渲染到组的第一列。附加的版块标题可通过组内<separator>元素添加，如果带有 string 属性也会显示标题标签。要更好地控制元素布局，我们可以使用col和colspan属性。</p>
<p>col 属性可用于<group>元素中来自定义包含的列数。如前所述，默认为两列，但可修改为任意其它数字。双数效果更佳，因为默认每个添加的字段会占据两列：字段标签和字段值。按照以下代码我们通过colspan&#x3D;”2” 来在一个组内将4个字段放在两列中显示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;group name=&quot;group_top&quot;&gt;</span><br><span class="line">    &lt;group name=&quot;group_col1&quot;</span><br><span class="line">        col=&quot;4&quot;</span><br><span class="line">        colspan=&quot;2&quot;</span><br><span class="line">        string=&quot;Group 1&quot;&gt;</span><br><span class="line">        &lt;field name=&quot;user_id&quot; /&gt;</span><br><span class="line">        &lt;field name=&quot;state&quot; /&gt;</span><br><span class="line">        &lt;field name=&quot;checkout_date&quot; /&gt;</span><br><span class="line">        &lt;field name=&quot;closed_date&quot; /&gt;</span><br><span class="line">    &lt;/group&gt;</span><br><span class="line">    &lt;group name=&quot;group_col2&quot; string=&quot;Group2&quot; /&gt;</span><br><span class="line">&lt;/group&gt;</span><br></pre></td></tr></table></figure>

<p>以上我们使用 string 属性为组添加了标题，来更清楚地看组所在位置。注意字段的顺序不同，它们先是从左到右，然后从上到下。<group>元素可以使用 colspan 属性来设置它所占用的具体列数。默认和带标签的字段一样为两列。可以修改以上代码中 col 和 colspan 的值来在表单中查看不同的效果。比如 col&#x3D;”6” colspan&#x3D;”4”的效果是什么样的？可以试一试(见下图)。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7e55449667304e39b7f551183081115e~tplv-k3u1fbpfcp-zoom-1.image" alt="Odoo 12 colspan 示例"></p>
<h3 id="选项卡笔记本-Tabbed-notebooks"><a href="#选项卡笔记本-Tabbed-notebooks" class="headerlink" title="选项卡笔记本(Tabbed notebooks)"></a>选项卡笔记本(Tabbed notebooks)</h3><p>另一种组织内容的方式是 notebook 元素，一个包含多个称为页面(page)的选项卡分区的容器。它们可以让不常用的内容在不使用时隐藏起来，或者用于按话题组织大量字段。</p>
<p>我们将在借阅表单中添加一个带有已借图书列表的notebook 元素。在前面的<group name="group_top">元素后可添加如下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;notebook&gt;</span><br><span class="line">    &lt;page string=&quot;Borrowed Books&quot; name=&quot;page_lines&quot;&gt;</span><br><span class="line">        &lt;field name=&quot;line_ids&quot; /&gt;</span><br><span class="line">    &lt;/page&gt;</span><br><span class="line">&lt;/notebook&gt;</span><br></pre></td></tr></table></figure>

<p>本例中笔记本仅有一个页面。添加更多，我们需在<section>元素内添加更多的<page>版块。页面画布默认不会渲染字段标签，如需显示，需像表单主画布那样将字段放在<group>版块内。本例中我们在页面中添加了one-to-many字段line_ids，我们已经有了页面标题，因此不需要标签。page支持以下属性：</p>
<ul>
<li>string：选项卡的标题（必填）</li>
<li>attrs：不可见属性与表达式映射的字典</li>
<li>accesskey：HTML访问密钥</li>
</ul>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7bc41790c5374bc38b607113a8fd9df6~tplv-k3u1fbpfcp-zoom-1.image" alt="Odoo 12选项卡笔记本"></p>
<h2 id="字段"><a href="#字段" class="headerlink" title="字段"></a>字段</h2><p>视图字段有一些可用属性。大部分从模型定义中获取值，但可在视图中覆盖。以下来快速查看字段的可用属性：</p>
<ul>
<li>name标识字段数据库中名称</li>
<li>string用于想要覆盖模型中标签文本的标签文本</li>
<li>help是鼠标悬停在字段上显示的提示文本，它允许我们覆盖模型定义中提供的帮助文本</li>
<li>placeholder是在字段中显示的提示文本</li>
<li>widget让我们可以覆盖字段的默认组件，一会儿我们就会讲到可用的组件</li>
<li>options是一个带有组件附加数据的JSON数据结构，值随各组件的不同支持而不同</li>
<li>class是用于字段 HTML 渲染的CSS类</li>
<li>nolabel&#x3D;”True”阻止自动字段标签的展示。仅对<group>元素内的字段有作用，通常与<label for="...">元素一起使用。</li>
<li>invisible&#x3D;”True”让字段不可见，但仍会从服务端获取数据并可在表单中使用</li>
<li>readonly&#x3D;”True”让表单中该字段不可编辑</li>
<li>required&#x3D;”True”让表单中该字段为必填</li>
</ul>
<p>一些特定字段的属性如下：</p>
<ul>
<li>password&#x3D;”True”用于文本字段。显示为密码项，隐藏所输入文字</li>
<li>filename用于二进制字段，它是用于存储上传文件名的模型字段的名称</li>
</ul>
<h3 id="字段标签"><a href="#字段标签" class="headerlink" title="字段标签"></a>字段标签</h3><p><label>元素可用于更好地控制字段标签的展示。一个使用示例是仅在表单为编辑模式时展示标签：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;label for=&quot;name&quot; class=&quot;oe_edit_only&quot; /&gt;</span><br></pre></td></tr></table></figure>

<p>这么做时，如果字段在<group>元素内部，我们通常还要对其设置nolabel&#x3D;”True”。class&#x3D;”oe_edit_only”可用于应用 CSS 样式，让标签仅在编辑模式下可见。</p>
<h3 id="字段组件"><a href="#字段组件" class="headerlink" title="字段组件"></a>字段组件</h3><p>每个字段类型都会使用相应的默认组件在表单中显示。但还有一些替代组件可以使用。对于文本字段，有如下组件：</p>
<ul>
<li>email用于让 email 文本成为可操作的”mail-to”地址</li>
<li>url用于将文本格式化为可点击的URL</li>
<li>html用于将文本渲染为HTML内容；在编辑模式下，它显示为一个WYSIWYG(所见即所得)编辑器，可在不使用 HTML 代码的情况下格式化内容。</li>
</ul>
<p>对于数字字段，有以下组件：</p>
<ul>
<li>handle在列表视图中作为一个排序字段，显示一个句柄来让我们可以拖放进行自定义排序</li>
<li>float_time将一个浮点型字段格式化为带有小时和分钟的值</li>
<li>monetary将一个浮点型字段显示为货币金额。它与currency_id字段一起使用，还可以通过options&#x3D;”{‘currency_field’: ‘currency_id’}”来使用另一个字段名</li>
<li>progressbar将一个浮点值显示为进度条百分比，有助于将字段展示为完成率</li>
<li>percentage和percentpie组件可用于浮点型字段</li>
</ul>
<p>对于关联和选择项字段，有以下附加组件：</p>
<ul>
<li>many2many_tags将值显示为按钮标签列表</li>
<li>many2many_checkboxes将选项值显示为一个复选框列表</li>
<li>selection对many-to-one字段使用选择字段组件</li>
<li>radio以单选按钮显示选择字段选项</li>
<li>priority将选项字段显示为一个可点击星形列表。选择项目通常是数值。</li>
<li>state_selection将看板状态选择列表显示为信号灯。普通状态显示为灰色，完成显示为绿色，其它状态显示为红色。</li>
<li>pdf_viewer是一个二进制字段(在 Odoo 12中引入)。</li>
</ul>
<blockquote>
<p>ℹ️<strong>Odoo 11中的修改</strong><br>state_selection在 Odoo11中引入来替换掉kanban_state_selection。后者被淘汰，但为保持向后兼容性，还支持使用。</p>
</blockquote>
<h3 id="关联字段"><a href="#关联字段" class="headerlink" title="关联字段"></a>关联字段</h3><p>在关联字段中，我们可让用户操作做一些额外控制。默认用户从这些字段中创建新记录（也称作“快速创建”）并打开关联记录表单。可通过options字段属性来关闭：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">options=&quot;&#123;&#x27;no_open&#x27;: True, &#x27;no_create&#x27;: True&#125;&quot;</span><br></pre></td></tr></table></figure>

<p>context和domain也是字段属性并对于关联字段特别有用。context可定义关联字记录默认值，domain 可限制可选记录。常见的示例为让一个字段依赖其它字段值来产生选择项。domain可在模型中直接定义，但也可在视图中进行覆盖。</p>
<p>在to-many字段中，我们还可使用 mode 属性来更改用于显示记录的视图类型。默认为 tree，但还有其它选项：form, kanban或graph。关联字段可定义行内指定视图来使用。这些视图在元素中的嵌套视图定义中声明。例如，在line_ids借阅中，我们可以为这些线路定义特定的列表和表单视图：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;notebook&gt;</span><br><span class="line">    &lt;page string=&quot;Borrowed Books&quot; name=&quot;page_lines&quot;&gt;</span><br><span class="line">        &lt;field name=&quot;line_ids&quot;&gt;</span><br><span class="line">            &lt;tree&gt;</span><br><span class="line">                &lt;field name=&quot;book_id&quot; /&gt;</span><br><span class="line">            &lt;/tree&gt;</span><br><span class="line">            &lt;!--form&gt;</span><br><span class="line">                &lt;field name=&quot;book_id&quot; /&gt;</span><br><span class="line">            &lt;/form--&gt;</span><br><span class="line">        &lt;/field&gt;</span><br><span class="line">    &lt;/page&gt;</span><br><span class="line">&lt;/notebook&gt;</span><br></pre></td></tr></table></figure>

<p>线路列表将带有给定的<tree>定义。当我们与线路交互时，弹出一个表单对话框，在<form>定义中包含该结构。</p>
<blockquote>
<p><strong>小贴士：</strong> 如果想要在列表视图的表单弹出窗口中直接编辑one-to-many路线，应使用<tree editable="top">或<tree editable="bottom"></p>
</blockquote>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/73975940065e4dab91d83e3b2fd8adef~tplv-k3u1fbpfcp-zoom-1.image" alt="Odoo 12内联列表、表单视图"></p>
<h2 id="按钮"><a href="#按钮" class="headerlink" title="按钮"></a>按钮</h2><p>按钮支持这些属性：</p>
<ul>
<li><p>string是按钮文本标签或使用图标时的 HTML alt 文本</p>
</li>
<li><p>type是执行操作的类型，有以下值：</p>
<ul>
<li>object用于调用 Python 方法</li>
<li>action用于运行窗口操作</li>
</ul>
</li>
<li><p>name标识按所选类型要操作的具体的操作，要么是模型方法名，要么是要运行的窗口操作的数据库 ID。可使用%(xmlid)d方程式来将XML ID转换成加载视图时所需的数据库 ID。</p>
</li>
<li><p>args在类型为 object 时用于向方法传递额外的参数，须是在形成方法调用参数的记录 ID 之后所添加的纯静态 JSON 参数。</p>
</li>
<li><p>context在上下文中添加值，可在窗口操作或 Python 代码方法调用之后产生效果。</p>
</li>
<li><p>confirm在运行相关操作之前显示确认消息框，显示的内容是属性中分配的文本。special&#x3D;”cancel”用于向导表单。</p>
</li>
<li><p>icon是按钮所显示的图标。可用的按钮来自Font Awesome图标集，版本为4.7.0，应通过对应的 CSS 类来指定，如icon&#x3D;”fa-question”。更多信息可访问<a target="_blank" rel="noopener" href="https://fontawesome.com/v4.7.0/icons/">Font Awesome</a>。</p>
</li>
</ul>
<blockquote>
<p>ℹ️<strong>Odoo 11中的修改</strong><br>在 Odoo 11之前，按钮图标是来自GTK客户端库的图片，并且仅限于addons&#x2F;web&#x2F;static&#x2F;src&#x2F;img&#x2F;icons中所保存图片。</p>
<p>ℹ️<strong>Odoo 11中的修改</strong><br>在 Odoo 11中工作流引擎被淘汰并删除。此前的版本中，在支持工作流的地方，按钮可通过type&#x3D;”workflow”来触发工作流引擎信号。这时name属性用于工作流的信号名。</p>
</blockquote>
<h3 id="智能按钮"><a href="#智能按钮" class="headerlink" title="智能按钮"></a>智能按钮</h3><p>在右上角版块中带有智能按钮(smart button)也很常见。智能按钮显示为带有数据指示的矩形，在点击时可进入。</p>
<p>Odoo 中使用的 UI样式是在放置智能按钮的地方带有一个隐藏框，按钮框通常是<sheet>的第一个元素，在<div class="oe_title">元素前(以及头像)，类似这样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div name=&quot;button_box&quot; class=&quot;oe_button_box&quot;&gt;</span><br><span class="line">    &lt;!-- Smart buttons will go here... --&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<p>按钮的容器是一个带有oe_button_box类的 div 元素。在 Odoo 11.0以前，可能需要添加一个oe_right类来确保按钮框在表单中右对齐。在我们的应用中，我们将在按钮中显示图书会员待归还的其它借阅的总数，点击按钮会进入这些项的列表中。</p>
<p>所以我们需要该会员处于 open 状态的借阅记录，排除掉当前借阅。对于按钮统计，我们应创建一个计算字段来在library_checkout&#x2F;models&#x2F;library_checkout.py文件的借阅类中进行计数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">num_other_checkouts = fields.Integer(</span><br><span class="line">    compute=&#x27;_compute_num_other_checkouts&#x27;)</span><br><span class="line"></span><br><span class="line">def _compute_num_other_checkouts(self):</span><br><span class="line">    for rec in self:</span><br><span class="line">        domain = [</span><br><span class="line">            (&#x27;member_id&#x27;, &#x27;=&#x27;, rec.member_id.id),</span><br><span class="line">            (&#x27;state&#x27;, &#x27;in&#x27;, [&#x27;open&#x27;]),</span><br><span class="line">            (&#x27;id&#x27;, &#x27;!=&#x27;, rec.id)]</span><br><span class="line">        rec.num_other_checkouts = self.search_count(domain)</span><br></pre></td></tr></table></figure>

<p>下一步我们可以添加按钮框并在其中添加按钮。在<sheet>版块的上方，替换上面的按钮框占位符为以下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;div name=&quot;button_box&quot; class=&quot;oe_button_box&quot;&gt;</span><br><span class="line">    &lt;button class=&quot;oe_stat_button&quot;</span><br><span class="line">        icon=&quot;fa-tasks&quot;</span><br><span class="line">        help=&quot;Other checkouts pending return.&quot;</span><br><span class="line">        type=&quot;action&quot;</span><br><span class="line">        name=&quot;%(action_other_checkouts_button)d&quot;</span><br><span class="line">        context=&quot;&#123;&#x27;default_member_id&#x27;: member_id&#125;&quot;&gt;</span><br><span class="line">        &lt;field string=&quot;To Return&quot;</span><br><span class="line">            name=&quot;num_other_checkouts&quot;</span><br><span class="line">            widget=&quot;statinfo&quot; /&gt;</span><br><span class="line">    &lt;/button&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<p>按钮元素本身是一个带有显示数据字段的容器。这些数据是使用statinfo特定组件的普通字段。该字段通常是作用于模型中定义的计算字段。除字段外，在按钮中还可以使用静态文本，如<div>Other Checkouts</div>。其它待借阅的数量展示在按钮定义中的num_other借阅字段中。</p>
<p>智能按钮必须带有class&#x3D;”oe_stat_button” CSS样式，并应使用 icon 属性来带有一个图标。它有一个type&#x3D;”action”，表示点击按钮时将运行通过 name 属性标识的窗口操作。%(action_other_checkouts_button)d表达式返回要运行的操作的数据库 ID。</p>
<p>在点击按钮时，我们要查看当前会员的其它借阅列表。这可通过action_other_checkouts_button窗口操作来实现。该操作会使用合适的域过滤器打开一个图书借阅列表。操作和相应的域过滤器在表单上下文之外处理，无法访问表单数据。因此按钮必须在上下文中设置当前member_id 来供窗口操作随后使用。使用的窗口操作必须在表单之前定义，因此我们应在 XML 文件根元素<odoo>中的最上方添加以下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;act_window id=&quot;action_other_checkouts_button&quot;</span><br><span class="line">    name=&quot;Open Other Checkouts&quot;</span><br><span class="line">    res_model=&quot;library.checkout&quot;</span><br><span class="line">    view_mode=&quot;tree,form&quot;</span><br><span class="line">    domain=&quot;[(&#x27;member_id&#x27;, &#x27;=&#x27;, default_member_id),</span><br><span class="line">        (&#x27;state&#x27;, &#x27;in&#x27;, [&#x27;open&#x27;]),</span><br><span class="line">        (&#x27;id&#x27;, &#x27;!=&#x27;, active_id)]&quot;/&gt;</span><br></pre></td></tr></table></figure>

<p>注意我们在域过滤器中如何使用default_member_id上下文键。该键还会点击按钮链接创建新任务时为member_id字段设置默认值。域过滤器也需要当前 ID。这无需在上下文中明确设置，因为网页客户端会在active_id上下文键中自动进行设置。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/df35196c7ba64de1882c2996570030f2~tplv-k3u1fbpfcp-zoom-1.image" alt="Odoo 12智能按钮"></p>
<p>以下是可在智能按钮中添加的属性，供您参考：</p>
<ul>
<li>class&#x3D;”oe_stat_button”渲染的不是普通按钮而是一个矩形</li>
<li>icon从Font Awesome图标集中选择图标来使用。访问<a target="_blank" rel="noopener" href="http://fontawesome.io/">Font Awesome</a>查看有哪些图标。</li>
<li>type和name是按钮类型以及触发的操作名。对于智能按钮，类型通常是 action，指定窗口操作，名称为所要执行操作的 ID。应传入真实数据库 ID，因此我们要使用方程式来将XML ID转换为数据库 ID：”%(actionxmlid)d”。这一操作应该会打开带有关联记录的视图。</li>
<li>string为按钮添加标签文本，这里没有使用因为所包含的字段中已经提供了文本。</li>
<li>context应用于为目标视图设置默认值，用于点击按钮后视图上新建的记录。</li>
<li>help在鼠标悬停在按钮上显示帮助提示信息</li>
</ul>
<h2 id="动态视图元素"><a href="#动态视图元素" class="headerlink" title="动态视图元素"></a>动态视图元素</h2><p>视图元素还支持一些允许视图按字段值动态变更外观或行为的属性。我们可以有onchange 事件来在编辑表单数据时修改其它字段值，或在满足特定条件时让字段为必填或显示。</p>
<h3 id="onchange-事件"><a href="#onchange-事件" class="headerlink" title="onchange 事件"></a>onchange 事件</h3><p>onchange机制允许我在某一特定字段变更时修改其它表单字段。例如一个商品字段的 onchange可以在商品被修改时设置价格字段为默认值。在老版本中，onchange 事件在视图级别定义，但8.0之后直接在模型层中定义，无需在视图上做任何特定标记。这通过使用@api.onchange(‘field1’, ‘field2’, …) 装饰器创建模型，来对一些字段绑定 onchange 逻辑。onchange 模型方法在第八章 <a target="_blank" rel="noopener" href="https://alanhou.org/odoo12-business-logic/">Odoo 12开发之业务逻辑 - 业务流程的支持</a>中详细讨论过，其中还有相关示例。</p>
<p>onchange 机制还可以在用户输入时即时反馈进行计算字段的自动重算。继续使用商品来举例，如果在修改商品时价格字段变化了，它还会根据新的价格自动更新计算后的总金额字段。</p>
<h3 id="动态属性"><a href="#动态属性" class="headerlink" title="动态属性"></a>动态属性</h3><p>一些属性允许我们根据记录的值来动态变更视图元素的显示。指定用户界面元素的可见性可通过如下属性很方便地控制：</p>
<ul>
<li>groups可根据当前用户所属安全组来让元素可见。仅指定组的成员可看到该元素。它的值应为一个逗号分隔的XML ID列表</li>
<li>states可根据记录的状态字段来让元素可见。它的值为一个逗号分隔的状态列表，仅对带有state 字段的模型生效。</li>
</ul>
<p>除这些以外，我们有一些灵活的方法来根据客户端动态生成的表达式设置元素可见性。它是一个特别属性 attrs，它的值为一个映射invisible属性值与表达式结果的字典。例如，要让closed_date字段在new和open状态时不可见，可使用如下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;field name=&quot;closed_date&quot;</span><br><span class="line">     attrs=&quot;&#123;&#x27;invisible&#x27;:[(&#x27;state&#x27;, &#x27;in&#x27;, [&#x27;new&#x27;, &#x27;open&#x27;])]&#125;&quot;/&gt;</span><br></pre></td></tr></table></figure>

<p>invisible不只在字段中可用，在任意元素中均可用。例如，它可用于 notebook 页面和group元素中。attrs属性也可为其它两个属性设置值：readonly和required。它们仅对数据字段有意义，通过二者来让字段可编辑或为必填。这让我们可以实现一些基础客户端逻辑，如根据其它字段值(如 state)来让字段设为必填。</p>
<h2 id="列表视图"><a href="#列表视图" class="headerlink" title="列表视图"></a>列表视图</h2><p>学到这里可能不太需要介绍列表视图了，但它还一些有趣的额外属性可以讨论。下面我们修改library_checkout&#x2F;views&#x2F;checkout_view.xml文件来改进第八章 <a target="_blank" rel="noopener" href="https://alanhou.org/odoo12-business-logic/">Odoo 12开发之业务逻辑 - 业务流程的支持</a>中的版本：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;record id=&quot;view_tree_checkout&quot; model=&quot;ir.ui.view&quot;&gt;</span><br><span class="line">    &lt;field name=&quot;name&quot;&gt;Checkout Tree&lt;/field&gt;</span><br><span class="line">    &lt;field name=&quot;model&quot;&gt;library.checkout&lt;/field&gt;</span><br><span class="line">    &lt;field name=&quot;arch&quot; type=&quot;xml&quot;&gt;</span><br><span class="line">        &lt;tree</span><br><span class="line">            decoration-muted=&quot;state in [&#x27;done&#x27;, &#x27;cancel&#x27;]&quot;</span><br><span class="line">            decoration-bf=&quot;state==&#x27;open&#x27;&quot;&gt;</span><br><span class="line">            &lt;field name=&quot;state&quot; invisible=&quot;True&quot; /&gt;</span><br><span class="line">            &lt;field name=&quot;request_date&quot; /&gt;</span><br><span class="line">            &lt;field name=&quot;member_id&quot; /&gt;</span><br><span class="line">            &lt;field name=&quot;checkout_date&quot; /&gt;</span><br><span class="line">            &lt;field name=&quot;stage_id&quot; /&gt;</span><br><span class="line">            &lt;field name=&quot;num_books&quot; sum=&quot;# Books&quot; /&gt;</span><br><span class="line">        &lt;/tree&gt;</span><br><span class="line">    &lt;/field&gt;</span><br><span class="line">&lt;/record&gt;</span><br></pre></td></tr></table></figure>

<p>行文本颜色和字体可根据 Python 表达式计算结果来动态变化。这通过decoration–NAME属性带上计算字段属性的表达式来实现。NAME可以是bf或it，分别表示粗体和斜体，也可以是其它Bootstrap文本上下文颜色：danger, info, muted, primary, success或warning。<a target="_blank" rel="noopener" href="https://getbootstrap.com/docs/3.3/css/#helper-classes">Bootstrap文档</a>中有相关显示示例。</p>
<blockquote>
<p>ℹ️<strong>Odoo 9中的修改</strong><br>decoration-NAME 属性在 Odoo 9中引入。在 Odoo 8中使用是 colors 和 fonts 属性。</p>
</blockquote>
<p>记住表达式中使用的字段必须要在<field>字段中声明，这样网页客户端才知道要从服务端获取该列。如果不想对用户显示，应对其使用invisible&#x3D;”1”属性。其它 tree 元素的相关属性有：</p>
<ul>
<li>default_order让我们可以覆盖模型中的默认排序，它的值和模型中定义的排序格式相同。</li>
<li>create, delete和edit，如果设为 false（字母小写），会禁用列表视图中的相应操作。</li>
<li>editable让记录在列表视图中可直接被编辑。可用值有 top 和 bottom，表示新记录添加的位置。</li>
</ul>
<p>列表视图可包含字段和按钮，表单中的大部分属性对它们也有效。在列表视图中，数值字段可显示为对应列的汇总值。为字段添加一个累加属性(sum, avg, min或max)会为其分配汇总值的标签文本。我们在 num_books 字段中添加了一个示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;field name=&quot;num_books&quot; sum=&quot;# Books&quot; /</span><br></pre></td></tr></table></figure>

<p>num_books字段计算每个借阅中的图书数量，它是一个计算字段，我们需要在模型进行添加：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">num_books = fields.Integer(compute=&#x27;_compute_num_books&#x27;)</span><br><span class="line"></span><br><span class="line">@api.depends(&#x27;line_ids&#x27;)</span><br><span class="line">def _compute_num_books(self):</span><br><span class="line">    for book in self:</span><br><span class="line">        book.num_books = len(book.line_ids)</span><br></pre></td></tr></table></figure>

<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6de19e2e7d5c4e0da1111266197680d4~tplv-k3u1fbpfcp-zoom-1.image" alt="Odoo 12列表视图数量累加"></p>
<h2 id="搜索视图"><a href="#搜索视图" class="headerlink" title="搜索视图"></a>搜索视图</h2><p>可用的搜索选项通过<search>视图类型来定义。我们可以选择在搜索框中输入时自动搜索的字段。还可以预置过滤器，通过点击启用，以及在列表视图中的预置分组选项。图书借阅的搜索视图可设置如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;record id=&quot;view_filter_checkout&quot; model=&quot;ir.ui.view&quot;&gt;</span><br><span class="line">    &lt;field name=&quot;model&quot;&gt;library.checkout&lt;/field&gt;</span><br><span class="line">    &lt;field name=&quot;arch&quot; type=&quot;xml&quot;&gt;</span><br><span class="line">        &lt;search&gt;</span><br><span class="line">            &lt;field name=&quot;member_id&quot; /&gt;</span><br><span class="line">            &lt;field name=&quot;user_id&quot; /&gt;</span><br><span class="line">            &lt;filter name=&quot;filter_not_done&quot;</span><br><span class="line">                string=&quot;To Return&quot;</span><br><span class="line">                domain=&quot;[(&#x27;state&#x27;,&#x27;=&#x27;,&#x27;open&#x27;)]&quot; /&gt;</span><br><span class="line">            &lt;filter name=&quot;filter_my_checkouts&quot;</span><br><span class="line">                string=&quot;My Checkouts&quot;</span><br><span class="line">                domain=&quot;[&#x27;user_id&#x27;, &#x27;=&#x27;, uid]&quot; /&gt;</span><br><span class="line">            &lt;filter name=&quot;group_user&quot;</span><br><span class="line">                string=&quot;By Member&quot;</span><br><span class="line">                context=&quot;&#123;&#x27;group_by&#x27;: &#x27;member_id&#x27;&#125;&quot; /&gt;</span><br><span class="line">        &lt;/search&gt;</span><br><span class="line">    &lt;/field&gt;</span><br><span class="line">&lt;/record&gt;</span><br></pre></td></tr></table></figure>

<p>在<search>视图定义中，可以看到两个member_id和user_id的简单元素，当用户在搜索框中输入时，推荐下拉框中会显示对这些字段的匹配。然后有两个使用域过滤器的预置过滤器。可在搜索框下方的 Filter 按钮下选择。第一个过滤器是 To Return 图书，也就还处于 open 状态的图书。第二个过滤器是当前图书管理员处理的图书，通过当前用户的 user_id （可在上下文的 uid 键中获取）过滤。</p>
<p>这两个过滤器可以分别被启用并以 OR运算符连接。以<separator />元素分隔的整块过滤器以 AND 运算符连接。</p>
<p>第三个过滤器仅设置 group by 上下文键，它让视图按照字段来对记录分组，本例中为 member_id 字段。</p>
<p>字段元素可使用如下属性：</p>
<ul>
<li>name标识要使用的字段</li>
<li>string用作标签文本，它会替换默认值</li>
<li>operator用于修改默认的运算符(默认值：数值字段&#x3D;，其它字段类型ilike)</li>
<li>filter_domain设置搜索使用的特定域表达式，为 operator 属性提供一种灵活的替代方式。搜索文本在表达式中通过 self 引用。一个简单示例：filter_domain&#x3D;”[(‘name’, ‘ilike’, self)]”</li>
<li>groups让对该字段的搜索仅向安全组内成员开发，它的值是一个逗号分隔的XML ID列表</li>
</ul>
<p>过滤元素有以下可用属性：</p>
<ul>
<li>name用作后续继承&#x2F;扩展或通过窗口操作启用的标识符。这不是必填项，但包含该属性是一个不错的编码习惯。</li>
<li>string是过滤器显示的标签文本，必填</li>
<li>domain是加入当前域的域表达式</li>
<li>context是加入当前上下文的上下文字典。通常使用group_id作为键，用于对记录分组的字段名作为值</li>
<li>groups让该字段的搜索仅对安全组列表(XML IDs)成员开放</li>
</ul>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d4e3f1cca7cf402c87947dc438b6bb46~tplv-k3u1fbpfcp-zoom-1.image" alt="Odoo 12搜索过滤"></p>
<h2 id="其它视图类型"><a href="#其它视图类型" class="headerlink" title="其它视图类型"></a>其它视图类型</h2><p>表单、列表和搜索视图是最常用的视图类型。但还有一些其它的视图类型可用于设计用户界面。对于前述三种基本视图类型我们已经很熟悉了，在第十一章 <a target="_blank" rel="noopener" href="https://alanhou.org/odoo12-kanban-qweb/">Odoo 12开发之看板视图和用户端 QWeb</a>中将详细介绍看板视图，它会将记录可视化为卡片形式，甚至会按列组织为看板。下面我们将学习一些其它视图类型：</p>
<ul>
<li>activity将计划活动显示为有组织的汇总</li>
<li>calendar基于所选日期字段以日历格式展示数据</li>
<li>diagram展示记录间的关系，当前不在 Odoo 中使用</li>
</ul>
<p>以下两种视图类型用于显示累加数据：</p>
<ul>
<li>graph用于图表展示</li>
<li>pivot用于交互的数据透视表</li>
</ul>
<p>还有更多的视图类型，但仅在 Odoo 企业版中可用。因为我们整个系列的文章是基于社区版的，所以无法为这些视图提供示例：</p>
<ul>
<li>dashboard使用透视表和图表这类子视图展示累加数据</li>
<li>cohort用于显示在不同时期数据如何变化</li>
<li>gantt以甘特图显示日期计划信息，常用于项目管理</li>
<li>grid通过行和列网格组织数据进行展示</li>
</ul>
<p>官方文档中提供了对所有视图和可用属性很好的参考，这里就不再重复。我们集中于提供一些基础使用示例，这样可以对这些视图入门。这样应该可以提供一个很好的基础，然后可进一步探索每个视图的所有功能。</p>
<blockquote>
<p><strong>小贴士：</strong> 可通过社区插件模块查看其它视图类型。OCA 管理的网页客户端插件请见 <a target="_blank" rel="noopener" href="https://github.com/OCA/web">GitHub 仓库</a>。例如，web_timeline模块提供了一个时间线视图类型，也可像甘特图那样展示计划信息，它是社区版的 gantt 视图类型。</p>
</blockquote>
<h3 id="活动视图"><a href="#活动视图" class="headerlink" title="活动视图"></a>活动视图</h3><p>活动视图类型是内置的计划活动汇总板，帮助用于可视化活动任务。由 mail 模块提供，因此需要先安装该模块才能使用这一视图类型。要使用这一类型，只需在窗口操作的 view_code 属性的视图列表中添加活动视图类型即可。实际的视图定义会自动生成，我们也可以手动进行添加，唯一的选项是修改 string 属性，但在UI 中并不使用。</p>
<p>作为参考，活动视图的定义类似这样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;activity string=&quot;Activities&quot;/&gt;</span><br></pre></td></tr></table></figure>

<h3 id="日历视图"><a href="#日历视图" class="headerlink" title="日历视图"></a>日历视图</h3><p>从名称可以看出，该视图类型在日历中展示记录，可通过不同时间区间浏览：按月、按周或按日。以下是我们图书借阅的日历视图，根据请求日期在日历上显示各项：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;record id=&quot;view_calendar_checkout&quot; model=&quot;ir.ui.view&quot;&gt;</span><br><span class="line">    &lt;field name=&quot;model&quot;&gt;library.checkout&lt;/field&gt;</span><br><span class="line">    &lt;field name=&quot;arch&quot; type=&quot;xml&quot;&gt;</span><br><span class="line">        &lt;calendar date_start=&quot;request_date&quot;</span><br><span class="line">            color=&quot;user_id&quot;&gt;</span><br><span class="line">            &lt;field name=&quot;member_id&quot; /&gt;</span><br><span class="line">            &lt;field name=&quot;stage_id&quot; /&gt;</span><br><span class="line">        &lt;/calendar&gt;</span><br><span class="line">    &lt;/field&gt;</span><br><span class="line">&lt;/record&gt;</span><br></pre></td></tr></table></figure>

<p>补充：请记得在菜单xml文件中加回前文删除的 calendar 类型</p>
<p>基础的日历属性有：</p>
<ul>
<li>date_start是开始日期字段（必填）</li>
<li>date_end是结束日期字段（可选）</li>
<li>date_delay是天数字段，用于代替date_end</li>
<li>all_day传入一个布尔字段名，用于标识全天活动。这类活动会忽略时长。</li>
<li>color用于为一组日历项添加颜色。每个不同值都会被分配一种颜色，它的所有项都会显示为相同颜色。</li>
<li>mode是日历视图的默认显示模块，可以是天、周或月。</li>
</ul>
<blockquote>
<p>ℹ️<strong>Odoo 11中的修改</strong><br>dipsplay 日历属性在 Odoo 11中删除。此前的版本中，它用于自定义日历项标题文本的格式，例如display&#x3D;”[name], Stage [stage_id]”。</p>
</blockquote>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c48747647f094de3ab40e649ee4bcec3~tplv-k3u1fbpfcp-zoom-1.image" alt="Odoo 12日历视图"></p>
<h3 id="透视表视图"><a href="#透视表视图" class="headerlink" title="透视表视图"></a>透视表视图</h3><p>还可通过透视表查看数据，它是一个动态分析矩阵。为此我们可使用透视表视图。</p>
<blockquote>
<p>ℹ️<strong>Odoo 9中的修改</strong><br>透视表在 Odoo 8中就已存在，作为一个图表视图功能。在 Odoo 9中，它成为一个独立的视图类型。同时也增强了透视表功能、优化了透视表数据的获取。</p>
</blockquote>
<p>数据累加仅对数据库中存储的字段可用。我们将使用num_books字段来展示一些借书数量的统计。它是一个计算字段，还没有存储在数据库中。要在这些视图中使用，需要通过添加store&#x3D;True属性先将其存储在数据库中：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">num_books = fields.Integer(</span><br><span class="line">    compute=&#x27;_compute_num_books&#x27;,</span><br><span class="line">    store=True)</span><br></pre></td></tr></table></figure>

<p>使用如下代码来为图书借阅添加数据透视表：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;record id=&quot;view_pivot_checkout&quot; model=&quot;ir.ui.view&quot;&gt;</span><br><span class="line">    &lt;field name=&quot;model&quot;&gt;library.checkout&lt;/field&gt;</span><br><span class="line">    &lt;field name=&quot;arch&quot; type=&quot;xml&quot;&gt;</span><br><span class="line">        &lt;pivot&gt;</span><br><span class="line">            &lt;field name=&quot;stage_id&quot; type=&quot;col&quot; /&gt;</span><br><span class="line">            &lt;field name=&quot;member_id&quot; /&gt;</span><br><span class="line">            &lt;field name=&quot;request_date&quot; interval=&quot;week&quot; /&gt;</span><br><span class="line">            &lt;field name=&quot;num_books&quot; type=&quot;measure&quot; /&gt;</span><br><span class="line">        &lt;/pivot&gt;</span><br><span class="line">    &lt;/field&gt;</span><br><span class="line">&lt;/record&gt;</span><br></pre></td></tr></table></figure>

<p>图表和透视表视图应包含描述轴和度量的字段元素，两者的属性大多数都通用：</p>
<ul>
<li>name像其它视图一样标识图表中使用的字段</li>
<li>type是指如何使用字段，行分组(默认)、度量(measure)或列（仅针对透视表，用于列分组）</li>
<li>interval用于日期字段，是对时间数据的分组间隔：按天、按周、按月、按季度或按年</li>
</ul>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d53862cd90d745d5a6acf65fecfa0bcd~tplv-k3u1fbpfcp-zoom-1.image" alt="Odoo 12透视表视图"></p>
<h3 id="图表视图"><a href="#图表视图" class="headerlink" title="图表视图"></a>图表视图</h3><p>图表视图将数据累加展示为图表，可以使用柱状图、线状图和饼图。下面来为图书借阅添加图表视图：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;record id=&quot;view_graph_checkout&quot; model=&quot;ir.ui.view&quot;&gt;</span><br><span class="line">    &lt;field name=&quot;model&quot;&gt;library.checkout&lt;/field&gt;</span><br><span class="line">    &lt;field name=&quot;arch&quot; type=&quot;xml&quot;&gt;</span><br><span class="line">        &lt;graph type=&quot;bar&quot;&gt;</span><br><span class="line">            &lt;field name=&quot;stage_id&quot; /&gt;</span><br><span class="line">            &lt;field name=&quot;num_books&quot; type=&quot;measure&quot; /&gt;</span><br><span class="line">        &lt;/graph&gt;</span><br><span class="line">    &lt;/field&gt;</span><br><span class="line">&lt;/record&gt;</span><br></pre></td></tr></table></figure>

<p>图表视图元素可带有一个type属性，值可为 bar(默认), pie或line。对于 bar，可使用额外的stacked&#x3D;”True”属性来让柱状图叠放起来。图表使用两种类型字段：</p>
<ul>
<li>type&#x3D;”row”是默认值，设置累加值的条件</li>
<li>type&#x3D;”measure”用于作为实际累加值的度量字段</li>
</ul>
<p>图表和透视表视图应包含描述需使用的轴和度量的字段元素。大多数图表视图中的属性同样可在透视表视图中使用。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/53de3260c991443eaf6a56d1b0fde94a~tplv-k3u1fbpfcp-zoom-1.image" alt="Odoo 12图表视图"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文中我们学习了更多创建用户界面的 Odoo 视图。我们深入讲解了表单视图，然后一起概览了其它视图类型，包括列表视图和搜索视图。我们还学习了如何向视图元素添加动态行为。</p>
<p>下一篇文章中，我们将学习本文中未涉及到的视图：看板视图以及它使用的模板语言 QWeb。</p>
<p> </p>
<p>☞☞☞第十一章 <a target="_blank" rel="noopener" href="https://alanhou.org/odoo12-kanban-qweb/">Odoo 12开发之看板视图和用户端 QWeb</a></p>
<p> </p>
<h2 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h2><p>以下本文中所讨论的话题的附加参考和补充材料：</p>
<ul>
<li><p>Odoo 官方文档</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.odoo.com/documentation/12.0/reference/actions.html">有关actions</a></li>
<li><a target="_blank" rel="noopener" href="https://www.odoo.com/documentation/12.0/reference/views.html">有关视图</a></li>
</ul>
</li>
<li><p>Font Awesome<a target="_blank" rel="noopener" href="https://fontawesome.com/v4.7.0/icons/">图标索引</a></p>
</li>
</ul>
<p>本文首发地址：<a target="_blank" rel="noopener" href="https://alanhou.org/developer-mode-odoo12/">Alan Hou 的个人博客</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://alanhou.github.io/2019/01/15/odoo-essentials-12-chapter9/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Alan Hou">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Alan Hou的个人博客">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Alan Hou的个人博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2019/01/15/odoo-essentials-12-chapter9/" class="post-title-link" itemprop="url">第九章 Odoo 12开发之外部 API – 集成第三方系统</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2019-01-15 00:00:00" itemprop="dateCreated datePublished" datetime="2019-01-15T00:00:00+08:00">2019-01-15</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2023-02-03 13:45:28" itemprop="dateModified" datetime="2023-02-03T13:45:28+08:00">2023-02-03</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>本文为<a target="_blank" rel="noopener" href="https://alanhou.org/odoo-12-development/">最好用的免费ERP系统Odoo 12开发手册</a>系列文章第九篇。</p>
<p>Odoo 服务器端带有外部 API，可供网页客户端和其它客户端应用使用。本文中我们将学习如何在我们的客户端程序中使用 Odoo 的外部 API。为避免引入大家所不熟悉的编程语言，此处我们将使用基于 Python 的客户端，但这种 RPC 调用的处理方法也适用于其它编程语言。</p>
<p>我们将一起了解如何使用 Odoo RPC调用，然后根据所学知识使用 Python创建一个简单的图书命令行应用。</p>
<p>本文主要内容有：</p>
<ul>
<li>在客户端机器上安装 Python</li>
<li>使用XML-RPC连接 Odoo</li>
<li>使用XML-RPC运行服务器端方法</li>
<li>搜索和读取 API 方法</li>
<li>图书客户端XML-RPC 接口</li>
<li>图书客户端用户界面</li>
<li>使用OdooRPC库</li>
<li>了解ERPpeek客户端</li>
</ul>
<h2 id="开发准备"><a href="#开发准备" class="headerlink" title="开发准备"></a>开发准备</h2><p>本文基于第三章 <a target="_blank" rel="noopener" href="https://alanhou.org/odoo12-first-application/">Odoo 12 开发之创建第一个 Odoo 应用</a>创建的代码，具体代码请参见<a target="_blank" rel="noopener" href="https://github.com/alanhou/odoo12-development/tree/master/library_app"> GitHub 仓库</a>。应将library_app模块放在addons路径下并进行安装。为保持前后一致，我们将使用第二章 <a target="_blank" rel="noopener" href="https://alanhou.org/odoo12-development-environment/">Odoo 12开发之开发环境准备</a>所进行安装并使用12-library数据库。本章完成后的代码请参见 <a target="_blank" rel="noopener" href="https://github.com/alanhou/odoo12-development/tree/master/chapter9">GitHub 仓库</a>。</p>
<p>补充：因原书前后曾使用过多个数据库，本文中Alan将使用系列中一直使用的 dev12数据库，并在前一篇文章的基础上进行开发。</p>
<h2 id="学习项目-图书目录客户端"><a href="#学习项目-图书目录客户端" class="headerlink" title="学习项目-图书目录客户端"></a>学习项目-图书目录客户端</h2><p>本文中，我们将开发一个简单的客户端应用来管理图书目录。这是一个命令行接口(CLI) 应用，使用 Odoo 来作为后端。应用的功能非常有限，这样我们可以聚焦在用于与 Odoo服务端交互的技术，而不是具体应用的实现细节。我们的简单应用可以完成如下功能：</p>
<ul>
<li>通过标题搜索并列出图书</li>
<li>向目录添加新标题</li>
<li>修正图书标题</li>
<li>从目录中删除图书</li>
</ul>
<p>这个应用是一个 Python 脚本，等待输入命令来执行操作。使用会话示例如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ python3 library.py add &quot;Moby-Dick&quot;</span><br><span class="line">$ python3 library.py list &quot;moby&quot;</span><br><span class="line">60 Moby-Dick</span><br><span class="line">$ python3 library.py set-title 60 &quot;Moby Dick&quot;</span><br><span class="line">$ python3 library.py del 60</span><br></pre></td></tr></table></figure>

<h2 id="在客户端机器上安装-Python"><a href="#在客户端机器上安装-Python" class="headerlink" title="在客户端机器上安装 Python"></a>在客户端机器上安装 Python</h2><p>Odoo API 可以在外部通过两种协议访问：XML-RPC和JSON-RPC。任意外部程序，只要能实施其中一种协议的客户端，就可以与 Odoo 服务端进行交互。为避免引入其它编程语言，我们将保持使用 Python 来研究外部 API。</p>
<p>到目前为止我们仅在服务端运行了 Python 代码。现在我们要在客户端上使用 Python，所以你可能需要在电脑上做一些额外设置。要学习本文的示例，你需要能在操作电脑上运行 Python 文件。可通过在命令行终端运行python3 –version命令来进行确认。如果没有安装，请参考官方网站针对你所使用的平台的<a target="_blank" rel="noopener" href="https://www.python.org/downloads/">安装包</a>。</p>
<p>对于 Ubuntu，你可能已经安装了 Python 3，如果没有安装，可通过以下命令进行安装：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install python3 python3-pip</span><br></pre></td></tr></table></figure>

<p>如果你使用的是 Windows 并且已安装了 Odoo，可能会奇怪为什么没有 Python 解释器，还需要进行额外安装。简单地说是因为 Odoo 安装带有一个内嵌的 Python 解释器，无法在外部使用。</p>
<h2 id="使用XML-RPC连接-Odoo-API"><a href="#使用XML-RPC连接-Odoo-API" class="headerlink" title="使用XML-RPC连接 Odoo API"></a>使用XML-RPC连接 Odoo API</h2><p>访问服务的最简单方法是使用XML-RPC，我们可以使用 Python 标准库中的xmlrpclib来实现。不要忘记我们是在编写客户端程序连接服务端，因此需运行 Odoo 服务端实例来供连接。本例中我们假设 Odoo 服务端实例在同一台机器上运行，但你可以使用任意运行服务的其它机器，只要能连接其IP 地址或服务器名。</p>
<p>让我们来初次连接 Odoo 外部 API。打开 Python 3终端并输入如下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; from xmlrpc import client</span><br><span class="line">&gt;&gt;&gt; srv = &#x27;http://localhost:8069&#x27;</span><br><span class="line">&gt;&gt;&gt; common = client.ServerProxy(&#x27;%s/xmlrpc/2/common&#x27; % srv)</span><br><span class="line">&gt;&gt;&gt; common.version()</span><br><span class="line">&#123;&#x27;server_version&#x27;: &#x27;12.0&#x27;, &#x27;server_version_info&#x27;: [12, 0, 0, &#x27;final&#x27;, 0, &#x27;&#x27;], &#x27;server_serie&#x27;: &#x27;12.0&#x27;, &#x27;protocol_version&#x27;: 1&#125;</span><br></pre></td></tr></table></figure>

<p>这里我们导入了xmlrpc.client库，然后创建了一个包含服务地址和监听端口信息的变量。请根据自身状况进行修改（如 Alan 使用srv &#x3D; ‘<a target="_blank" rel="noopener" href="http://192.168.16.161:8069'）。">http://192.168.16.161:8069&#39;）。</a></p>
<p>下一步访问服务端公共服务（无需登录），在终端地址&#x2F;xmlrpc&#x2F;2&#x2F;common上暴露。其中一个可用方法是version()，用于查看服务端版本。我们使用它来确认可与服务端进行通讯。</p>
<p>另一个公共方法是authenticate()。你可能你会以为它会创建会话，但实际上不会。该方法仅仅确认用户名和密码可被接受，请求不使用用户名而是它返回的用户 ID。示例如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; db = &#x27;dev12&#x27;</span><br><span class="line">&gt;&gt;&gt; user, pwd = &#x27;admin&#x27;, &#x27;admin&#x27;</span><br><span class="line">&gt;&gt;&gt; uid = common.authenticate(db, user, pwd, &#123;&#125;)</span><br><span class="line">&gt;&gt;&gt; print(uid)</span><br><span class="line">2</span><br></pre></td></tr></table></figure>

<p>首先创建变量 db，来存储使用的数据库名。本例中为 dev12，但可以修改为任意其它你所使用的数据库名。如果登录信息错误，将不会返回用户 ID，而是返回 False 值。authenticate()最后一个参数是用户代理(User Agent)环境，用于提供客户端的一些元数据(metadata)，它是必填的，但可以是一个空字典。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dbc0881b09484c0998d44eaee58743b1~tplv-k3u1fbpfcp-zoom-1.image" alt="Odoo 12 Python 客户端访问XML RPC"></p>
<h2 id="使用XML-RPC运行服务器端方法"><a href="#使用XML-RPC运行服务器端方法" class="headerlink" title="使用XML-RPC运行服务器端方法"></a>使用XML-RPC运行服务器端方法</h2><p>使用XML-RPC，不会维护任何会话，每次请求都会发送验证信息。这让协议过重，但使用简单。下一步我们设置访问需登录才能访问的服务端方法。暴露的终端地址为&#x2F;xmlrpc&#x2F;2&#x2F;object，示例如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; api = client.ServerProxy(&#x27;%s/xmlrpc/2/object&#x27; % srv)</span><br><span class="line">&gt;&gt;&gt; api.execute_kw(db, uid, pwd, &#x27;res.partner&#x27;, &#x27;search_count&#x27;, [[]])</span><br><span class="line">48</span><br></pre></td></tr></table></figure>

<p>此处我们第一次访问了服务端 API，执行了Partner 记录的计数。通过 execute_kw() 方法来调用方法，接收如下参数：</p>
<ul>
<li>连接的数据库名</li>
<li>连接用户ID</li>
<li>用户密码</li>
<li>目标模型标识符名称</li>
<li>调用的方法</li>
<li>位置参数列表</li>
<li>可选的关键字参数字典(本例中未使用)</li>
</ul>
<p>上面的例子中对res.partner模型调用了search_count方法，仅一个位置参数[]，没有关键字参数。该位置参数是一个搜索域，因我们传入的是一个空列表，它对所有伙伴进行计数。常用的操作有搜索和读取。在使用RPC调用时，search方法返回一个区块的 ID 列表。browse方法不可用于RPC，而应使用read来得到记录 ID 列表并获取相应数据，示例如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; domain = [(&#x27;is_company&#x27;, &#x27;=&#x27;, True)]</span><br><span class="line">&gt;&gt;&gt; api.execute_kw(db, uid, pwd, &#x27;res.partner&#x27;, &#x27;search&#x27;, [domain])</span><br><span class="line">[14, 10, 11, 15, 12, 13, 9, 1]</span><br><span class="line">&gt;&gt;&gt; api.execute_kw(db, uid, pwd, &#x27;res.partner&#x27;, &#x27;read&#x27;, [[14]], &#123;&#x27;fields&#x27;: [&#x27;id&#x27;, &#x27;name&#x27;, &#x27;country_id&#x27;]&#125;)</span><br><span class="line">[&#123;&#x27;id&#x27;: 14, &#x27;name&#x27;: &#x27;Azure Interior&#x27;, &#x27;country_id&#x27;: [233, &#x27;United States&#x27;]&#125;]</span><br></pre></td></tr></table></figure>

<p>对于 read 方法，我们使用了一个位置参数[14]来作为 ID 列表，以及一个关键字参数fields。还可以看到many-to-one关联字段如country_id，被成对获取，包含关联的记录 ID 和显示名称。在代码中处理数据时应记住这一点。</p>
<p>经常会使用search和 read 的组合，所以提供了一个search_read方法来在同一步中执行两者的操作。可通过如下命令来获取以上两段代码的同样结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">api.execute_kw(db, uid, pwd, &#x27;res.partner&#x27;, &#x27;search_read&#x27;, [domain], &#123;&#x27;fields&#x27;: [&#x27;id&#x27;, &#x27;name&#x27;, &#x27;country_id&#x27;]&#125;)</span><br></pre></td></tr></table></figure>

<p>补充：以上代码会为 read 方法传入所有 search 方法的结果，因此内容要较仅传入[14]多</p>
<p>search_read方法和 read 相似，但需要 domain代替 id 列表来作为第一个位置参数。需要说明在 read 和search_read中fields参数并非必须。如果不传入，则获取所有字段。这可能会带来对函数字段的大量计算，并且获取大量可能从来都不会用到的数据，所以通常建议明确传入字段列表。</p>
<h2 id="搜索和读取-API-方法"><a href="#搜索和读取-API-方法" class="headerlink" title="搜索和读取 API 方法"></a>搜索和读取 API 方法</h2><p>在第七章 <a target="_blank" rel="noopener" href="https://alanhou.org/odoo12-recordsets/">Odoo 12开发之记录集 - 使用模型数据</a>我们学习了用于生成记录的最重要的模型方法以及代码书写。但还有一些其它模型方法可用于更具体的操作，如：</p>
<ul>
<li>read([fields]) 类似于browse方法，但返回的不是记录集，而是包含按参数指定的字段的各行数据列表。每一行是一个字典。它提供可供 RPC 协议使用的数据的序列化展示，设计用于客户端程序中而非服务端逻辑中。</li>
<li>search_read([domain], [fields], offset&#x3D;0, limit&#x3D;None, order&#x3D;None)在读取结果记录列表之后执行搜索操作。设计用于 RPC 客户端，避免了反复进行读取结果和搜索的操作。</li>
</ul>
<p>所有其它模型方法都对 RPC 暴露，但以下划线开头的除外，这些是私有方法。也就是说我们可以像下面这样使用create, write,和unlink修改服务端数据：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; x = api.execute_kw(db, uid, pwd, &#x27;res.partner&#x27;, &#x27;create&#x27;, [&#123;&#x27;name&#x27;: &#x27;Packt Pub&#x27;&#125;])</span><br><span class="line">&gt;&gt;&gt; print(x)</span><br><span class="line">69</span><br><span class="line">&gt;&gt;&gt; api.execute_kw(db, uid, pwd, &#x27;res.partner&#x27;, &#x27;write&#x27;, [[x], &#123;&#x27;name&#x27;: &#x27;Packt Publishing&#x27;&#125;])</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; api.execute_kw(db, uid, pwd, &#x27;res.partner&#x27;, &#x27;read&#x27;,  [[x], [&#x27;id&#x27;, &#x27;name&#x27;]])</span><br><span class="line">[&#123;&#x27;id&#x27;: 69, &#x27;name&#x27;: &#x27;Packt Publishing&#x27;&#125;]</span><br><span class="line">&gt;&gt;&gt; api.execute_kw(db, uid, pwd, &#x27;res.partner&#x27;, &#x27;unlink&#x27;, [[x]])</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; api.execute_kw(db, uid, pwd, &#x27;res.partner&#x27;, &#x27;read&#x27;,  [[x], [&#x27;id&#x27;, &#x27;name&#x27;]])</span><br><span class="line">[]</span><br></pre></td></tr></table></figure>

<p>XML-RPC的一个缺陷是它不支持 None 值。有一个XML-RPC扩展可以支持 None 值，但这取决于我们客户端所依赖的具体XML-RPC库。不返回任何值的方法不能在XML-RPC中使用，因为默认返回的是 None。这也是为什么方法在结束时至少会带有一个return True语句。另一个方案是使用 Odoo 同时支持的JSON-RPC。OdooRPC对其进行运行，在稍后的<a href="#odoorpc">使用OdooRPC库</a>一节会进行使用。</p>
<p>应反复强调 Odoo 的外部 API 可在大部分编程语言中使用。<a target="_blank" rel="noopener" href="https://www.odoo.com/documentation/12.0/webservices/odoo.html">官方文档</a>中我们可以看到Ruby, PHP和Java实际示例。</p>
<blockquote>
<p>ℹ️以下划线开头的模块方法被认为是私有方法，不对XML-RPC暴露。</p>
</blockquote>
<h2 id="图书客户端XML-RPC-接口"><a href="#图书客户端XML-RPC-接口" class="headerlink" title="图书客户端XML-RPC 接口"></a>图书客户端XML-RPC 接口</h2><p>下面就来实现图书客户端应用。我们将使用两个文件：一个处理服务端的接口：library_api.py，另一个处理应用的用户界面：library.py。然后我们会使用现有的OdooRPC库来提供一个替代的实现方法。</p>
<p>我们将创建类来配置与 Odoo 服务端的连接，以及读取&#x2F;写入图书数据。这将暴露基本的增删改查方法：</p>
<ul>
<li>search_read()获取图书数据</li>
<li>create()创建图书</li>
<li>write()更新图书</li>
<li>unlink()删除图书</li>
</ul>
<p>选择一个目录来放置应用文件并创建library_api.py文件。首先添加类的构造方法，代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">from xmlrpc import client</span><br><span class="line"></span><br><span class="line">class LibraryAPI():</span><br><span class="line">	def __init__(self, srv, port, db, user, pwd):</span><br><span class="line">		common = client.ServerProxy(</span><br><span class="line">			&#x27;http://%s:%d/xmlrpc/2/common&#x27; % (srv, port))</span><br><span class="line">		self.api = client.ServerProxy(</span><br><span class="line">			&#x27;http://%s:%d/xmlrpc/2/object&#x27; % (srv, port))</span><br><span class="line">		self.uid = common.authenticate(db, user, pwd, &#123;&#125;)</span><br><span class="line">		self.pwd = pwd</span><br><span class="line">		self.db = db</span><br><span class="line">		self.model = &#x27;library.book&#x27;</span><br></pre></td></tr></table></figure>

<p>此处我们存储了所有创建执行模型调用的对象的所有信息：API引用、uid、密码、数据库名和要使用的模型。接下来我们定义一个帮助方法来执行调用。有赖于前面对象存储的数据该方法可以很精炼：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">def execute(self, method, arg_list, kwarg_dict=None):</span><br><span class="line">	return self.api.execute_kw(</span><br><span class="line">		self.db, self.uid, self.pwd, self.model,</span><br><span class="line">		method, arg_list, kwarg_dict or &#123;&#125;)</span><br></pre></td></tr></table></figure>

<p>现在就可以使用它来实现更高级的方法了。search_read()方法接收一个可选的 ID 列表来获取数据。如果没传入数据，则返回所有记录：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">def search_read(self, text=None):</span><br><span class="line">	domain = [(&#x27;name&#x27;, &#x27;ilike&#x27;, text)] if text else []</span><br><span class="line">	fields = [&#x27;id&#x27;, &#x27;name&#x27;]</span><br><span class="line">	return self.execute(&#x27;search_read&#x27;, [domain, fields])</span><br></pre></td></tr></table></figure>

<p>create()方法用于创建给定书名的新书并返回所创建记录的 ID：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">def create(self, title):</span><br><span class="line">	vals = &#123;&#x27;name&#x27;: title&#125;</span><br><span class="line">	return self.execute(&#x27;create&#x27;, [vals])</span><br></pre></td></tr></table></figure>

<p>write()方法中传入新书名和图书 ID 作为参数，并对该书执行写操作：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">def write(self, title, id):</span><br><span class="line">	vals = &#123;&#x27;name&#x27;: title&#125;</span><br><span class="line">	return self.execute(&#x27;write&#x27;, [[id], vals])</span><br></pre></td></tr></table></figure>

<p>然后我们可以实现unlink()方法，非常简单：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">def unlink(self, id):</span><br><span class="line">	return self.execute(&#x27;unlink&#x27;, [[id]])</span><br></pre></td></tr></table></figure>

<p>在该Python文件最后添加一段测试代码在运行时执行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">	# 测试配置</span><br><span class="line">	srv, db, port = &#x27;localhost&#x27;, &#x27;dev12&#x27;, 8069</span><br><span class="line">	user, pwd = &#x27;admin&#x27;, &#x27;admin&#x27;</span><br><span class="line">	api = LibraryAPI(srv, port, db, user, pwd)</span><br><span class="line">	from pprint import pprint</span><br><span class="line">	pprint(api.search_read())</span><br></pre></td></tr></table></figure>

<p>如果执行以上 Python 脚本，我们可以打印出图书的内容：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ python3 library_api.py</span><br><span class="line">[&#123;&#x27;id&#x27;: 56, &#x27;name&#x27;: &#x27;Brave New World&#x27;&#125;,</span><br><span class="line"> &#123;&#x27;id&#x27;: 40, &#x27;name&#x27;: &#x27;Hands-On System Programming with Linux&#x27;&#125;,</span><br><span class="line"> &#123;&#x27;id&#x27;: 41, &#x27;name&#x27;: &#x27;Lord of the Flies&#x27;&#125;,</span><br><span class="line"> &#123;&#x27;id&#x27;: 39, &#x27;name&#x27;: &#x27;Mastering Docker - Third Edition&#x27;&#125;,</span><br><span class="line"> &#123;&#x27;id&#x27;: 38, &#x27;name&#x27;: &#x27;Mastering Reverse Engineering&#x27;&#125;,</span><br><span class="line"> &#123;&#x27;id&#x27;: 55, &#x27;name&#x27;: &#x27;Odoo 11 Development Cookbook&#x27;&#125;,</span><br><span class="line"> &#123;&#x27;id&#x27;: 54, &#x27;name&#x27;: &#x27;Odoo Development Essentials 11&#x27;&#125;]</span><br></pre></td></tr></table></figure>

<p>现在已经有了对 Odoo 后端的简单封装，下面就可以处理命令行用户界面了。</p>
<h2 id="图书客户端用户界面"><a href="#图书客户端用户界面" class="headerlink" title="图书客户端用户界面"></a>图书客户端用户界面</h2><p>我的目标是学习如何写外部应用和 Odoo 服务之间的接口，前面已经实现了。但不能止步于此，我们还应让终端用户可以使用它。为使设置尽量简单，我们将使用 Python 内置功能来实现这个命令行应用。该功能是标准库自带的，因此不需要进行额外的安装。</p>
<p>在library_api.py 同目录，新建一个library.py文件。首先导入命令行参数解析器，然后导入LibraryAPI类，代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">from argparse import ArgumentParser</span><br><span class="line">from library_api import LibraryAPI</span><br></pre></td></tr></table></figure>

<p>下面我们来看看参数解析器接收的命令，有以下四个命令：</p>
<ul>
<li>搜索并列出图书</li>
<li>添加图书</li>
<li>设置(修改)书名</li>
<li>删除图书</li>
</ul>
<p>在命令行解析器中添加这些命令的代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">parser = ArgumentParser()</span><br><span class="line">parser.add_argument(</span><br><span class="line">	&#x27;command&#x27;,</span><br><span class="line">	choices=[&#x27;list&#x27;, &#x27;add&#x27;, &#x27;set-title&#x27;, &#x27;del&#x27;])</span><br><span class="line">parser.add_argument(&#x27;params&#x27;, nargs=&#x27;*&#x27;) # 可选参数</span><br><span class="line">args = parser.parse_args()</span><br></pre></td></tr></table></figure>

<p>这里 args 是一个包含传入脚本参数的对象，args.command是提供的命令，args.params是可选项，用于存放命令所需的其它参数。如果使用了不存在或错误的命令，参数解析器会进行处理并提示用户应输入的内容。有关argparse更完整的说明，请参考<a target="_blank" rel="noopener" href="https://docs.python.org/3/library/argparse.html">官方文档</a>。</p>
<p>下一步是执行所计划的操作。首先为 Odoo服务准备连接：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">srv, port, db = &#x27;localhost&#x27;, 8069, &#x27;dev12&#x27;</span><br><span class="line">user, pwd = &#x27;admin&#x27;, &#x27;admin&#x27;</span><br><span class="line">api = LibraryAPI(srv, port, db, user, pwd)</span><br></pre></td></tr></table></figure>

<p>第一行代码设置服务实例的一些固定参数以及要连接的数据库。本例中，我们连接 Odoo 服务本机(localhost)，监听8069默认端口，并使用 dev12数据库。如需连接其它服务器和数据库，请对参数进行相应调整。</p>
<p>这里硬编码了服务器地址并且密码使用了明文，显然与最佳实施相差甚远。我们应该包含配置步骤让客户提供相关设置信息，并以安全的方式进行存储。但此处我们的目标是学习使用 Odoo RPC，所以可把它看作概念代码，而非已完成的产品。下面写代码来利用 api 对象处理所支持的命令。我们可以先写list命令来列出图书：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if args.command == &#x27;list&#x27;:</span><br><span class="line">	text = args.params[0] if args.params else None</span><br><span class="line">	books = api.search_read(text)</span><br><span class="line">	for book in books:</span><br><span class="line">		print(&#x27;%(id)d %(name)s&#x27; % book)</span><br></pre></td></tr></table></figure>

<p>这里我们使用了LibraryAPI.search_read()来从服务端获取图书记录列表。然后遍历列表中每个元素并打印。我们使用 Python 字符串格式化来向用户显示每条图书记录，记录是一个键值对字典。下面添加add命令，这里使用了额外的书名作为参数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if args.command == &#x27;add&#x27;:</span><br><span class="line">	for title in args.params:</span><br><span class="line">		new_id = api.create(title)</span><br><span class="line">		print(&#x27;Book added with ID %d.&#x27; % new_id)</span><br></pre></td></tr></table></figure>

<p>因为主要的工作已经在LibraryAPI对象中完成，下面我们只要调用write()方法并向终端用户显示结果即可。 set-title命令允许我们修改已有图书的书名，应传入两个参数，新的书名和图书的 ID：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if args.command == &#x27;set-title&#x27;:</span><br><span class="line">	if len(args.params) != 2:</span><br><span class="line">		print(&quot;set command requires a title and ID.&quot;)</span><br><span class="line">	else:</span><br><span class="line">		book_id, title = int(args.params[0]), args.params[1]</span><br><span class="line">		api.write(title, book_id)</span><br><span class="line">		print(&#x27;Title set for Book ID %d.&#x27; % book_id)</span><br></pre></td></tr></table></figure>

<p>最终我们要实现 del 命令来删除图书记录，学到这里应该不再有任何挑战性了：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if args.command == &#x27;del&#x27;:</span><br><span class="line">	for param in args.params:</span><br><span class="line">		api.unlink(int(param))</span><br><span class="line">		print(&#x27;Book with ID %s deleted.&#x27; % param)</span><br></pre></td></tr></table></figure>

<p>到这里我们就完成了基础的 API CLI (命令行接口)了，读者可以尝试执行命令来查看效果。比如，我们可以运行本文开头<a href="#catalog">学习项目-图书目录客户端</a>中的命令。通过普通客户端来访问图书中的数据也会有助于确认该CLI是否如预想般运行。这是一个非常基础的应用，查看代码你应该可以想到一些改进它的方式。但要记住我们这里的目的是以相对有趣的方式举例说明Odoo RPC API的使用。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1515b0259da04f108b3ad0ce5645aa02~tplv-k3u1fbpfcp-zoom-1.image" alt="Odoo 12 客户端RPC命令行接口"></p>
<h2 id="使用OdooRPC库"><a href="#使用OdooRPC库" class="headerlink" title="使用OdooRPC库"></a>使用OdooRPC库</h2><p>另一个可以考虑的客户端库是OdooRPC。它是一个更流行的客户端库，使用JSON-RPC 协议而不是XML-RPC。事实上 Odoo 官方客户端使用的就是JSON-RPC，XML-RPC更多是用于支持向后兼容性。</p>
<blockquote>
<p>ℹ️OdooRPC库现在由 OCA 管理和持续维护。了解更多请参见<a target="_blank" rel="noopener" href="https://github.com/OCA/odoorpc">OCA</a>。</p>
</blockquote>
<p>OdooRPC库可通过PyPI安装：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip3 install --user odoorpc</span><br></pre></td></tr></table></figure>

<p>不管是使用JSON-RPC还是XML-RPC，Odoo API的使用方式并没什么分别。所以在下面我们可以看一些细节可能有区别，但这些客户端库的使用方式并没有什么分别。</p>
<p>OdooRPC库在创建新的odoorpc.ODOO对象时建立服务端连接，然后应使用ODOO.login()方法来创建用户会话。和服务端相似，会话有一个带有会话环境的 env 属性，包含用户 ID-uid 和上下文。我们可以使用OdooRPC来重新实现library_api.py对服务端的接口。它应提供相同的功能，但使用JSON-RPC代替XML-RPC来实施。在相同目录下创建library_odoorpc.py文件并加入如下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">from odoorpc import ODOO</span><br><span class="line"></span><br><span class="line">class LibraryAPI():</span><br><span class="line">	def __init__(self, srv, port, db, user, pwd):</span><br><span class="line">		self.api = ODOO(srv, port=port)</span><br><span class="line">		self.api.login(db, user, pwd)</span><br><span class="line">		self.uid = self.api.env.uid</span><br><span class="line">		self.model = &#x27;library.book&#x27;</span><br><span class="line">		self.Model = self.api.env[self.model]</span><br><span class="line"></span><br><span class="line">	def execute(self, method, arg_list, kwarg_dict=None):</span><br><span class="line">		return self.api.execute(</span><br><span class="line">			self.model,</span><br><span class="line">			method, *arg_list, **kwarg_dict)</span><br></pre></td></tr></table></figure>

<p>OdooRPC库实现Model和Recordset对象来模仿服务端对应的功能。目标是在客户端编程与服务端编程应基本一致。客户端使用的方法将通过存储在self.Model属性中的图书模型来利用这点。这里实现的execute()方法并不会在我们客户端中使用，仅用于与本文中讨论的其它实现进行对比。</p>
<p>下面我们来实现search_read(), create(), write()和unlink()这些客户端方法。在相同文件的LibraryAPI()类中添加如下方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">def search_read(self, text=None):</span><br><span class="line">	domain = [(&#x27;name&#x27;, &#x27;ilike&#x27;, text)] if text else []</span><br><span class="line">	fields = [&#x27;id&#x27;, &#x27;name&#x27;]</span><br><span class="line">	return self.Model.search_read(domain, fields)</span><br><span class="line"></span><br><span class="line">def create(self, title):</span><br><span class="line">	vals = &#123;&#x27;name&#x27;: title&#125;</span><br><span class="line">	return self.Model.create(vals)</span><br><span class="line"></span><br><span class="line">def write(self, title, id):</span><br><span class="line">	vals = &#123;&#x27;name&#x27;: title&#125;</span><br><span class="line">	self.Model.write(id, vals)</span><br><span class="line"></span><br><span class="line">def unlink(self, id):</span><br><span class="line">	return self.Model.unlink(id)</span><br></pre></td></tr></table></figure>

<p>注意这段代码和 Odoo 服务端代码相似，因为它使用了与 Odoo 中插件写法相近的 API。然后可以将library.py文件中的from library_api import LibraryAPI一行修改为library_odoorpc import LibraryAPI。现在再次运行library.py客户端应用进行测试，执行的效果和之前应该一致。</p>
<h2 id="了解ERPpeek客户端"><a href="#了解ERPpeek客户端" class="headerlink" title="了解ERPpeek客户端"></a>了解ERPpeek客户端</h2><p>ERPpeek是一个多功能工具，既可以作为交互式命令行接口(CLI)也可以作为 Python库，它提供了比xmlrpc库更便捷的 API。它在PyPi索引中，可通过如下命令安装：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip3 install --user erppeek</span><br></pre></td></tr></table></figure>

<p>ERPpeek不仅可用作 Python 库，它还可作为 CLI 来在服务器上执行管理操作。Odoo shell 命令在主机上提供了一个本地交互式会话功能，而erppeek库则为网络上的客户端提供了一个远程交互式会话。打开命令行，通过以下命令可查看能够使用的选项：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">erppeek --help</span><br></pre></td></tr></table></figure>

<p>下面一起来看看一个示例会话：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ erppeek --server=&#x27;http://192.168.16.161:8069&#x27; -d dev12 -uadmin</span><br><span class="line">Usage (some commands):</span><br><span class="line">    models(name)                    # List models matching pattern</span><br><span class="line">    model(name)                     # Return a Model instance</span><br><span class="line">... </span><br><span class="line"></span><br><span class="line">Password for &#x27;admin&#x27;:</span><br><span class="line">Logged in as &#x27;admin&#x27;</span><br><span class="line">dev12 &gt;&gt;&gt; model(&#x27;res.users&#x27;).count()</span><br><span class="line">3</span><br><span class="line">dev12 &gt;&gt;&gt; rec = model(&#x27;res.partner&#x27;).browse(14)</span><br><span class="line">dev12 &gt;&gt;&gt; rec.name</span><br><span class="line">&#x27;Azure Interior&#x27;</span><br></pre></td></tr></table></figure>

<p>如上所见，建立了服务端的连接，执行上下文引用了model() 方法来获得模型实例并对其进行操作。连接使用的erppeek.Client实例也可通过客户端变量来使用。 值得一提的是它可替代网页客户端来管理所安装的插件模块：</p>
<ul>
<li>client.modules()列出可用或已安装模块</li>
<li>client.install()执行模块安装</li>
<li>client.upgrade()执行模块升级</li>
<li>client.uninstall()卸载模块</li>
</ul>
<p>因此ERPpeek可作为 Odoo 服务端远程管理的很好的服务。有关ERPpeek的更多细节请见 <a target="_blank" rel="noopener" href="https://github.com/tinyerp/erppeek">GitHub</a>。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0a340ec4fe0e4eb388da1d3adea46334~tplv-k3u1fbpfcp-zoom-1.image" alt="Odoo 12 ERPpeek"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文的目标是学习外部 API 如何运作以及它们能做些什么。一开始我们通过一个简单的Python XML-RPC客户端来进行探讨，但外部 API 可用于其它编程语言。事实上官方文档中包含了Java, PHP和Ruby的代码示例。</p>
<p>有很多库可处理XML-RPC或JSON-RPC，有些是通用的，有些仅适用于 Odoo。我们使用了一个指定库OdooRPC。</p>
<p>以上我们就完结了本文有关编程 API 和业务逻辑的学习。是时候深入视图和用户界面了。在下一篇文章中，我们进一步学习网页客户端所提供的后台视图和用户体验。</p>
<p> </p>
<p>☞☞☞第十章 <a target="_blank" rel="noopener" href="https://alanhou.org/odoo12-backend-views/">Odoo 12开发之后台视图 - 设计用户界面</a></p>
<p> </p>
<h2 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h2><p>以下参考资料可用于补充本文所学习的内容：</p>
<ul>
<li>Odoo web 服务的<a target="_blank" rel="noopener" href="https://www.odoo.com/documentation/12.0/webservices/odoo.html">官方文档</a>中包含了 Python 以外的其它编程语言示例</li>
<li><a target="_blank" rel="noopener" href="https://pythonhosted.org/OdooRPC/">OdooRPC文档</a></li>
<li><a target="_blank" rel="noopener" href="https://erppeek.readthedocs.io/en/latest/">ERPpeek文档</a></li>
</ul>
<p>本文首发地址：<a target="_blank" rel="noopener" href="https://alanhou.org/developer-mode-odoo12/">Alan Hou 的个人博客</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://alanhou.github.io/2019/01/14/odoo-essentials-12-chapter8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Alan Hou">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Alan Hou的个人博客">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Alan Hou的个人博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2019/01/14/odoo-essentials-12-chapter8/" class="post-title-link" itemprop="url">第八章 Odoo 12开发之业务逻辑 – 业务流程的支持</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2019-01-14 00:00:00" itemprop="dateCreated datePublished" datetime="2019-01-14T00:00:00+08:00">2019-01-14</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2023-02-03 13:44:31" itemprop="dateModified" datetime="2023-02-03T13:44:31+08:00">2023-02-03</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>本文为<a target="_blank" rel="noopener" href="https://alanhou.org/odoo-12-development/">最好用的免费ERP系统Odoo 12开发手册</a>系列文章第八篇。</p>
<p>在前面的文章中，我们学习了模型层、如何创建应用数据结构以及如何使用 ORM API 来存储查看数据。本文中我们将利用前面所学的模型和记录集知识实现应用中常用的业务逻辑模式。</p>
<p>本文的主要内容有：</p>
<ul>
<li>以文件为中心工作流的阶段(stage)</li>
<li>ORM 方法装饰器：@api.multi, @api.one和@api.model</li>
<li>onchange方法，与用户即时交互</li>
<li>使用 ORM 内置方法，如create, write 和 unlink</li>
<li>Mail 插件提供的消息和活动功能</li>
<li>创建向导来帮助用户执行复杂操作</li>
<li>使用日志消息优化系统监测</li>
<li>抛出异常以在出错时给用户反馈</li>
<li>使用单元测试来进行代码质量检查</li>
<li>开发工具，调试器等开发者工具</li>
</ul>
<h2 id="开发准备"><a href="#开发准备" class="headerlink" title="开发准备"></a>开发准备</h2><p>本文中我们将创建一个依赖于之前文章创建的library_app和library_member模块的library_checkout插件模块。这些模块的代码请参见 <a target="_blank" rel="noopener" href="https://github.com/alanhou/odoo12-development/tree/master/chapter6">GitHub 仓库</a>。这两个插件模块都应放置在add-ons路径中(参见命令行–addons-path或~&#x2F;.odoorc 配置文件中的addons_path)，这样我们才能安装和使用。本文完成后的代码请见 <a target="_blank" rel="noopener" href="https://github.com/alanhou/odoo12-development/tree/master/chapter8">GitHub 仓库</a>。</p>
<h2 id="学习项目-–-library-checkout模块"><a href="#学习项目-–-library-checkout模块" class="headerlink" title="学习项目 – library_checkout模块"></a>学习项目 – library_checkout模块</h2><p>在前面章节的学习中，我们为图书应用搭建了主数据结构。现在需要为图书会员添加借书的功能了。也就是说需要追踪图书是否可借以及归还的记录。每本书的借阅都有一个生命周期，从图书登记选中到图书被归还。这是一个可通过看板视图表示的简单工作流，看板视图中每个阶段(stage)可展现为一列，工作项和借阅请求流从左侧列到右侧列，直至完成为止。</p>
<p>在本文中，我们集中学习实现这一功能的数据模型和业务逻辑。用户界面部分的详情将在第十章 <a target="_blank" rel="noopener" href="https://alanhou.org/odoo12-backend-views/">Odoo 12开发之后台视图 - 设计用户界面</a>和第十一章 <a target="_blank" rel="noopener" href="https://alanhou.org/odoo12-kanban-qweb/">Odoo 12开发之看板视图和用户端 QWeb</a>中讨论。</p>
<p>图书借阅模型包含：</p>
<ul>
<li>借阅图书的会员（必填）</li>
<li>借阅请求日期（默认为当天）</li>
<li>负责借阅请求的图书管理员（默认为当前用户）</li>
<li>借阅路线，包含请求借阅的一本或多本图书</li>
</ul>
<p>要支持并存档借阅生命周期，需要添加如下内容：</p>
<ul>
<li>请求的阶段：已选中、可借阅、已借出、已归还或已取消</li>
<li>借阅日期，图书借出的日期</li>
<li>关闭日期，图书归还的日期</li>
</ul>
<p>我们将开始创建一个新的模块library_checkout并实现图书借阅模型的初始版本。与此前章节相比此处并没有引入新的知识，用于提供一个基础供本文后续创建新功能。</p>
<p>在其它图书插件模块的同级路径下创建一个library_checkout目录：</p>
<p>1、首先添加__manifest__.py文件并加入如下内容：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &#x27;name&#x27;: &#x27;Library Book Borrowing&#x27;,</span><br><span class="line">    &#x27;description&#x27;: &#x27;Members can borrow books from the library.&#x27;,</span><br><span class="line">    &#x27;author&#x27;: &#x27;Alan Hou&#x27;,</span><br><span class="line">    &#x27;depends&#x27;: [&#x27;library_member&#x27;],</span><br><span class="line">    &#x27;data&#x27;:[</span><br><span class="line">        &#x27;security/ir.model.access.csv&#x27;,</span><br><span class="line">        &#x27;views/library_menu.xml&#x27;,</span><br><span class="line">        &#x27;views/checkout_view.xml&#x27;,</span><br><span class="line">    ],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、在模块目录下创建__init__.py文件，并添加如下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">from . import models</span><br></pre></td></tr></table></figure>

<p>3、创建models&#x2F;<strong>init</strong>.py文件并添加：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">from . import library_checkout</span><br></pre></td></tr></table></figure>

<p>4、在models&#x2F;library_checkout.py中添加如下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">from odoo import api, exceptions, fields, models</span><br><span class="line"></span><br><span class="line">class Checkout(models.Model):</span><br><span class="line">    _name = &#x27;library.checkout&#x27;</span><br><span class="line">    _description = &#x27;Checkout Request&#x27;</span><br><span class="line">    member_id = fields.Many2one(</span><br><span class="line">        &#x27;library.member&#x27;,</span><br><span class="line">        required=True)</span><br><span class="line">    user_id = fields.Many2one(</span><br><span class="line">        &#x27;res.users&#x27;,</span><br><span class="line">        &#x27;Librarian&#x27;,</span><br><span class="line">        default=lambda s: s.env.uid)</span><br><span class="line">    request_date = fields.Date(</span><br><span class="line">        default=lambda s: fields.Date.today())</span><br><span class="line">    line_ids = fields.One2many(</span><br><span class="line">        &#x27;library.checkout.line&#x27;,</span><br><span class="line">        &#x27;checkout_id&#x27;,</span><br><span class="line">        string=&#x27;Borrowed Books&#x27;,)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class CheckoutLine(models.Model):</span><br><span class="line">    _name = &#x27;library.checkout.line&#x27;</span><br><span class="line">    _description = &#x27;Borrow Request Line&#x27;</span><br><span class="line">    checkout_id = fields.Many2one(&#x27;library.checkout&#x27;)</span><br><span class="line">    book_id = fields.Many2one(&#x27;library.book&#x27;)</span><br></pre></td></tr></table></figure>

<p>下面就要添加数据文件了，添加访问规则、菜单项和一些基础视图，这样模块可以最小化的运行起来。</p>
<p>5、添加security&#x2F;ir.model.access.csv文件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">id,name,model_id:id,group_id:id,perm_read,perm_write,perm_create,perm_unlink</span><br><span class="line">checkout_user,Checkout User,model_library_checkout,library_app.library_group_user,1,1,1,0</span><br><span class="line">checkout_line_user,Checkout Line User ,model_library_checkout_line,library_app.library_group_user,1,1,1,1</span><br><span class="line">checkout_manager,Checkout Manager,model_library_checkout,library_app.library_group_manager,1,1,1,1</span><br></pre></td></tr></table></figure>

<p>6、菜项项通过views&#x2F;library_menu.xml实现：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;odoo&gt;</span><br><span class="line">    &lt;act_window id=&quot;action_library_checkout&quot;</span><br><span class="line">        name=&quot;Checkouts&quot;</span><br><span class="line">        res_model=&quot;library.checkout&quot;</span><br><span class="line">        view_mode=&quot;tree,form&quot; /&gt;</span><br><span class="line">    &lt;menuitem id=&quot;menu_library_checkout&quot;</span><br><span class="line">        name=&quot;Checkout&quot;</span><br><span class="line">        action=&quot;action_library_checkout&quot;</span><br><span class="line">        parent=&quot;library_app.menu_library&quot; /&gt;</span><br><span class="line">&lt;/odoo&gt;</span><br></pre></td></tr></table></figure>

<p>7、视图通过views&#x2F;checkout_view.xml文件实现：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; ?&gt;</span><br><span class="line">&lt;odoo&gt;</span><br><span class="line">    &lt;record id=&quot;view_tree_checkout&quot; model=&quot;ir.ui.view&quot;&gt;</span><br><span class="line">        &lt;field name=&quot;name&quot;&gt;Checkout Tree&lt;/field&gt;</span><br><span class="line">        &lt;field name=&quot;model&quot;&gt;library.checkout&lt;/field&gt;</span><br><span class="line">        &lt;field name=&quot;arch&quot; type=&quot;xml&quot;&gt;</span><br><span class="line">            &lt;tree&gt;</span><br><span class="line">                &lt;field name=&quot;request_date&quot; /&gt;</span><br><span class="line">                &lt;field name=&quot;member_id&quot; /&gt;</span><br><span class="line">            &lt;/tree&gt;</span><br><span class="line">        &lt;/field&gt;</span><br><span class="line">    &lt;/record&gt;</span><br><span class="line"></span><br><span class="line">    &lt;record id=&quot;view_form_checkout&quot; model=&quot;ir.ui.view&quot;&gt;</span><br><span class="line">        &lt;field name=&quot;name&quot;&gt;Checkout Form&lt;/field&gt;</span><br><span class="line">        &lt;field name=&quot;model&quot;&gt;library.checkout&lt;/field&gt;</span><br><span class="line">        &lt;field name=&quot;arch&quot; type=&quot;xml&quot;&gt;</span><br><span class="line">            &lt;form&gt;</span><br><span class="line">                &lt;sheet&gt;</span><br><span class="line">                    &lt;group&gt;</span><br><span class="line">                        &lt;field name=&quot;member_id&quot; /&gt;</span><br><span class="line">                        &lt;field name=&quot;request_date&quot; /&gt;</span><br><span class="line">                        &lt;field name=&quot;user_id&quot; /&gt;</span><br><span class="line">                        &lt;field name=&quot;line_ids&quot; /&gt;</span><br><span class="line">                    &lt;/group&gt;</span><br><span class="line">                &lt;/sheet&gt;</span><br><span class="line">            &lt;/form&gt;</span><br><span class="line">        &lt;/field&gt;</span><br><span class="line">    &lt;/record&gt;</span><br><span class="line">&lt;/odoo&gt;</span><br></pre></td></tr></table></figure>

<p>现在就可以在我们的 Odoo 工作数据库中安装这个模块，并准备开始添加更多功能了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~/odoo-dev/odoo/odoo-bin -d dev12 -i library_checkout</span><br></pre></td></tr></table></figure>

<h2 id="以文档为中心工作流的阶段-stage"><a href="#以文档为中心工作流的阶段-stage" class="headerlink" title="以文档为中心工作流的阶段(stage)"></a>以文档为中心工作流的阶段(stage)</h2><p>在 Odoo 中，我们可以实现以文档(document)为中心的工作流。我们这里说的文档包括销售订单、项目任务或人事申请。所有这些都遵循一个特定的生命周期，它们都在完成时才被创建。它们都被记录在一个文档中，按照一系列可能的阶段推进，直至完成。</p>
<p>如果把各阶段以列展示在面板中，把文档作为这些列中的工作项，就可以得到一个看板(Kanban)，一个快速查看工作进度的视图。实现这些进度步骤有两种方法，通常称为状态和阶段。</p>
<p>状态通过预定义的闭合选项列表来实现。它便于实现业务规则，并且模型和视图对 state 字段有特别的支持，根据当前状态来带有必填和隐藏属性集。状态列表有一个劣势，就是它是预定义并且闭合的，因此无法按具体流程需求来做调整。</p>
<p>阶段通过关联模型实现，阶段列表是开放的，可被配置来满足当前流程需求。可以轻易地修改引用阶段列表：删除、添加或渲染这些阶段。它的劣势是对流程自动化不可靠，因为阶段列表可被修改，自动化规则就无法依赖于具体的阶段 ID 或描述。</p>
<p>获取两种方法优势的方式是将阶段映射到状态中。文档组织到可配置的阶段中，然后间接关联到对于自动化业务逻辑可靠的状态码中。我们将在library_checkout&#x2F;models&#x2F;library_checkout_stage.py文件中实现library.checkout.stage模型，代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">from odoo import fields, models</span><br><span class="line"></span><br><span class="line">class CheckoutStage(models.Model):</span><br><span class="line">    _name = &#x27;library.checkout.stage&#x27;</span><br><span class="line">    _description = &#x27;Checkout Stage&#x27;</span><br><span class="line">    _order = &#x27;sequence,name&#x27;</span><br><span class="line"></span><br><span class="line">    name = fields.Char()</span><br><span class="line">    sequence = fields.Integer(default=10)</span><br><span class="line">    fold = fields.Boolean()</span><br><span class="line">    active = fields.Boolean(default=True)</span><br><span class="line">    state = fields.Selection(</span><br><span class="line">        [(&#x27;new&#x27;, &#x27;New&#x27;),</span><br><span class="line">        (&#x27;open&#x27;, &#x27;Borrowed&#x27;),</span><br><span class="line">        (&#x27;done&#x27;, &#x27;Returned&#x27;),</span><br><span class="line">        (&#x27;cancel&#x27;, &#x27;Cancelled&#x27;)],</span><br><span class="line">        default=&#x27;new&#x27;,</span><br><span class="line">    )</span><br></pre></td></tr></table></figure>

<p>这里我们可以看到 state 字段，允许每个阶段与四个基本状态映射。sequence字段很重要，要配置顺序，阶段应在看板和阶段选择列表中展示。fold 布尔字段是看板用于将一些列默认折叠，这样其内容就不会马上显示出来。折叠通常用于已完成或取消的阶段。新的代码一定不要忘记加入到models&#x2F;<strong>init</strong>.py文件中，当前内容为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">from . import library_checkout_stage</span><br><span class="line">from . import library_checkout</span><br></pre></td></tr></table></figure>

<p>下一步，我们需要向图书借阅模型添加阶段字段stage。编辑library_checkout&#x2F;models&#x2F;library_checkout.py文件，在 Checkout 类的最后面(line_ids 字段后)添加如下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@api.model</span><br><span class="line">def _default_stage(self):</span><br><span class="line">    Stage = self.env[&#x27;library.checkout.stage&#x27;]</span><br><span class="line">    return Stage.search([], limit=1)</span><br><span class="line"></span><br><span class="line">@api.model</span><br><span class="line">def _group_expand_stage_id(self, stages, domain, order):</span><br><span class="line">    return stages.search([], order=order)</span><br><span class="line"></span><br><span class="line">stage_id = fields.Many2one(</span><br><span class="line">    &#x27;library.checkout.stage&#x27;,</span><br><span class="line">    default=_default_stage,</span><br><span class="line">    group_expand=&#x27;_group_expand_stage_id&#x27;)</span><br><span class="line">state = fields.Selection(related=&#x27;stage_id.state&#x27;)</span><br></pre></td></tr></table></figure>

<p>stage_id是一个与阶段模型的 many-to-one关联。我们还添加了 state 字段，这是一个让阶段的 state 字段在当前模型中可用的关联字段，这样才能在视图中使用。阶段的默认值由_default_stage() 函数来计算，它返回阶段模型的第一条记录。因为阶段模型已通过 sequence 排序，所以返回的是 sequence 值最小的一条记录。</p>
<p>group_expand参数重载字段的分组方式，默认的分组操作行为是仅能看到使用过的阶段，而不带有借阅文档的阶段不会显示。在我们的例子中，我们想要不同的效果：我们要看到所有的阶段，哪怕它没有文档。_group_expand_stage_id() 帮助函数返回分组操作需使用组记录列表。本例中返回所有已有阶段，不论其中是否包含图书借阅记录。</p>
<blockquote>
<p>ℹ️<strong>Odoo 10中的修改</strong><br>group_expand字段在Odoo 10中引入，但在官方文档中没有介绍。使用示例在 Odoo 的源代码中可以找到，比如在 Project 应用中：<a target="_blank" rel="noopener" href="https://github.com/odoo/odoo/blob/12.0/addons/project/models/project.py">GitHub 仓库</a>。</p>
</blockquote>
<p>既然我们添加了新模块，就应该在security&#x2F;ir.model.access.csv文件中加入对应的安全权限，代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">checkout_stage_user,Checkout Stage User,model_library_checkout_stage,library_app.library_group_user,1,0,0,0</span><br><span class="line">checkout_stage_manager,Checkout Stage Manager,model_library_checkout_stage,library_app.library_group_manager,1,1,1,1</span><br></pre></td></tr></table></figure>

<p>我们需要一组阶段来进行操作，所以下面来为模块添加默认数据。创建data&#x2F;library_checkout_stage.xml文件并加入如下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;odoo noupdate=&quot;1&quot;&gt;</span><br><span class="line">    &lt;record id=&quot;stage_10&quot; model=&quot;library.checkout.stage&quot;&gt;</span><br><span class="line">        &lt;field name=&quot;name&quot;&gt;Draft&lt;/field&gt;</span><br><span class="line">        &lt;field name=&quot;sequence&quot;&gt;10&lt;/field&gt;</span><br><span class="line">        &lt;field name=&quot;state&quot;&gt;new&lt;/field&gt;</span><br><span class="line">    &lt;/record&gt;</span><br><span class="line">    &lt;record id=&quot;stage_20&quot; model=&quot;library.checkout.stage&quot;&gt;</span><br><span class="line">        &lt;field name=&quot;name&quot;&gt;Borrowed&lt;/field&gt;</span><br><span class="line">        &lt;field name=&quot;sequence&quot;&gt;20&lt;/field&gt;</span><br><span class="line">        &lt;field name=&quot;state&quot;&gt;open&lt;/field&gt;</span><br><span class="line">    &lt;/record&gt;</span><br><span class="line">    &lt;record id=&quot;stage_90&quot; model=&quot;library.checkout.stage&quot;&gt;</span><br><span class="line">        &lt;field name=&quot;name&quot;&gt;Completed&lt;/field&gt;</span><br><span class="line">        &lt;field name=&quot;sequence&quot;&gt;90&lt;/field&gt;</span><br><span class="line">        &lt;field name=&quot;state&quot;&gt;done&lt;/field&gt;</span><br><span class="line">    &lt;/record&gt;</span><br><span class="line">    &lt;record id=&quot;stage_95&quot; model=&quot;library.checkout.stage&quot;&gt;</span><br><span class="line">        &lt;field name=&quot;name&quot;&gt;Cacelled&lt;/field&gt;</span><br><span class="line">        &lt;field name=&quot;sequence&quot;&gt;95&lt;/field&gt;</span><br><span class="line">        &lt;field name=&quot;state&quot;&gt;cancel&lt;/field&gt;</span><br><span class="line">    &lt;/record&gt;</span><br><span class="line">&lt;/odoo&gt;</span><br></pre></td></tr></table></figure>

<p>要使文件生效，需先在library_checkout&#x2F;<strong>manifest</strong>.py文件中添加该文件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">    &#x27;data&#x27;:[</span><br><span class="line">...</span><br><span class="line">        &#x27;data/library_checkout_stage.xml&#x27;,</span><br><span class="line">    ],</span><br></pre></td></tr></table></figure>

<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b4a3cb2556464c60b4e9084500306b8d~tplv-k3u1fbpfcp-zoom-1.image" alt="Odoo 12图书项目 stages"></p>
<p>备注：上图为通过开发者菜单中Edit View: Form编辑添加了 stage_id 后的效果。</p>
<h2 id="ORM-方法装饰器"><a href="#ORM-方法装饰器" class="headerlink" title="ORM 方法装饰器"></a>ORM 方法装饰器</h2><p>就我们目前碰到的 Odoo 中 Python 代码，装饰器，如@api.multi通常用于模型方法中。这对 ORM 非常重要，允许它给这些方法特殊用法。下面就来看看有哪些 ORM 装饰器以及如何使用。</p>
<h3 id="记录集方法：-api-multi"><a href="#记录集方法：-api-multi" class="headerlink" title="记录集方法：@api.multi"></a>记录集方法：@api.multi</h3><p>大多数情况下，我们需要一个自定义方法来对记录集执行一些操作。此时就需要使用@api.multi，并且此处self参数就是要操作的记录集。方法的逻辑通常会包含对 self 的遍历。@api.multi是最常用的装饰器。</p>
<blockquote>
<p><strong>小贴士：</strong> 如果模型方法没有添加装饰器，默认就使用@api.multi。</p>
</blockquote>
<h3 id="单例记录方法：-api-one"><a href="#单例记录方法：-api-one" class="headerlink" title="单例记录方法：@api.one"></a>单例记录方法：@api.one</h3><p>有些情况下方法用于操作单条记录（单例），此时可使用@api.one装饰器。现在仍可使用@api.one，但在 Odoo 9中已声明为弃用。它包裹装饰的方法，进行 for 循环遍历，它调用装饰方法，一次一条记录，然后返回一个结果列表。因此在@api.one装饰的方法内，self 一定是单例。</p>
<blockquote>
<p><strong>小贴士：</strong> @api.one的返回值有些搞怪，它返回一个列表，而不实际方法返回的数据结构。比如方法代码如果返回字典，实际返回值是一个字典值列表。这种误导性也是该方法被弃用的主要原因。</p>
</blockquote>
<p>对于要操作单条记录的方法，我们应还是使用@api.multi，在代码顶部添加一行self.ensure_one()，来确保操作的是单条记录。</p>
<h3 id="类静态方法：-api-model"><a href="#类静态方法：-api-model" class="headerlink" title="类静态方法：@api.model"></a>类静态方法：@api.model</h3><p>有时方法需要在类级别而不是具体记录上操作。面向对象编程语言中，这称之为静态方法。这些类级别的静态方法应由@api.model装饰。在这些情况下，self 应作为模型的引用 ，无需包含实际记录。</p>
<blockquote>
<p>ℹ️@api.model装饰的方法无法用于用户界面按钮，在这种情况下，应使用@api.multi。</p>
</blockquote>
<h3 id="onchange-方法"><a href="#onchange-方法" class="headerlink" title="onchange 方法"></a>onchange 方法</h3><p>onchange由用户界面表单视图触发，当用户编辑指定字段值时，立即执行一段业务逻辑。这可用于执行验证，向用户显示消息或修改表单中的其它字段。支持该逻辑的方法就使用@api.onchange(‘fld1’, ‘fld2’, …)装饰。装饰器的参数是用户界面通过编辑需触发方法的字段名。</p>
<blockquote>
<p><strong>小贴士：</strong> 通过为字段添加属性on_change&#x3D;”0”可在特定表单中关闭 on change 行为，比如<field name="fld1" on_change="0" /></p>
</blockquote>
<p>在方法内，self 参数是带有当前表单数据的一条虚拟记录。如果在记录上设置了值，就会在用户界面表单中被修改。注意它并没有向数据库实际写入记录，而是提供信息来修改 UI表单中的数据。无需返回信息，但可以返回一个字典结构的警告信息来显示在用户界面中。</p>
<p>作为示例，我们可以使用它来执行借阅表单中的部分自动化：在图书会员变更时，请求日期设置为当天，并且显示一个警告信息告知用户。下面我们就在library_checkout&#x2F;models&#x2F;library_checkout.py文件中添加如下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@api.onchange(&#x27;member_id&#x27;)</span><br><span class="line">def onchange_member_id(self):</span><br><span class="line">    today = fields.Date.today()</span><br><span class="line">    if self.request_date != today:</span><br><span class="line">        self.request_date = fields.Date.today()</span><br><span class="line">        return &#123;</span><br><span class="line">            &#x27;warning&#x27;:&#123;</span><br><span class="line">                &#x27;title&#x27;: &#x27;Changed Request Date&#x27;,</span><br><span class="line">                &#x27;message&#x27;: &#x27;Request date changed to today.&#x27;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>通过用户界面修改member_id字段时，此处使用了@api.onchange装饰器来触发一些逻辑。实际方法不存在关联，但按照惯例名称应以onchange_开头，方法中我们更新了request_date的值并返回警告信息。在onchange方法内，self 表示一条虚拟记录，它包含当前正在编辑的记录的所有字段，我们可以与这些字段进行交互。大多数情况下我们想要根据修改字段设置的值自动在其它字段填充值。本例中，我们将request_date更新为当天。</p>
<p>onchange 方法无需返回任何值，但可以返回一个包含警告或作用域键的字典：</p>
<ul>
<li>警告的键应描述显示在对话框中的消息，如{‘title’: ‘Message Title’, ‘message’: ‘Message Body’}</li>
<li>作用域键可设置或修改其它字段的域属性。通过让to-many字段仅展示在当下有意义的字段，会使得用户界面更加友好。作用域键类似这样：{‘user_id’: [(‘email’, ‘!&#x3D;’, False)]}</li>
</ul>
<h3 id="其它模型方法装饰器"><a href="#其它模型方法装饰器" class="headerlink" title="其它模型方法装饰器"></a>其它模型方法装饰器</h3><p>以下装饰器也会经常使用到，它们与模型内部行为有关，在第六章 <a target="_blank" rel="noopener" href="https://alanhou.org/odoo12-structuring-data/">Odoo 12开发之模型 - 结构化应用数据</a>中进行了详细讨论。罗列如下供您参考：</p>
<ul>
<li>@api.depends(fld1,…)用于计算字段函数，来识别(重新)计算应触发什么样的修改。必须设置在计算字段值上，否则会报错。</li>
<li>@api.constrains(fld1,…)用于模型验证函数并在任意参数中包含的字段修改时执行检查。它不应向数据库写入修改，如检查失败，则抛出异常。</li>
</ul>
<h2 id="使用-ORM-内置方法"><a href="#使用-ORM-内置方法" class="headerlink" title="使用 ORM 内置方法"></a>使用 ORM 内置方法</h2><p>上一部分讨论的装饰器允许我们为模型添加一些功能，如实施验证或自动运算。</p>
<p>ORM 提供对模型数据执行增删改查(CRUD)操作的方法。下面我们来探讨如何扩展写操作来支持自定义逻辑。读取数据的主要方法search()和browse()在中第七章 <a target="_blank" rel="noopener" href="https://alanhou.org/odoo12-recordsets/">Odoo 12开发之记录集 - 使用模型数据</a>已进行讨论。</p>
<h3 id="写入模型数据的方法"><a href="#写入模型数据的方法" class="headerlink" title="写入模型数据的方法"></a>写入模型数据的方法</h3><p>ORM 为三种基本写操作提供了三个方法，如下所示：</p>
<ul>
<li><Model>.create(values)在模型上创建新记录，它返回所创建记录。</li>
<li><Recordset>.write(values) 更新记录集中的字段值，它不返回值。</li>
<li><Recordset>.unlink()从数据库中删除记录，它不返回值。</li>
</ul>
<p>values参数是一个字典，映射要写入的字段名和值。这些方法由@api.multi装饰，除create()方法使用@api.model装饰器外。</p>
<blockquote>
<p>ℹ️<strong>Odoo 12中的修改</strong><br>create()现在也可批量创建数据，这通过把单个字典对象修改为字典对象列表来传参进行实现。这由带有@api.model_create_multi装饰器的create() 方法来进行支持。</p>
</blockquote>
<p>有些情况下，我们需要扩展这些方法来添加一些业务逻辑，在这些操作执行时触发。通过将逻辑放到自定义方法的适当位置，我们可以让代码在主操作执行之前或之后运行。</p>
<p>我们将使用借阅模型类创建一个示例：添加两个日期字段来记录进入 open 状态的时间和进入 closed 状态的时间。这是计算字段所无法实现的，我们还将添加一个检查来阻止对已为 done 状态的创建借阅。</p>
<p>因此我们应在 Checkout 类中添加两个新字段，在library_checkout&#x2F;models&#x2F;library_checkout.py文件中添加如下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">checkout_date = fields.Date(readonly=True)</span><br><span class="line">closed_date = fields.Date(readonly=True)</span><br></pre></td></tr></table></figure>

<p>现在就可以创建自定义的create()方法来设置checkout_date了，如果状态正确则创建，而如果已经是完成状态则不予创建，代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@api.model</span><br><span class="line">def create(self, vals):</span><br><span class="line">    # Code before create: should use the `vals` dict</span><br><span class="line">    if &#x27;stage_id&#x27; in vals:</span><br><span class="line">        Stage = self.env[&#x27;library.checkout.stage&#x27;]</span><br><span class="line">        new_state = Stage.browse(vals[&#x27;stage_id&#x27;]).state</span><br><span class="line">        if new_state == &#x27;open&#x27;:</span><br><span class="line">            vals[&#x27;checkout_date&#x27;] = fields.Date.today()</span><br><span class="line">    new_record = super().create(vals)</span><br><span class="line">    # Code after create: can use the `new_record` created</span><br><span class="line">    if new_record.state == &#x27;done&#x27;:</span><br><span class="line">        raise exceptions.UserError(</span><br><span class="line">            &#x27;Not allowed to create a checkout in the done state.&#x27;)</span><br><span class="line">    return new_record</span><br></pre></td></tr></table></figure>

<p>注意在实际新记录创建之前，不存在其它记录，仅带有用于创建记录的值的字典。这也就是我们使用browse()来获取新记录stage_id的原因，然后对值进行相应的检查。作为对比，一旦创建了新记录，相应的操作就变简单了，使用对象的点号标记即可：new_record.state。在执行super().create(vals)命令之前可以对值字典进行修改，我们使用它在状态合适的情况下写入checkout_date。</p>
<blockquote>
<p>ℹ️<strong>Odoo 11中的修改</strong><br>Python 3中有一种super()的简写方式，我们上例中使用的就是这种方式。而在 Python 2中则写成super(Checkout, self).create(vals)，其中 Checkout 为代码所在的 Python 类名。在 Python 3这种语法仍然可用，但同时带有简写语法：super().create(vals)。</p>
</blockquote>
<p>修改记录时，如果订阅进入的是合适的状态我们需要更新checkout_date和closed_date。实现这一功能需要使用自定义的write() 方法，代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@api.multi</span><br><span class="line">def write(self, vals):</span><br><span class="line">    # Code before write: can use `self`, with the old values</span><br><span class="line">    if &#x27;stage_id&#x27; in vals:</span><br><span class="line">        Stage = self.env[&#x27;library.checkout.stage&#x27;]</span><br><span class="line">        new_state = Stage.browse(vals[&#x27;stage_id&#x27;]).state</span><br><span class="line">        if new_state == &#x27;open&#x27; and self.state != &#x27;open&#x27;:</span><br><span class="line">            vals[&#x27;checkout_date&#x27;] = fields.Date.today()</span><br><span class="line">        if new_state == &#x27;done&#x27; and self.state != &#x27;done&#x27;:</span><br><span class="line">            vals[&#x27;closed_date&#x27;] = fields.Date.today()</span><br><span class="line">    super().write(vals)</span><br><span class="line">    # Code after write: can use `self`, with the updated values</span><br><span class="line">    return True</span><br></pre></td></tr></table></figure>

<p>我们一般会尽量在super().write(vals)之前修改写入的值。如果write()方法在同一模型中有其它的写操作，会导致递归循环，它在工作进程资源耗尽后结束并报错。请考虑是否需要这么做，如果需要，避免递归循环的一个技巧是在上下文中添加一个标记。作为示例，我们添加类似如下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if not self.env.context.get(&#x27;_library_checkout_writing&#x27;):</span><br><span class="line">            self.with_context(_library_checkout_writing=True).write(some_values)</span><br></pre></td></tr></table></figure>

<p>通过这个技巧，具体的逻辑受到 if 语句的保护，仅在上下文中出现指定标记时才会运行。再深入一步，self.write()操作应使用with_context来设置标记。这种组合确保 if 语句中自定义登录(login)只执行一次，并且不会触发更多的write()调用，避免进入无限循环。</p>
<p>在write()内运行write()方法会导致无限循环。要避免这一循环，我们需要在上下文中设置标记值来在代码中进行检查避免进入循环。</p>
<p>应仔细考虑是否需要对create或write方法进行扩展。大多数情况下我们只需要在保存记录时执行一些验证或自动计算某些值：</p>
<ul>
<li>对于根据其它字段自动计算的字段值，我们应使用计算字段。这样的例子有在各行值修改时对头部汇总的计算。</li>
<li>要使字段默认值动态计算，我们可以将字段赋值的默认值修改为一个函数绑定。</li>
<li> 要让字段根据其它字段的修改来设置值，我们可以使用 onchange 函数。举个例子，在选定客户时，将用户的币种设置为文档的币种，但随后可由用户手动修改。记住 onchange 仅用于表单视图的交互，不直接进行写入调用。</li>
<li>对于验证，我们应使用由@api.constraints(fld1,fld2,…)装饰的约束函数。这和计算字段相似，但不同处在于它会抛出错误。</li>
</ul>
<h3 id="数据导入、导出方法"><a href="#数据导入、导出方法" class="headerlink" title="数据导入、导出方法"></a>数据导入、导出方法</h3><p>导入、导出操作在第五章 <a target="_blank" rel="noopener" href="https://alanhou.org/odoo12-import-export-data/">Odoo 12开发之导入、导出以及模块数据</a>已做讨论，也可以通过 ORM API 中的如下方法操作：</p>
<ul>
<li>load([fields], [data]) 用于导入从 CSV 文件中获取的数据。第一个参数是导入的字段列表，与 CSV 的第一行对应。第二个参数是记录列表，每条记录是一个待解析和导入的字符串列表，与 CSV 数据中的行和列直接对应。它实现了 CSV 数据导入的功能，比如对外部标识符的支持。它用于网页客户端的导入函数。</li>
<li>export_data([fields], raw_data&#x3D;False)用于网页客户端导出函数。它返回一个字典，带有包含数据（一个行列表）的数据键。字段名可使用 CSV 文件使用的.id和&#x2F;id后缀，数据格式与需导入的 CSV 文件兼容。可选raw_data参数让数据值与 Python 类型一同导出，而不是 CSV 文件中的字符串形式。</li>
</ul>
<h3 id="用户界面的支持方法"><a href="#用户界面的支持方法" class="headerlink" title="用户界面的支持方法"></a>用户界面的支持方法</h3><p>以下方法最常用于网页客户端中渲染用户界面和执行基础交互：</p>
<ul>
<li>name_get()返回一个表示每条记录的文本的元组(ID, name)列表。它默认用于计算display_name值，来提供关联字段的文本表示。可扩展它来实现自定义的显示方式，如将仅显示名称改为显示记录编号和名称。</li>
<li>name_search(name&#x3D;’’, args&#x3D;None, operator&#x3D;’ilike’, limit&#x3D;100)返回一个元组(ID, name)列表，其显示名与 name 参数的文本相匹配。它用于 UI 中，在关联字段中通过输入来生成带有匹配所输入文本推荐记录的列表。例如，它可用于在挑选产品的字段中输入时，实现通过名称和引用来查找产品。</li>
<li>name_create(name)创建一条仅带有要使用的标题名的新记录。它用于在 UI 中快速创建(quick-create)功能，这里我们可以仅提供名称快速创建一条关联记录。可扩展来为通过此功能创建的新记录提供指定默认值。</li>
<li>default_get([fields])返回一个带有要创建的新记录默认值的字典。默认值可使用变量，如当前用户或会话上下文。</li>
<li>fields_get()用于描述模型字段的定义，在开发者菜单的View Fields选项中也可以看到。</li>
<li>fields_view_get()在网页客户端中用于获取要渲染的 UI视图的结构。可传入视图的 ID或想要使用的视图类型(view_type&#x3D;’form’)作为参数。例如可使用self.fields_view_get(view_type&#x3D;’tree’)。</li>
</ul>
<h2 id="消息和活动-activity-功能"><a href="#消息和活动-activity-功能" class="headerlink" title="消息和活动(activity)功能"></a>消息和活动(activity)功能</h2><p>Odoo 自带全局的消息和活动规划功能，由 Discuss 应用提供，技术名称为 mail。mail 模块提供包含mail.thread抽象类，它让在任意模型中添加消息功能都变得很简单。还提供mail.activity.mixin用于添加规划活动功能。在第四章 <a target="_blank" rel="noopener" href="https://alanhou.org/odoo12-extending-modules/">Odoo 12 开发之模块继承</a>中已讲解了如何从 mixin 抽象类中继承功能。</p>
<p>要添加这些功能，我们需要在library_checkout中先添加对 mail 的依赖，然后在图书借阅模型中继承抽象类中提供的这些功能。编辑library_checkout&#x2F;<strong>manifest</strong>.py文件，在 depends 键下添加 mail 模块：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x27;depends&#x27;: [&#x27;library_member&#x27;, &#x27;mail&#x27;],</span><br></pre></td></tr></table></figure>

<p>然后编辑library_checkout&#x2F;models&#x2F;library_checkout.py文件来继承 mixin 抽象模型，代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class Checkout(models.Model):</span><br><span class="line">    _name = &#x27;library.checkout&#x27;</span><br><span class="line">    _description = &#x27;Checkout Request&#x27;</span><br><span class="line">    _inherit = [&#x27;mail.thread&#x27;, &#x27;mail.activity.mixin&#x27;]</span><br></pre></td></tr></table></figure>

<p>然后我们的模型就会添加三个新字段，每条记录（有时也称文档）都包含：</p>
<ul>
<li>mail_follower_ids：存储 followers 和相应的通知首选项</li>
<li>mail_message_ids：列出所有包含关联活动规划的关联messages.activity_id</li>
</ul>
<p>follower 可以是伙伴(partner)或频道(channel)。partner表示一个具体的人或组织，频道不是具体的人，而是体现为订阅列表。每个follower还有一个他们订阅的消息类型列表，仅有已选消息类型才会发送通知。</p>
<h3 id="消息子类型"><a href="#消息子类型" class="headerlink" title="消息子类型"></a>消息子类型</h3><p>一些消息类型称为子类型，它们存储在mail.message.subtype模型中，可通过Settings &gt; Technical &gt; Email &gt; Subtypes菜单访问。默认我们有如下三种消息子类型：</p>
<ul>
<li>Discussions：带有mail.mt_comment XML ID，用于创建带有Send message链接的消息，默认会发送通知。</li>
<li>Activities：带有mail.mt_activities XML ID，用于创建带有Schedule activity链接的消息，默认不会发送通知。</li>
<li>Note：带有mail.mt_note XML ID，用于创建带有Log note链接的消息，默认不会发送通知。</li>
</ul>
<p>子类型默认通知设置如上所述，但用户可以就具体文档来进行调整，比如关闭他们不感兴趣的讨论的通知。除内置子类型之外，我们还可以添加自己的子类型并在应用中自定义通知。子类型既可以是通用的也可以只针对具体模型。对于后者，我们应将其所作用的模型名填入子类型的res_model字段中。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/998e29c9f6e9431883612f944404e7d0~tplv-k3u1fbpfcp-zoom-1.image" alt="Odoo 12消息子类型"></p>
<h3 id="发送消息"><a href="#发送消息" class="headerlink" title="发送消息"></a>发送消息</h3><p>我们的业务逻辑可利用这个消息系统来向用户发送通知。可使用message_post() 方法来发送通知，示例如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">self.message_post(&#x27;Hello!&#x27;)</span><br></pre></td></tr></table></figure>

<p>这会添加一个普通文本消息，但不会向follower发送通知。这是因为默认由mail.mt_note子类型发送消息。但我们可以通过指定的子类型来发送消息。要添加一条向follower发送通知的消息，应使用mt_comment子类型。另一个可选属性是消息标题，使用这两项的示例如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">self.message_post(&#x27;Hello again!&#x27;, subject=&#x27;Hello&#x27;, subtype=&#x27;mail.mt_comment&#x27;)</span><br></pre></td></tr></table></figure>

<p>消息体是HTML格式的，所以我们可以添加标记来实现文本效果，如<b>为加粗，<i>为斜体。</p>
<blockquote>
<p>ℹ️出于安全原因消息体会被清洗，所以有些 HTML 元素可能最终无法出现在消息中。</p>
</blockquote>
<h3 id="添加-follower"><a href="#添加-follower" class="headerlink" title="添加 follower"></a>添加 follower</h3><p>从业务逻辑角度来看还有一个有意思的功能：可以向文档添加 follower，这样他们可以获取相应的通知。我们有以下几种方法来添加 follower：</p>
<ul>
<li>message_subscribe(partner_ids&#x3D;&lt;整型 id 列表&gt;)添加伙伴</li>
<li>message_subscribe(channel_ids&#x3D;&lt;整型 id 列表&gt;) 添加频道</li>
<li>message_subscribe_users(user_ids&#x3D;&lt;整型 id 列表&gt;) 添加用户</li>
</ul>
<p>默认的子类型会作用于每个订阅者。强制订阅指定的子类型列表，可添加subtype_ids&#x3D;&lt;整型 id 列表&gt;属性，来列出在订阅中使用指定子类型。</p>
<h2 id="创建向导"><a href="#创建向导" class="headerlink" title="创建向导"></a>创建向导</h2><p>假定我们的图书馆用户需要向一组借阅者发送消息。比如他们可选择某本书最早的借阅者，向他们发送消息要求归还图书。这可通过向导来实现。向导是接受用户输入的一系列表单，然后使用输入来做进一步操作。</p>
<p>我们的用户开始从借阅列表中选择待使用的记录，然后从视图顶级菜单中选择 wizard 选项。这会打开向导表单，可填入消息主题和内容。一旦点击 Send 就将会向所有已选借阅者发送消息。</p>
<h3 id="向导模型"><a href="#向导模型" class="headerlink" title="向导模型"></a>向导模型</h3><p>向导对用户显示为一个表单视图，通常是一个对话窗口，可填入一些字段。这些字段会随后在向导逻辑中使用。这通过普通视图同样的模型&#x2F;视图结构实现，但支持的模型继承的是models.TransientMode而不是models.Model。这种类型的模型也会在数据库体现并存储状态，但数据仅在向导完成操作前有用。定时 job 会定期清除向导数据表中的老数据。</p>
<p>我们将使用wizard&#x2F;checkout_mass_message.py 文件来定义与用户交互的字段：通知的订阅者列表，标题和消息体。</p>
<p>首先编辑library_checkout&#x2F;<strong>init</strong>.py文件并导入wizard&#x2F;子目录：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">from . import models</span><br><span class="line">from . import wizard</span><br></pre></td></tr></table></figure>

<p>添加wizard&#x2F;<strong>init</strong>.py文件并加入如下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">from . import checkout_mass_message</span><br></pre></td></tr></table></figure>

<p>然后创建实际的wizard&#x2F;checkout_mass_message.py文件，内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">from odoo import api, exceptions, fields, models</span><br><span class="line"></span><br><span class="line">class CheckoutMassMessage(models.TransientModel):</span><br><span class="line">    _name = &#x27;library.checkout.massmessage&#x27;</span><br><span class="line">    _description = &#x27;Send Message to Borrowers&#x27;</span><br><span class="line">    checkout_ids = fields.Many2many(</span><br><span class="line">        &#x27;library.checkout&#x27;,</span><br><span class="line">        string=&#x27;Checkouts&#x27;)</span><br><span class="line">    message_subject = fields.Char()</span><br><span class="line">    message_body = fields.Html()</span><br></pre></td></tr></table></figure>

<p>值得注意的是普通模型中的one-to-many关联不能在临时模型中使用。这是因为那样就会要求普通模型中添加与临时模型的反向many-to-one关联。但这是不允许的，因为那样普通记录的已有引用会阻止对老的临时记录的清除。替代方案是使用many-to-many关联。</p>
<blockquote>
<p>ℹ️Many-to-many关联存储在独立的表中，会在关联任意一方被删除时自动删除表中对应行。</p>
</blockquote>
<p>临时模型无需安全规则 ，因为它们是用于辅助执行的一次性记录。那么也就不需要添加ecurity&#x2F;ir.model.access.csv权限控制列表文件。</p>
<h3 id="向导表单"><a href="#向导表单" class="headerlink" title="向导表单"></a>向导表单</h3><p>向导表单视图与普通模型相同，只是它有两个特定元素：</p>
<ul>
<li>可使用<footer>元素来替换操作按钮</li>
<li>special&#x3D;”cancel”按钮用于中断向导，不执行任何操作</li>
</ul>
<p>wizard&#x2F;checkout_mass_message_wizard.xml文件的内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot;?&gt;</span><br><span class="line">&lt;odoo&gt;</span><br><span class="line">    &lt;record id=&quot;view_form_checkout_message&quot; model=&quot;ir.ui.view&quot;&gt;</span><br><span class="line">        &lt;field name=&quot;name&quot;&gt;Library Checkout Mass Message Wizard&lt;/field&gt;</span><br><span class="line">        &lt;field name=&quot;model&quot;&gt;library.checkout.massmessage&lt;/field&gt;</span><br><span class="line">        &lt;field name=&quot;arch&quot; type=&quot;xml&quot;&gt;</span><br><span class="line">            &lt;form&gt;</span><br><span class="line">                &lt;group&gt;</span><br><span class="line">                    &lt;field name=&quot;message_subject&quot; /&gt;</span><br><span class="line">                    &lt;field name=&quot;message_body&quot; /&gt;</span><br><span class="line">                    &lt;field name=&quot;checkout_ids&quot; /&gt;</span><br><span class="line">                &lt;/group&gt;</span><br><span class="line">                &lt;footer&gt;</span><br><span class="line">                    &lt;button type=&quot;object&quot;</span><br><span class="line">                        name=&quot;button_send&quot;</span><br><span class="line">                        string=&quot;Send Message&quot; /&gt;</span><br><span class="line">                    &lt;button special=&quot;cancel&quot;</span><br><span class="line">                        string=&quot;Cancel&quot;</span><br><span class="line">                        class=&quot;btn-secondary&quot; /&gt;</span><br><span class="line">                &lt;/footer&gt;</span><br><span class="line">            &lt;/form&gt;</span><br><span class="line">        &lt;/field&gt;</span><br><span class="line">    &lt;/record&gt;</span><br><span class="line"></span><br><span class="line">        &lt;act_window id=&quot;action_checkout_message&quot;</span><br><span class="line">            name=&quot;Send Messages&quot;</span><br><span class="line">            src_model=&quot;library.checkout&quot;</span><br><span class="line">            res_model=&quot;library.checkout.massmessage&quot;</span><br><span class="line">            view_type=&quot;form&quot;</span><br><span class="line">            view_mode=&quot;form&quot;</span><br><span class="line">            target=&quot;new&quot;</span><br><span class="line">            multi=&quot;True&quot;</span><br><span class="line">            /&gt;</span><br><span class="line">&lt;/odoo&gt;</span><br></pre></td></tr></table></figure>

<p>XML 中的窗口操作使用src_model属性向图书借阅的Action按钮添加了一个选项。target&#x3D;”new”属性让它以对话窗口形式打开。打开向导，我们可以从借阅列表中选择一条或多条记录，然后从Action菜单中选择 Send Messages 选项，Action 菜单显示在列表顶部的Filters菜单旁。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/43407e5c88784836a2271907d628c604~tplv-k3u1fbpfcp-zoom-1.image" alt="Odoo 12图书项目发送消息菜单"></p>
<p>现在这会打开向导表单，但从列表中所选的记录会被忽略。如果能在向导中任务列表中显示预选的记录会很棒。表单会调用default_get() 方法来计算要展示的默认值，这正是我们需要的功能。注意在打开向导表单时，有一条空记录并且还没有使用create()方法，该方法仅在点击按钮时才会触发，所以暂不能满足我们的需求。</p>
<p>Odoo 视图向上下文字典添加一些元素，可在点击操作或跳到其它视图时使用。它们分别是：</p>
<ul>
<li>active_model：带有视图模型的技术名</li>
<li>active_id：带有表单活跃记录或表中第一条记录的 ID</li>
<li>active_ids：带有一个列表中活跃记录的列表（如果是表单则只有一个元素）</li>
<li>active_domain：如果在表单视图中触发了该操作</li>
</ul>
<p>本例中，active_ids中保存任务列表中所选记录的 ID，可使用这些 ID 作为向导task_ids字段的默认值，相关代码如下(izard&#x2F;checkout_mass_message.py)：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@api.model</span><br><span class="line">def default_get(self, field_names):</span><br><span class="line">    defaults = super().default_get(field_names)</span><br><span class="line">    checkout_ids = self.env.context.get(&#x27;active_ids&#x27;)</span><br><span class="line">    defaults[&#x27;checkout_ids&#x27;] = checkout_ids</span><br><span class="line">    return defaults</span><br></pre></td></tr></table></figure>

<p>我们首先使用了super()来调用标准的default_get()运算，然后向默认值添加了一个checkout__id，而active_ids值从环境下文中读取。</p>
<p>下面我们需要实现点击表单中Send按钮的操作。</p>
<h3 id="向导业务逻辑"><a href="#向导业务逻辑" class="headerlink" title="向导业务逻辑"></a>向导业务逻辑</h3><p>除了无需进行任何操作仅仅关闭表单的 Cancel 按钮外，我们还有一个Send按钮的操作需要实现。该按钮调用的方法为button_send，需要在wizard&#x2F;checkout_mass_message.py文件中使用如下代码定义：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@api.multi</span><br><span class="line">def button_send(self):</span><br><span class="line">    self.ensure_one()</span><br><span class="line">    for checkout in self.checkout_ids:</span><br><span class="line">        checkout.message_post(</span><br><span class="line">            body=self.message_body,</span><br><span class="line">            subject=self.message_subject,</span><br><span class="line">            subtype=&#x27;mail.mt_comment&#x27;,</span><br><span class="line">        )</span><br><span class="line">    return True</span><br></pre></td></tr></table></figure>

<p>我们的代码一次仅需处理一个向导实例，所以这里通过self.ensure_one()以示清晰。这里的 self 表示向导表单里显示的数据。以上方法遍历已选借阅记录并向其中的每个借阅者发送消息。这里使用mt_comment子类型，因此会向每个 follower 发送消息通知。</p>
<blockquote>
<p>ℹ️让方法至少返回一个 True 值是一个很好的编程实践。主要是因为有些XML-RPC协议不支持 None 值，所以对于这些协议就用不了那些方法了。在实际工作中，我们可能不会遇到这个问题，因为网页客户端使用JSON-RPC而不是XML-RPC，但这仍是一个可遵循的良好实践。</p>
</blockquote>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/83fe9464617241ae8a95f6ce98392308~tplv-k3u1fbpfcp-zoom-1.image" alt="消息发送对话框"></p>
<h2 id="使用日志消息"><a href="#使用日志消息" class="headerlink" title="使用日志消息"></a>使用日志消息</h2><p>向日志文件写入消息有助于监控和审计运行的系统。它还有助于代码维护，在无需修改代码的情况下可以从运行的进程中轻松获取调试信息。要让我们的代码能使用日志功能，首先要准备一个日志记录器(logger)，在library_checkout&#x2F;wizard&#x2F;checkout_mass_message.py文件的头部添加如下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import logging</span><br><span class="line">_logger = logging.getLogger(__name__)</span><br></pre></td></tr></table></figure>

<p>这里使用了 Python标准库logging模块。_logger通过当前代码文件名__name__来进行初始化。这样日志信息就会带有生成日志文件的信息。有以下几种级别的日志信息：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">_logger.debug(&#x27;DEBUG调试消息&#x27;)</span><br><span class="line">_logger.info(&#x27;INFO信息日志&#x27;)</span><br><span class="line">_logger.warning(&#x27;WARNING警告消息&#x27;)</span><br><span class="line">_logger.error(&#x27;ERROR错误消息&#x27;)</span><br></pre></td></tr></table></figure>

<p>现在就可以使用logger向日志中写入消息了，让我们为button_send向导方法来添加日志。在文件最后的return True前添加如下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">_logger.info(</span><br><span class="line">    &#x27;Posted %d messages to Checkouts: %s&#x27;,</span><br><span class="line">    len(self.checkout_ids),</span><br><span class="line">    str(self.checkout_ids),</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>这样在使用向导发送消息时，服务器日志中会出现类似如下消息：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INFO dev12 odoo.addons.library_checkout.wizard.checkout_mass_message: Posted 1 messages to Checkouts: library.checkout(30,)</span><br></pre></td></tr></table></figure>

<p>注意我们没有在日志消息中使用 Python 内插字符串。我们没使用_logger.info(‘Hello %s’ % ‘World’)，而是使用了类似_logger.info(‘Hello %s’, ‘World’)。不使用内插使我们的代码少执行一个任务，让日志记录更为高效。因此我们应一直为额外的日志参数传入变量。</p>
<blockquote>
<p>ℹ️服务器日志的时间戳总是使用 UTC 时间。因此打印的日志消息中也是 UTC 时间。你可能会觉得意外 ，但 Odoo服务内部都是使用 UTC 来处理日期的。</p>
</blockquote>
<p>对于调试级别日志，我们使用_logger.debug()。例如，可以在checkout.message_post() 命令后添加如下调试日志消息：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">_logger.debug(</span><br><span class="line">    &#x27;Message on %d to followers: %s&#x27;,</span><br><span class="line">    checkout.id,</span><br><span class="line">    checkout.message_follower_ids)</span><br></pre></td></tr></table></figure>

<p>这不会在服务器日志中显示任何消息，因为默认的日志级别是INFO。需要将日志级别设置为DEBUG才会输出调试日志消息。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DEBUG dev12 odoo.api: call library.checkout(30,).read([&#x27;request_date&#x27;, &#x27;member_id&#x27;, &#x27;checkout_date&#x27;, &#x27;stage_id&#x27;])</span><br></pre></td></tr></table></figure>

<p>Odoo 命令行选项–log-level&#x3D;debug可用于设置通用日志级别。我们还可以对指定模块设置日志级别。我们的向导的 Python 模块是odoo.addons.library_checkout.wizard.checkout_mass_message，这在 INFO 日志消息中也可以看到。要开启向导的调试消息，使用–loghandler 选项，该选项还可重复多次来对多个模块设置日志级别，示例如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--loghandler=odoo.addons.library_checkout.wizard.checkout_mass_message:DEBUG</span><br></pre></td></tr></table></figure>

<p>有关 Odoo 服务器日志选项的完整手册可参见<a target="_blank" rel="noopener" href="https://www.odoo.com/documentation/12.0/reference/cmdline.html#logging">官方文档</a>。如果想要了解原始的 Python 日志细节，可参见Python <a target="_blank" rel="noopener" href="https://docs.python.org/3.6/howto/logging.html">官方文档</a>。</p>
<h2 id="抛出异常"><a href="#抛出异常" class="headerlink" title="抛出异常"></a>抛出异常</h2><p>在操作和预期不一致时，我们可能需要通知用户并中断程序，显示错误信息。这可通过抛出异常来实现。Odoo 中提供了一些异常类供我们使用。插件模块中最常用的 Odoo 异常有：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">from odoo import exceptions</span><br><span class="line">raise exceptions.ValidationError(&#x27;验证失败&#x27;)</span><br><span class="line">raise exceptions.UserError(&#x27;业务逻辑错误&#x27;)</span><br></pre></td></tr></table></figure>

<p>ValidationError异常用于 Python 代码中的验证，比如使用@api.constrains装饰的方法。UserError应该用在其它所有操作不被允许的情况，因为这不符合业务逻辑。</p>
<blockquote>
<p>ℹ️<strong>Odoo 9中的修改</strong><br>引用了UserError异常来替换掉Warning异常，淘汰掉 Warning 异常的原因是因为它与 Python 内置异常冲突，但 Odoo 保留了它以保持向后兼容性。</p>
</blockquote>
<p>通常所有在方法执行期间的数据操纵在数据库事务中，发生异常时会进行回滚。也就是说在抛出异常时，所有此前对数据的修改都会被取消。</p>
<p>下面就使用本例向导button_send方法来进行举例说明。试想一下如果执行发送消息逻辑时没有选中任何借阅文档是不是不合逻辑？同样如果没有消息体就发送消息也不合逻辑。下面就来在发生这些情况时向用户发出警告。</p>
<p>编辑button_send()方法，在self.ensure_one()一行后加入如下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if not self.checkout_ids:</span><br><span class="line">    raise exceptions.UserError(</span><br><span class="line">        &#x27;请至少选择一条借阅记录来发送消息!&#x27;)</span><br><span class="line">if not self.message_body:</span><br><span class="line">    raise exceptions.UserError(</span><br><span class="line">        &#x27;请填写要发送的消息体!&#x27;)</span><br></pre></td></tr></table></figure>

<p>补充：经测试发现消息体不填内容并不会抛出异常，因为默认的会发送<p><br></p>这段 html 标签</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/78b81b7d64eb4fc2b4ebecbf78efd5c8~tplv-k3u1fbpfcp-zoom-1.image" alt="Odoo 12图书项目异常测试"></p>
<h2 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h2><p>自动化测试是广泛接受的软件开发最佳实践。不仅可以帮助我们确保代码正确实施，更重要的为我们未来的代码修改和重写提供了一个安全保障。对于 Python 这样的动态编程语言，因为没有编译这一步，语法错误经常不容易注意到。这也使得单元测试愈发重要，覆盖的代码行数越多越好。</p>
<p>以上两个目标是我们编写测试时的灯塔。测试的第一个目标应是提供更好的测试覆盖：设置测试用例运行所有代码行。单单这个就会为第二个目标迈出很大一步：显示代码有无功能性错误，因为在这之后，我们一定可以很好地开始为不显著的使用特例添加测试用例。</p>
<blockquote>
<p>ℹ️Odoo 12中的修改<br>在该版本之前，Odoo 还支持通过 YAML格式的数据文件进行测试。Odoo 12中删除了YAML数据文件引擎，不再支持该格式，有关该格式的最后一个文档请见<a target="_blank" rel="noopener" href="https://doc.odoo.com/v6.0/contribute/15_guidelines/coding_guidelines_testing/">官方网站</a>。</p>
</blockquote>
<h3 id="添加单元测试"><a href="#添加单元测试" class="headerlink" title="添加单元测试"></a>添加单元测试</h3><p>Python 测试文件添加在模块的tests&#x2F;子目录下，测试执行器会自动在该目录下查找测试文件。为测试library_checkout模块向导逻辑，我们可以创建tests&#x2F;test_checkout_mass_message.py，老规矩，需要添加tests&#x2F;<strong>init</strong>.py文件，内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">from . import test_checkout_mass_message</span><br></pre></td></tr></table></figure>

<p>tests&#x2F;test_checkout_mass_message.py代码的基础框架如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">from odoo.tests.common import TransactionCase</span><br><span class="line"></span><br><span class="line">class TestWizard(TransactionCase):</span><br><span class="line">    def setUp(self, *args, **kwargs):</span><br><span class="line">        super(TestWizard, self).setUp(*args, **kwargs)</span><br><span class="line">        # Add test setup code here...</span><br><span class="line"></span><br><span class="line">    def test_button_send(self):</span><br><span class="line">        &quot;&quot;&quot;Send button should create messages on Checkouts&quot;&quot;&quot;</span><br><span class="line">        # Add test code</span><br></pre></td></tr></table></figure>

<p>Odoo 提供了一些供测试使用的类：</p>
<ul>
<li>TransactionCase测试为每个测试使用不同的事务，在测试结束时自动回滚。</li>
<li>SingleTransactionCase将所有测试放在一个事务中运行，在最后一条测试结束后才进行回滚。在每条测试的最终状态需作为下一条测试的初始状态时这会非常有用。</li>
</ul>
<p>setUp()方法用于准备数据以及待使用的变量。通常我们将数据和变量存放在类属性中，这样就可在测试方法中进行使用。测试应使用类方法实现，如test_button_send()。测试用例方法名必须以test_为前缀。这些方法被自动发现，该前缀就是用于辨别是否为实施测试用例的方法。根据测试方法名的顺序来运行。</p>
<p>在使用TransactionCase类时，在每个测试用例运行完后都会进行回滚。在测试运行时会显示方法的文档字符串(docstring)，因此可以使用它来作为所执行测试的简短描述。</p>
<blockquote>
<p>ℹ️这些测试类是对Python 标准库中unittest测试用例的封装。有关unittest详细内容，请参见<a target="_blank" rel="noopener" href="https://docs.python.org/3/library/unittest.html">官方文档</a>。</p>
</blockquote>
<h3 id="运行测试"><a href="#运行测试" class="headerlink" title="运行测试"></a>运行测试</h3><p>下面就来运行已书写的测试。我们仅需在安装或升级(-i或-u)模块时在 Odoo 服务启动命令中添加– test-enable选项即可。具体命令如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~/odoo-dev/odoo/odoo-bin --test-enable -u library_checkout --stop-after-init</span><br></pre></td></tr></table></figure>

<p>仅在安装或升级模块时才会运行测试，这也就是为会什么添加了-u 选项。如果需要安装一些依赖，它的测试也会运行。想要避免这一情况，可以像平常那样测试安装模块，然后在升级(-u)模块时运行测试。以上测试中实际没有做任何测试，但应该可以正常运行。仔细查看服务器日志可看到报告测试运行的INFO信息，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INFO dev12 odoo.modules.module: odoo.addons.library_checkout.tests.test_checkout_mass_message running tests.</span><br></pre></td></tr></table></figure>

<h3 id="配置测试"><a href="#配置测试" class="headerlink" title="配置测试"></a>配置测试</h3><p>我们应开始在setUp方法中准备测试中将使用的数据。这里我们要创建一条在向导中使用的借阅记录。使用指定用户执行测试操作会很便捷，这样可以同时测试权限控制是否正常配置。这通过sudo(<user>)模型方法来实现。记录集中携带这一信息，因此在使用 sudo()创建后，相同记录集后续的操作都会使用相同上下文执行。以下是setUp方法中的代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class TestWizard(TransactionCase):</span><br><span class="line"></span><br><span class="line">    def setUp(self, *args, **kwargs):</span><br><span class="line">        super(TestWizard, self).setUp(*args, **kwargs)</span><br><span class="line">        # Setup test data</span><br><span class="line">        admin_user = self.env.ref(&#x27;base.user_admin&#x27;)</span><br><span class="line">        self.Checkout = self.env[&#x27;library.checkout&#x27;].sudo(admin_user)</span><br><span class="line">        self.Wizard = self.env[&#x27;library.checkout.massmessage&#x27;].sudo(admin_user)</span><br><span class="line"></span><br><span class="line">        a_member = self.env[&#x27;library.member&#x27;].create(&#123;&#x27;name&#x27;: &#x27;John&#x27;&#125;)</span><br><span class="line">        self.checkout0 = self.Checkout.create(&#123;</span><br><span class="line">            &#x27;member_id&#x27;: a_member.id&#125;)</span><br></pre></td></tr></table></figure>

<p>此时我们就可以在测试中使用self.checkout0记录和self.Wizard模型了。</p>
<h3 id="编写测试用例"><a href="#编写测试用例" class="headerlink" title="编写测试用例"></a>编写测试用例</h3><p>现在让我们来扩展一下初始框架中的test_button_test()方法吧。最简单的测试是运行测试对象中的部分代码，获取结果，然后使用断言语句来与预期结果进行对比。</p>
<p>要测试发送消息的方法，测试计算向导运行前后的消息条数来确定有没有增加新消息。要运行向导，需要在上下文中设置active_ids，像 UI 表单一样，创建带有填写向导表单（至少是消息体）的向导记录，然后运行button_send方法。完整代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">def test_button_send(self):</span><br><span class="line">    &quot;&quot;&quot;Send button should create messages on Checkouts&quot;&quot;&quot;</span><br><span class="line">    # Add test code</span><br><span class="line">    msgs_before = len(self.checkout0.message_ids)</span><br><span class="line"></span><br><span class="line">    Wizard0 = self.Wizard.with_context(active_ids=self.checkout0.ids)</span><br><span class="line">    wizard0 = Wizard0.create(&#123;&#x27;message_body&#x27;: &#x27;Hello&#x27;&#125;)</span><br><span class="line">    wizard0.button_send()</span><br><span class="line"></span><br><span class="line">    msgs_after = len(self.checkout0.message_ids)</span><br><span class="line">    self.assertEqual(</span><br><span class="line">        msgs_after,</span><br><span class="line">        msgs_before+1,</span><br><span class="line">        &#x27;Expected on additional message in the Checkout.&#x27;)</span><br></pre></td></tr></table></figure>

<p>这一检测在self.assertEqual语句中验证测试成功还是失败。它对比运行向导前后的消息数，预期会比运行前多一条消息。最后一个参数在测试失败时作为信息提示，它是可选项，但推荐使用。</p>
<p>assertEqual方法仅是断言方法的一种，我们应根据具体用例选择合适的断言方法，这样才更易于理解导致测试错误的原因。单元测试文档提供对所有这些方法的说明，参见 Python <a target="_blank" rel="noopener" href="https://docs.python.org/3/library/unittest.html#test-cases">官方文档</a>。</p>
<p>要添加新的测试用例，在类中添加另一个实现方法。要记住TransactionCase测试，每次测试结束后都会回滚。因此，前一次测试的操作会被撤销，我需要重新打开向导表单。然后模拟用户填写消息内容，执行消息发送。最后检测消息条数来进行验证。</p>
<p>补充：此处原文已惨不忍睹，通篇是任务清单项目的描述，笔者自行做了对应的调整。</p>
<h3 id="测试异常"><a href="#测试异常" class="headerlink" title="测试异常"></a>测试异常</h3><p>有时我们需要测试来检查是否生成了异常，常用的情况是测试是否正确地进行了验证。本例中，我们可以测试向导的一些验证。例如，我们可以测试空消息体抛出错误。要检查是否抛出异常，我们将相应代码放在self.assertRaises()代码块中。</p>
<p>首先在文件顶部导入 Odoo 的异常类：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">from odoo import exceptions</span><br></pre></td></tr></table></figure>

<p>然后，在测试类中添加含有测试用例的另一个方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">def test_button_send_empty_body(self):</span><br><span class="line">    &quot;Send button errors on empty body message&quot;</span><br><span class="line">    wizard0 = self.Wizard.create(&#123;&#125;)</span><br><span class="line">    with self.assertRaises(exceptions.UserError) as e:</span><br><span class="line">        wizard0.button_send()</span><br></pre></td></tr></table></figure>

<p>如果button_send()没有抛出异常，则检测失败。如果抛出了异常，检测成功并将异常存储在 e 变量中，我们可以使用它来做进一步的检测。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4fda133ca1cc4d1ea90f689fd8d0d065~tplv-k3u1fbpfcp-zoom-1.image" alt="Odoo 12图书项目单元测试"></p>
<h2 id="开发工具"><a href="#开发工具" class="headerlink" title="开发工具"></a>开发工具</h2><p>开发者应学习一些技巧有协助开发工作。本系列曾介绍过用户界面的开发者模式。也可以在服务端使用该选项来提供对开发者更友好的功能。这一部分就来进行详细说明。然后我们会讨论另一个开发者相关话题：如何对服务端代码进行调试。</p>
<h3 id="服务端开发选项"><a href="#服务端开发选项" class="headerlink" title="服务端开发选项"></a>服务端开发选项</h3><p>Odoo服务提供一个–dev选项来开启开发者功能、加速开发流程，比如：</p>
<ul>
<li>在发现插件模块中有异常时进入调试器</li>
<li>Python 文件保存时自动重新加载代码，避免反复手动重启服务</li>
<li>直接从 XML 文件中读取视图定义，无需手动更新模块</li>
</ul>
<p>–dev参数接收一个逗号分隔列表选项，通常 all 选项可适用大多数情况。我们可以指定想要用的调试器。默认使用Python 调试器pdb，有些人可能喜欢安装使用其它调试器，Odoo 对ipdb和pudb都予以支持。</p>
<blockquote>
<p>ℹ️<strong>Odoo 9中的修改</strong><br>Odoo 9之前的版本中，可使用–debug 选项来对某一模块异常打开调试器。从Odoo 9开始不再支持改选项，改用– dev&#x3D;all选项了。</p>
</blockquote>
<p>在使用 Python 代码时，每次代码修改都需重启服务来重新加载代码。–dev命令选项会处理重新加载，在服务监测到 Python 代码被修改时，自动重复服务加载序列，让代码修改立即生效。使用它仅需在服务命令后添加–dev&#x3D;all 选项：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~/odoo-dev/odoo/odoo-bin --dev=all</span><br></pre></td></tr></table></figure>

<p>要正常运行，要求安装watchdog Python包，可通过 pip 命令来执行安装：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install watchdog</span><br></pre></td></tr></table></figure>

<p>注意这仅对 Python 代码和 XML 文件中视图结构的修改有益。对于其它修改，如模型数据结构，需要进行模块升级，仅仅重新加载是不够的。</p>
<h3 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h3><p>我们都知道开发者的大部分工作是调试代码。我们通常使用代码编辑器打断点，运行程序来进行单步调试。如果使用 Windows 系统来开发，配置可运行 Odoo 源码的环境可不是个简单的工作。 Odoo是一个等待客户端调用的服务，然后才进行操作，这一事实让 Odoo 的调试与客户端程序截然不同。</p>
<h4 id="Python-调试器"><a href="#Python-调试器" class="headerlink" title="Python 调试器"></a>Python 调试器</h4><p>对于初学者可能有点高山仰止的感觉，最实际的方法是使用 Pyhton 集成的调试器pdb来对 Odoo 进行调试。我们会介绍它的扩展，会提供丰富的用户界面，类似于高级 IDE那样。</p>
<p>要使用调试器，最好的方法是在需要查看的代码（通常是模型方法）处插入断点。这通过在具体位置添加如下行来实现：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import pdb; pdb.set_trace()</span><br></pre></td></tr></table></figure>

<p>现在重启服务来加载修改代码。一旦程序运行到该行，服务运行窗口就会进入一个(pdb)Python 命令对话框，等待输入。这个对话框和 Python shell 一样，你可以输入当前执行上下文的任何表达式或命令来运行。这意味着可以检查甚至修改当前变量，以下是最常用的快捷命令：</p>
<ul>
<li>h (help) 显示可用 pdb 命令的汇总</li>
<li>p (print) 运行并打印表达式</li>
<li>pp (pretty print) 有助于打印数据结构，如字典或列表</li>
<li>l (list) 列出下一步要执行的代码及周边代码</li>
<li>n (next) 进入下一条命令</li>
<li>s (step) 进入当前命令</li>
<li>c (continue)继续正常执行</li>
<li>u (up) 在执行栈中上移</li>
<li>d (down)在执行栈中下移</li>
<li>bt (backtrace)显示当前执行栈</li>
</ul>
<p>如果启动服务时使用了dev&#x3D;all选项，抛出异常时服务在对应行进行后验模式。这是一个pdb对话框，和前述的一样，允许我们检查在发现错误那一刻的程序状态。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b849ec02d15a406d8db3a9c292b03e58~tplv-k3u1fbpfcp-zoom-1.image" alt="Odoo 12调试 pdb"></p>
<h4 id="示例调试会话"><a href="#示例调试会话" class="headerlink" title="示例调试会话"></a>示例调试会话</h4><p>让我们来看看一个简单调试会长什么样。可以在button_send向导方法的第一行添加调试器断点：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">    def button_send(self):</span><br><span class="line">        import pdb; pdb.set_trace()</span><br><span class="line">        self.ensure_one()</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>现在重启服务，打开一个发送消息向导表单并点击 Send 按钮。这会触发服务器上的button_send ，客户端会保持在Still loading…的状态，等待服务端响应。查看运行服务的终端窗口，可看到类似如下信息：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; /home/vagrant/odoo-dev/custom-addons/library_checkout/wizard/checkout_mass_message.py(24)button_send()</span><br><span class="line">-&gt; self.ensure_one()</span><br><span class="line">(Pdb)</span><br></pre></td></tr></table></figure>

<p>这是pdb调试器对话框，第一行告诉我们 Python 代码执行的位置以及所在的函数名，第二行是要运行的下一行代码。在调试会话中，可能会跳出一些日志消息。这对于调试没有伤害，但会打扰到我们。可以通过减少日志输出来避免这一情况。大多数据情况下日志消息都来自werkzeug模块。我们可通过–log-handler&#x3D;werkzeug:CRITICAL 选项来停止日志输出。如果这还不够，可以使用–log-level&#x3D;warn来降低通用日志级别。另一种方法是启用–logfile&#x3D;&#x2F;path&#x2F;to&#x2F;log选项，这样会将日志消息从标准输出重定向到文件中。</p>
<blockquote>
<p><strong>小贴士：</strong> 如果终端不响应，在终端中的输入不被显示，这可能与终端会话的显示问题有关，通过输入<enter>reset<enter>有可能解决这一问题。</p>
</blockquote>
<p>此时输入 h，可以看到可用命令的一个快速指南。输入 l 显示当前行代码，以及其周边的代码。输入 n 会运行当前行代码并进入下一行。如果只按下 Enter，会重复上一条命令。执行三次应该就可以进入方法的 return 语句。我们可以查看任意变量或属性的内容，如向导中使用的checkout_ids字段：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(Pdb) p self.checkout_ids</span><br><span class="line">library.checkout(30,)</span><br></pre></td></tr></table></figure>

<p>它允许使用任何 Python 表达式，甚至是分配变量。我们可以逐行调试，在任意时刻按下 c 继续正常运行。</p>
<h4 id="其它-Python-调试器"><a href="#其它-Python-调试器" class="headerlink" title="其它 Python 调试器"></a>其它 Python 调试器</h4><p>pdb 的优势是“开箱即用”，它简单但粗暴，还有一些使用上更舒适的选择。</p>
<p>ipdb(Iron Python debugger)是一个常用的选择，它使用和 pdb 一样的命令，但做了一些改进，比如添加 Tab 补全和语法高亮来让使用更舒适。可通过如下命令安装：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pip install ipdb</span><br></pre></td></tr></table></figure>

<p>使用如下行添加断点：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import ipdb; ipdb.set_trace()</span><br></pre></td></tr></table></figure>

<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3bb63c7e94cd4225ad99ff1f00376e61~tplv-k3u1fbpfcp-zoom-1.image" alt="Odoo 12调试工具 ipdb"></p>
<p>另一个可选调试器是pudb，它也支持和pdb相同的命令，仅用在文本终端中，但使用了类似 IDE 调试器的图形化显示。当前上下文的变量及值这类有用信息，在屏幕上它自己的窗口中显示。可通过系统包管理器或 pip 来进行安装：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install python-pudb # 使用Debian系统包</span><br><span class="line">sudo pip install pudb # 使用 pip，可在虚拟环境中</span><br></pre></td></tr></table></figure>

<p>添加pudb断点和其它调试器没什么分别：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import pudb; pudb.set_trace()</span><br></pre></td></tr></table></figure>

<p>也可以使用更短更易于记忆的方式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import pudb; pu.db</span><br></pre></td></tr></table></figure>

<h3 id=""><a href="#" class="headerlink" title=""></a><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1774a4113bc74c348786f8118706a8ce~tplv-k3u1fbpfcp-zoom-1.image" alt="Odoo 12调试工具 pudb"></h3><h3 id="打印消息和日志"><a href="#打印消息和日志" class="headerlink" title="打印消息和日志"></a>打印消息和日志</h3><p>有时我们只需要查看一些变量的值或者检查一些代码段是否被执行。Python的print()函数可以在不中断执行流的情况下完美解决这些问题。因为我们在服务器窗口中运行，打印的内容会显示在标准输出中，但如果日志是写入文件的打印内容不会存储到服务器日志中。</p>
<p>print()仅用于开发辅助，不应出现最终部署的代码中。如果你可能需要代码执行的更多细节，请使用debug 级别日志消息。在代码敏感点添加调试级别日志消息让我们可以在部署实例中调查问题。只需将服务器日志级别提升为 debug，然后查看日志文件。</p>
<h3 id="查看和关闭运行进程"><a href="#查看和关闭运行进程" class="headerlink" title="查看和关闭运行进程"></a>查看和关闭运行进程</h3><p>还有一些查看 Odoo 运行进程的小技巧。首先我们需要找到相应的进程ID (PID)，要找到 PID，再打开一个终端窗口并输入如下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps ax | grep odoo-bin</span><br></pre></td></tr></table></figure>

<p>输入的第一列是进程的PID，记录下要查看进程的 PID，在下面会使用到。现在，我们要向进程发送信号。使用的命令是 kill，默认它发送一个终止进程的信号，但也可以发送其它更友好的信号。知道了运行中的 Odoo 服务进程 PID，我们可以通过向进程发送SIGQUIT信号打印正在执行的代码踪迹，命令如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kill -3 &lt;PID&gt;</span><br></pre></td></tr></table></figure>

<p>然后如果我们查看终端窗口或写入服务输出的日志文件，就可以看到正常运行的一些线程的信息，以及它们运行所在行代码的细节栈踪迹。这用于一些代码性能分析中，追踪服务时间消耗在何处，来将代码执行性能归类。有关代码profiling的资料可参见<a target="_blank" rel="noopener" href="https://www.odoo.com/documentation/12.0/howtos/profilecode.html">官方文档</a>。其它可向 Odoo 服务器进程发送的信号有：HUP来重新加载服务，INT或TERM强制服务关闭：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kill -HUP &lt;PID&gt;</span><br><span class="line">kill -TERM &lt;PID&gt;</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我们详细解释了ORM API 的功能，以及如何使用这些功能来创建动态应用与用户互动，这可以帮助用户避免错误并自动化一些单调的任务。</p>
<p>模型验证和计算字段可以处理很多用例，但并不是所有的。我们学习了如何继承API的create, write和unlink 方法来处理更多用例。</p>
<p>对更丰富的用户交互，我们使用了 mail 内核插件 mixin 来为用户添加功能，方便他们围绕文档和活动规则进行交流。向导让应用可以与用户对话，收集所需数据来运行具体进程。异常允许应用终止错误操作，通知用户存在的问题并回滚中间的修改，保持系统的一致性。</p>
<p>我们还讨论了开发者可使用来创建和维护应用的工具：记录日志消息、调试工具和单元测试。</p>
<p>在下一篇文章中，我们还将使用 ORM，但会从外部应用的视角来操作，将 Odoo 服务器作为存储数据和运行业务进程的后端。</p>
<p> </p>
<p>☞☞☞ 第九章 <a target="_blank" rel="noopener" href="https://alanhou.org/odoo12-external-api/">Odoo 12开发之外部 API - 集成第三方系统</a></p>
<p> </p>
<h2 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h2><p>以下是本文所讨论的内容相关参考材料如下：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.odoo.com/documentation/12.0/reference/orm.html#common-orm-methods">ORM参考</a></li>
<li><a target="_blank" rel="noopener" href="https://www.odoo.com/documentation/12.0/reference/mixins.html">消息和活动功能</a></li>
<li><a target="_blank" rel="noopener" href="https://www.odoo.com/documentation/12.0/reference/testing.html">Odoo 测试参考</a></li>
<li>Python <a target="_blank" rel="noopener" href="https://docs.python.org/3/library/unittest.html#module-unittest">单元测试参考 </a></li>
</ul>
<p>本文首发地址：<a target="_blank" rel="noopener" href="https://alanhou.org/developer-mode-odoo12/">Alan Hou 的个人博客</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://alanhou.github.io/2019/01/12/odoo-essentials-12-chapter7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Alan Hou">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Alan Hou的个人博客">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Alan Hou的个人博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2019/01/12/odoo-essentials-12-chapter7/" class="post-title-link" itemprop="url">第七章 Odoo 12开发之记录集 – 使用模型数据</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2019-01-12 00:00:00" itemprop="dateCreated datePublished" datetime="2019-01-12T00:00:00+08:00">2019-01-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2023-02-03 13:43:35" itemprop="dateModified" datetime="2023-02-03T13:43:35+08:00">2023-02-03</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>本文为<a target="_blank" rel="noopener" href="https://alanhou.org/odoo-12-development/">最好用的免费ERP系统Odoo 12开发手册</a>系列文章第七篇。</p>
<p>在上一篇文章中，我们概览了模型创建以及如何从模型中载入和导出数据。现在我们已有数据模型和相关数据，是时候学习如何编程与其进行交互 了。模型的 ORM（Object-Relational Mapping）提供了一些交互数据的方法，称为 API（Application Programming Interface）。这包括基本的增删改查(CRUD)操作，也包括一些其它操作，如数据导入导出，以及改善用户界面和体验的工具方法。它还包含一些我们在前面文章中所看到的装饰器。这些都让我们可以通过添加新的方法来调用 ORM 进行相关操作。</p>
<p>本文主要内容有：</p>
<ul>
<li>使用 shell 命令交互式地学习 ORM API</li>
<li>理解执行环境和上下文</li>
<li>使用记录集和作用域(domain)查询数据</li>
<li>在记录集中访问数据</li>
<li>在记录中写入</li>
<li>编写记录集</li>
<li>使用底层 SQL 和数据库事务</li>
</ul>
<h2 id="开发准备"><a href="#开发准备" class="headerlink" title="开发准备"></a>开发准备</h2><p>本文代码使用交互式 shell 命令行执行，无需使用前面章节的代码。</p>
<h2 id="使用-shell-命令行"><a href="#使用-shell-命令行" class="headerlink" title="使用 shell 命令行"></a>使用 shell 命令行</h2><p>Python带有命令行界面，是研究其语法一个很好的方式。Odoo 也有类似的功能，可以交互式的测试命令的执行效果，这就是 shell 命令行。在命令行中执行以下命令并指定数据库即可使用：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~/odoo-dev/odoo/odoo-bin shell -d dev12</span><br></pre></td></tr></table></figure>

<p>此时在终端上可以看到正常的服务启动信息，等到出现&gt;&gt;&gt;Python提示符时即为完成，可以输入命令了。</p>
<blockquote>
<p>ℹ️<strong>Odoo 9中的修改</strong><br>shell 功能在9.0中才添加。Odoo 8.0可使用社区模块来添加这一功能。只需下载并放入 addons 路径即可使用，下载请见<a target="_blank" rel="noopener" href="https://www.odoo.com/apps/modules/8.0/shell/">应用市场</a>。</p>
</blockquote>
<p>此处 self 表示管理员用户的记录，可通过如下命令进行确认：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; self</span><br><span class="line">res.users(1,)</span><br><span class="line">&gt;&gt;&gt; self._name</span><br><span class="line">&#x27;res.users&#x27;</span><br><span class="line">&gt;&gt;&gt; self.login</span><br><span class="line">&#x27;__system__&#x27;</span><br></pre></td></tr></table></figure>

<p>在以上 shell 会话中，我们检查了自己的环境：</p>
<ul>
<li>self命令表示res.users记录集，仅包含一条 id 为1的记录</li>
<li>查看self._name获得记录集模型名，你可能猜到了，是’res.users’</li>
<li>记录的 name 值为OdooBot</li>
<li>记录的 login 字段值为__system__</li>
</ul>
<blockquote>
<p>ℹ️<strong>Odoo 12中的修改</strong><br>id 号为1的超级用户由原来的 admin 变成无法直接登录的内部系统用户。现在 admin 的 id 号为 2并且不是超级用户，但默认各应用会将其加入所有安全组。主要原因是避免用户使用超级用户账号来执行日常操作。这样的风险是该用户会跳过权限规则并导致数据的不一致，比如跨公司(cross-company)关联。现在超级用户仅用于检测问题或具体的跨公司操作。</p>
</blockquote>
<p>和 Python 一样，可通过 Ctrl + D退出该命令行。此时会结束服务并返回到系统shell 命令行。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2dd1317b68f24dcfa42684093cede038~tplv-k3u1fbpfcp-zoom-1.image" alt="Odoo 12 shell 命令行"></p>
<h2 id="执行环境"><a href="#执行环境" class="headerlink" title="执行环境"></a>执行环境</h2><p>Odoo shell 中包含一个 self 引用，类似于在res.users模型的方法中看到的那样。如我们所见，self 是一个记录集。记录集自带环境信息，包括浏览信息的用户以及其它上下文信息，如语言和时区。下面我们会学习执行环境中可用的属性、环境上下文的用处以及如何修改该上下文。</p>
<h3 id="环境属性"><a href="#环境属性" class="headerlink" title="环境属性"></a>环境属性</h3><p>我们可通过如下代码查看当前环境：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; self.env</span><br><span class="line">&lt;odoo.api.Environment object at 0x7f78a26026a0&gt;</span><br></pre></td></tr></table></figure>

<p>self.env 中的执行环境中有以下属性：</p>
<ul>
<li>env.cr是正在使用的数据库游标(cursor)</li>
<li>env.user是当前用户的记录</li>
<li>env.uid是会话用户 id，与env.user.id相同</li>
<li>env.context是会话上下文的不可变字典</li>
</ul>
<p>环境还提供对带有所有已安装模型注册表的访问，如self.env[‘res.partner’]返回一条对 partner 模型的引用。然后我们还可以对其使用search()或browse()方法来获取记录集：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; self.env[&#x27;res.partner&#x27;].search([(&#x27;name&#x27;, &#x27;like&#x27;, &#x27;Ad&#x27;)])</span><br><span class="line">res.partner(10, 35, 3)</span><br></pre></td></tr></table></figure>

<p>上例中返回的res.partner模型记录集包含三条记录，id 分别为10, 35和3。记录集并没有按 id 排序，因为使用了相应模型的默认排序。就 partner 模型而言，默认的_order为display_name。</p>
<h3 id="环境上下文"><a href="#环境上下文" class="headerlink" title="环境上下文"></a>环境上下文</h3><p>环境上下文是一个带有会话数据的字典，可用于客户端用户界面以及服务端 ORM 和业务逻辑中。在客户端中，它可以把信息从一个视图带到另一个视图中，比如前一个视图中活跃的记录 id，通过点击链接或按钮，可将默认值带入到下一个视图中。在服务端中，一些记录集的值会依赖于上下文提供的本地化设置。具体的例子有lang键影响可翻译字段的值。上下文还可为服务端代码提供信号。比如active_test键在设为 False 时，会改变ORM中search()方法的行为，它会忽略记录中的active标记，inactive(假删除)的记录也会被返回。</p>
<p>客户端的初始上下文长这样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#x27;lang&#x27;: &#x27;en_US&#x27;, &#x27;tz&#x27;: &#x27;Europe/Brussels&#x27;, &#x27;uid&#x27;: 2&#125;</span><br></pre></td></tr></table></figure>

<p>补充：服务端查看上下文命令为self.context_get()或self.env.context</p>
<p>其中 lang 键为用户语言，tz 为时区信息，uid 为当前用户 id。记录中的内容随当前依赖的上下文可能会不同：</p>
<ul>
<li>translated字段根据活跃的 lang 语言不同值也会不同</li>
<li>datetimep字段根据活跃的的 tz 时区不同时间会不同</li>
</ul>
<p>在上一个视图中点击链接或按钮打开表单时，一个active_id键会被加入上下文，它带有原表单我们所在位置记录的 id。以列表视图为例，active_ids上下文键中包含上一个列表中所选择的记录 id 列表。</p>
<p>在客户端中，上下文可用于使用default_或default_search_前缀在目录视图上设置默认值或启动默认过滤器。举例如下：</p>
<ul>
<li>设置当前用户为user_id字段默认值，使用{‘default_user_id’: uid}</li>
<li>在目标视图上默认启动filter_my_books过滤器，使用{‘default_search_filter_my_tasks’: 1}</li>
</ul>
<h3 id="修改记录集执行环境"><a href="#修改记录集执行环境" class="headerlink" title="修改记录集执行环境"></a>修改记录集执行环境</h3><p>记录集执行环境是不可变的，因此不能被修改，但我们可以创建一个变更环境并使用它来执行操作。我们通过如下方法来实现：</p>
<ul>
<li>env.sudo(user)中传入一条用户记录并返回该用户的环境。如未传入用户，则使用__system__超级用户root，这时可绕过安全规则执行指定操作。</li>
<li>env.with_context(<dictionary>) 替换原上下文为新的上下文</li>
<li>env.with_context(key&#x3D;value,…)修改当前上下文，为一些键设置值</li>
</ul>
<p>此外还有一个env.ref()函数，传入一个外部标识符字符串并返回它的记录，请参见：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; self.env.ref(&#x27;base.user_root&#x27;)</span><br><span class="line">res.users(1,)</span><br></pre></td></tr></table></figure>

<h2 id="使用记录集和作用域-domain-查询数据"><a href="#使用记录集和作用域-domain-查询数据" class="headerlink" title="使用记录集和作用域(domain)查询数据"></a>使用记录集和作用域(domain)查询数据</h2><p>在方法或 shell 会话中，self表示当前模型，并且我们仅能访问该模型的记录。要访问其它模型就需要使用self.env。例如self.env[‘res.partner’]返回一条对 Partner 模型的引用(也是一个空记录集)。我们可以使用search()或browse()来获取记录集，其中search()方法使用域表达式来定义记录选择范围。</p>
<h3 id="创建记录集"><a href="#创建记录集" class="headerlink" title="创建记录集"></a>创建记录集</h3><p>search()方法接收一个域表达式并返回符合条件记录的记录集。空域[] 将返回所有记录。</p>
<blockquote>
<p>ℹ️如果模型有特殊字段 active，默认只有active&#x3D;True的记录才在选择范围内</p>
</blockquote>
<p>还可以使用以下关键字参数：</p>
<ul>
<li>order是一个数据库查询语句中ORDER BY使用的字符串，通常是一个逗号分隔的字段名列表。每个字段都可接DESC关键字，用于表示倒序排列。</li>
<li>limit设置获取记录的最大条数</li>
<li>offset忽略前 n 前记录，可配合limit使用来一次查询指定范围记录</li>
</ul>
<p>有时我们只要知道满足某一条件的记录条数，这时可使用search_count()来返回记录条数而非记录集。这节约了先获取记录列表再记数的开销，在还没有获取记录集且仅想知道记录条数时这样会更高效。</p>
<p>browse()方法接收一个 ID 列表或单个ID并返回这些记录的记录集。在我们知道 ID 并想要获取记录时这就非常方便了。</p>
<p>一些使用示例如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; self.env[&#x27;res.partner&#x27;].search([(&#x27;name&#x27;, &#x27;like&#x27;, &#x27;Pac&#x27;)])</span><br><span class="line">res.partner(42, 62)</span><br><span class="line">&gt;&gt;&gt; self.env[&#x27;res.partner&#x27;].browse([42, 62])</span><br><span class="line">res.partner(42, 62)</span><br></pre></td></tr></table></figure>

<h3 id="域表达式"><a href="#域表达式" class="headerlink" title="域表达式"></a>域表达式</h3><p>域(domain)用于过滤数据记录。它使用一个特殊语法来供 Odoo ORM解析，生成数据库查询中的 WHERE 表达式。域表达式是一组条件组成的列表，每个条件都是一个 <strong>(‘字段名’, ‘运算符’, ‘值’)</strong> 组成的元组，例如，[(‘is_done’,’&#x3D;’,False)]是仅带有一个条件的有效域表达式。以下是对各个元素的说明：</p>
<ul>
<li><p>字段名：是一个待过滤字段，可使用点号标记来表示关联模型中的字段</p>
</li>
<li><p>值：在 Python 表达式中运行。可使用字面值，如数字、布尔值、字符串和列表，也可使用运行上下文中的字段和标识符。针对域其实有两种运行上下文：</p>
<ul>
<li>在窗口操作或字段属性等客户端中使用时，可使用原生字段值来渲染当前可用视图，但不能对其使用点标记符</li>
<li>在服务端使用时，如安全记录规则或服务端 Python 代码中，可以对字段使用点标记符，因为当前记录是一个对象</li>
</ul>
</li>
<li><p>运算符：可以是以下中的一个</p>
<ul>
<li>常用比较运算符有&lt;, &gt;, &lt;&#x3D; , &gt;&#x3D;, &#x3D;和!&#x3D;。</li>
<li>‘&#x3D;like’和’&#x3D;ilike’匹配某一模式，这里下划线_匹配单个字符，百分号%匹配任意一组字符。</li>
<li>‘like’匹配’%value%’模式，’ilike’与其相似但忽略大小写。还可以使用’not like’和’not ilike’运算符。</li>
<li>‘child of’在配置支持层级关联的模型中查找层级关系中的子级值。</li>
<li>‘in’ 和’not in’用于查看给定列表的包含，所以其值为一个列表。用于to-many关联字段时，in运算符和contains运算符一样。</li>
<li>‘not in’是in的反向运算，用于查看不在列表中的值。</li>
</ul>
</li>
</ul>
<p>域表达式是一个列表并且包含多个条件元组。默认这些条件使用AND逻辑运算符连接，也就是说它仅返回满足所有条件的记录。也可以使用显式逻辑运算符 - ‘&amp;’符号表示 AND 运算符（默认值），管道运算符’|’表示OR运算符。这两个运算符会作用于接下来的两项，递归执行。后面我们会一起来详细了解。</p>
<blockquote>
<p>ℹ️域表达式使用了更为正式的定义方式：前缀标记法，也称波兰表达式(Polish notation)：运算符放在运算项之前。AND和OR是二元运算符，而NOT是一元运算符。</p>
</blockquote>
<p>感叹号’!’表示NOT运算符，可用于下一项的运算，因此要放执行的否定项之前。例如[‘!’, (‘is_done’,’&#x3D;’,True)]将过滤出所有未完成(not-don e)的记录。</p>
<p>下一项本身也可以是一个作用其后续项的运算符，形成一个嵌套条件。下例可以有助于我们进行理解。在服务端记录规则中，可以找到类似下面这样的域表达式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[&#x27;|&#x27;,</span><br><span class="line">    (&#x27;message_follower_ids&#x27;, &#x27;in&#x27;, [user.partner_id.id]),</span><br><span class="line">    &#x27;|&#x27;,</span><br><span class="line">        (&#x27;user_id&#x27;, &#x27;=&#x27;, user.id),</span><br><span class="line">        (&#x27;user_id&#x27;, &#x27;=&#x27;, False)</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>这个域过滤出当前用户在follower列表中并且是负责人用户，或者没有负责人用户的用户集。第一个’|’或运算符作用于 follower 条件以及下一个条件的结果。下一个条件是后面两个条件的并集：用户ID是当前会话用户或未进行设置。下图是上例域表达式的抽象语法树表示：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3f31f8ad52864d9db84f22caa8105ad2~tplv-k3u1fbpfcp-zoom-1.image" alt="Odoo 12域表达式抽象语法树"></p>
<h2 id="在记录集中访问数据"><a href="#在记录集中访问数据" class="headerlink" title="在记录集中访问数据"></a>在记录集中访问数据</h2><p>一旦获取了数据集，就可以查看其中包含的数据了。下面的几个部分中我们就来看看如何访问记录集中的数据。我们可以获取单条记录的字段值，称为单例(singleton)。关联字段带有特殊属性，我们可通过点号标记来查看关联记录。最后我们一起思考处理日期和时间记录并进行格式转换。</p>
<h3 id="访问记录中数据"><a href="#访问记录中数据" class="headerlink" title="访问记录中数据"></a>访问记录中数据</h3><p>记录集的一个特例是仅有一条记录，称为单例。单例仍是记录集，在需要记录集的地方均可使用。与多元素记录集不同，单例可使用点号标记访问它的字段，如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; print(self.name)</span><br><span class="line">OdooBot</span><br></pre></td></tr></table></figure>

<p>下个例子中我们看看同一个 self 单例和记录集相同的行为，我们可对其进行遍历。它只有一条记录，所以只会打印出一个名称：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; for rec in self:</span><br><span class="line">...     print(rec.name)</span><br><span class="line">...</span><br><span class="line">OdooBot</span><br></pre></td></tr></table></figure>

<p>尝试访问有多条记录的记录集字段值会产生错误，所以在不确定操作的是否为单例数据集时就会产生问题。对于设计仅操作单例的方法，可在开头处使用self.ensure_one()，如果 self 不是单例时将抛出错误。</p>
<blockquote>
<p>ℹ️空记录也是单例。这样很方便，因为访问字段会返回 None 而非抛出错误。对于关联字段同样如此，使用点号标记访问关联记录也不会抛出错误。</p>
</blockquote>
<h3 id="访问关联字段"><a href="#访问关联字段" class="headerlink" title="访问关联字段"></a>访问关联字段</h3><p>如前面所见，模型可包含关联字段：many-to-one, one-to-many和many-to-many。这些字段类型的值为记录集。</p>
<p>对于many-to-one，其值可以是单例或空记录集。两种情况下都可以直接访问字段值。如下例中的命令是正确并安全的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; self.company_id</span><br><span class="line">res.company(1,)</span><br><span class="line">&gt;&gt;&gt; self.company_id.name</span><br><span class="line">&#x27;YourCompany&#x27;</span><br><span class="line">&gt;&gt;&gt; self.company_id.currency_id</span><br><span class="line">res.currency(1,)</span><br><span class="line">&gt;&gt;&gt; self.company_id.currency_id.name</span><br><span class="line">&#x27;EUR&#x27;</span><br></pre></td></tr></table></figure>

<p>为避免麻烦，空记录可像单例一样操作，访问其字段值不会返回错误而是返回 False。所以我们可以使用点号标记来遍历字段，而无需担心因其值为空而报错，如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; self.company_id.parent_id</span><br><span class="line">res.company()</span><br><span class="line">&gt;&gt;&gt; self.company_id.parent_id.name</span><br><span class="line">False</span><br></pre></td></tr></table></figure>

<h3 id="访问时间和日期值"><a href="#访问时间和日期值" class="headerlink" title="访问时间和日期值"></a>访问时间和日期值</h3><p>在记录集中，日期和日期时间值以原生 Python 对象展示，例如，在查询上次 admin 用户登录日期时：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; self.browse(2).login_date</span><br><span class="line">datetime.datetime(2019, 1, 8, 9, 2, 54, 45546)</span><br></pre></td></tr></table></figure>

<p>因为日期和日期时间是 Python 对象，它们可使用这些对象的所有功能。</p>
<blockquote>
<p>ℹ️<strong>Odoo 12中的修改</strong><br>date和datetime字段值以 Python 对象表示，而此前 Odoo 版本中它们以文本字符串表示。这些字段类型值仍可像此前 Odoo 版本中那样使用文本表示。</p>
</blockquote>
<p>日期和时间在数据库中以原生的世界标准时间(UTC) 格式存储，不受时区影响。 在记录集中看到的datetime值也是 UTC格式，在客户端中向用户展示时，datetime值会根据当前会话的时间设置来转换成用户的时区。这一设置存储在上下文的tz键中，如{‘tz’: ‘Europe&#x2F;Brussels’}。这一转换由客户端负责，而不是由服务端完成。</p>
<p>例如在布鲁塞尔(UTC+1)的用户输入12:00 AM数据库中会存储为10:00 AM UTC，而在纽约(UTC-4) 的用户查看时则为06:00 AM。</p>
<p>补充：请不要怀疑作者的数学是不是体育老师教的😂，布鲁塞尔为东一区，纽约为西五区，但冬令时和夏令时让这个问题变复杂了。将12:00修改为11:00应该就正确了。</p>
<blockquote>
<p>ℹ️Odoo 服务日志消息时间戳使用UTC时间而非本地服务器时间</p>
</blockquote>
<p>相反的转换，由会话时区转换为UTC，也需由客户端在将用户输入的datetime传回服务器时完成。日期对象可进行比较和相减来获取两个日期的时间差，时间差是一个timedelta对象。timedelta可通过date运算对date和datetime对象进行加减。这些对象由 Python 标准库datetime模块提供，以下是使用它进行的基本运算示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; from datetime import date</span><br><span class="line">&gt;&gt;&gt; date.today()</span><br><span class="line">datetime.date(2019, 1, 12)</span><br><span class="line">&gt;&gt;&gt; from datetime import timedelta</span><br><span class="line">&gt;&gt;&gt; timedelta(days=7)</span><br><span class="line">datetime.timedelta(7)</span><br><span class="line">&gt;&gt;&gt; date.today() + timedelta(days=7)</span><br><span class="line">datetime.date(2019, 1, 19)</span><br></pre></td></tr></table></figure>

<p>对于date, datetime和timedelta数据类型的完整参考请见<a target="_blank" rel="noopener" href="https://docs.python.org/3.6/library/datetime.html">Python 官方文档</a>。Odoo 还在odoo.tools.date_utils模块中提供了一些额外的便利函数，这些函数有：</p>
<ul>
<li>start_of(value, granularity)是某个特定刻度时间区间的开始时间，这些刻度有year, quarter, month, week, day或hour</li>
<li>end_of(value, granularity)是某个特定刻度时间区间的结束时间</li>
<li>add(value, <strong>kwargs)为指定值加上一个时间间隔。</strong>kwargs参数由一个relativedelta对象来定义时间间隔。这些参数可以是years, months, weeks, days, hours, minutes等等</li>
<li>subtract(value, **kwargs)为指定值减去一个时间间隔</li>
</ul>
<p>relativedelta对象来自dateutil库，可使用months或years执行date运算（Python的timedelta标准库仅支持days）。更多内容请见<a target="_blank" rel="noopener" href="https://dateutil.readthedocs.io/">相关文档</a>。以下为上述函数的一些使用示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; from odoo.tools import date_utils</span><br><span class="line">&gt;&gt;&gt; from datetime import datetime</span><br><span class="line">&gt;&gt;&gt; date_utils.start_of(datetime.now(), &#x27;week&#x27;)</span><br><span class="line">datetime.datetime(2019, 1, 7, 0, 0)</span><br><span class="line">&gt;&gt;&gt; date_utils.end_of(datetime.now(), &#x27;week&#x27;)</span><br><span class="line">datetime.datetime(2019, 1, 13, 23, 59, 59, 999999)</span><br><span class="line">&gt;&gt;&gt; from datetime import date</span><br><span class="line">&gt;&gt;&gt; date_utils.add(date.today(), months=2)</span><br><span class="line">datetime.date(2019, 3, 12)</span><br><span class="line">&gt;&gt;&gt; date_utils.subtract(date.today(), months=2)</span><br><span class="line">datetime.date(2018, 11, 12)</span><br></pre></td></tr></table></figure>

<p>这些工具方法在odoo.fields.Date和the odoo.fields.Datetime对象中也可使用，如：</p>
<ul>
<li>fields.Date.today()返回服务器所需格式的当前日期，它使用UTC作为一个引用。这足以计算默认值，这种情况下只需使用函数名无需添加括号。</li>
<li> fields.Datetime.now() 返回服务器所需格式的当前datetime，它使用UTC作为一个引用。这足以计算默认值，</li>
<li>fields.Date.context_today(record, timestamp&#x3D;None)在会话上下文中返回带有当前日期的字符串。时间从记录上下文中获取。可选项timestamp参数是一个datetime对象，如果传入将不使用当前时间，而使用传入值。</li>
<li>fields.Datetime.context_timestamp(record, timestamp)将原生的datetime值(无时区)转换为具体时区的datetime。时区从记录上下文中提取，因此使了前述函数名。</li>
</ul>
<h3 id="转换文本形式的日期和时间"><a href="#转换文本形式的日期和时间" class="headerlink" title="转换文本形式的日期和时间"></a>转换文本形式的日期和时间</h3><p>在Odoo 12以前，在进行运算前我们需要对文本形式的date和datetime进行转换。有些工作可帮助我们完成文本和原生数据类型的相互转换。这在此前的 Odoo 版本中都非常有用并且在 Odoo 12中也仍然相关：我们要将给到的日期格式化为文本。为便于格式之间的转换，fields.Date和fields.Datetime都提供了如下函数：</p>
<ul>
<li>to_date将字符串转换为date对象</li>
<li>to_datetime(value)将字符串转换为datetime对象</li>
<li>to_string(value)将date或datetime对象转换为 Odoo 11及之前版本Odoo服务所需的字符串格式</li>
</ul>
<p>函数所需的文本格式由 Odoo 通过如下方式默认预置：</p>
<ul>
<li>odoo.tools.DEFAULT_SERVER_DATE_FORMAT</li>
<li>odoo.tools.DEFAULT_SERVER_DATETIME_FORMAT</li>
</ul>
<p>它们分别与%Y-%m-%d和%Y-%m-%d %H:%M:%S相对应。from_string用法示例如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; from odoo import fields</span><br><span class="line">&gt;&gt;&gt; fields.Datetime.to_datetime(&#x27;2019-01-12 13:48:50&#x27;)</span><br><span class="line">datetime.datetime(2019, 1, 12, 13, 48, 50)</span><br></pre></td></tr></table></figure>

<p>对于其它的日期和时间格式，可使用datetime对象中的strptime方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; from datetime import datetime</span><br><span class="line">&gt;&gt;&gt; datetime.strptime(&#x27;1/1/2019&#x27;, &#x27;%d/%m/%Y&#x27;)</span><br><span class="line">datetime.datetime(2019, 1, 1, 0, 0)</span><br></pre></td></tr></table></figure>

<h2 id="在记录中写入"><a href="#在记录中写入" class="headerlink" title="在记录中写入"></a>在记录中写入</h2><p>有两种写入记录的方式：使用对象形式直接分配和使用write() 方法。第一种很简单但一次只能操作一条记录，效率较低。因为每次分配都执行一次写操作，会产生冗余的重复计算。第二种要求写入关联字段时使用特殊语法，但每条命令可写入多个字段和记录，记录计算更为高效。</p>
<h3 id="使用对象形式分配值写入"><a href="#使用对象形式分配值写入" class="headerlink" title="使用对象形式分配值写入"></a>使用对象形式分配值写入</h3><p>记录集实施活跃记录模式。也就是说我们可以为其分配值，并且会将这些修改在数据库中持久化存储。这是一种操作数据的易于理解和便捷的方式，但一次只能操作一个字段和一条记录。如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; root = self.env[&#x27;res.users&#x27;].browse(1)</span><br><span class="line">&gt;&gt;&gt; print(root.name)</span><br><span class="line">OdooBot</span><br><span class="line">&gt;&gt;&gt; root.name = &#x27;Superuser&#x27;</span><br><span class="line">&gt;&gt;&gt; print(root.name)</span><br><span class="line">Superuser</span><br></pre></td></tr></table></figure>

<p>虽然使用的是活跃记录模式，也可以通过分配记录值来设置关联字段。对于many-to-one字段，分配的值必须是单条记录（单例）。对于to-many字段，也可以通过一条记录集分配，来替换关联记录列表为新列表（如果有的话），这里允许任何大小的记录集。</p>
<h3 id="通过-write-方法写入"><a href="#通过-write-方法写入" class="headerlink" title="通过 write()方法写入"></a>通过 write()方法写入</h3><p>我们还可以使用write()方法来同时更新多条记录中的多个字段，仅需一条数据库命令。所以在重视效果时就应优先考虑这一方式。write() 接收一个字典来进行字段和值的映射。这会更新记录集中的所有记录并且没有返回值，如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; Partner = self.env[&#x27;res.partner&#x27;]</span><br><span class="line">&gt;&gt;&gt; recs = Partner.search( [(&#x27;name&#x27;, &#x27;ilike&#x27;, &#x27;Azure&#x27;)] )</span><br><span class="line">&gt;&gt;&gt; recs.write(&#123;&#x27;comment&#x27;: &#x27;Hello!&#x27;&#125;)</span><br><span class="line">True</span><br></pre></td></tr></table></figure>

<p>与对象形式的分配不同，使用write() 方法时我们不能直接为关联字段分配记录集对象。取而代之的是，我们需要使用所需的记录ID来从记录集中进行提取。在写入many-to-one字段时，写入的值必须是关联记录的ID。例如，我们不用self.write({‘user_id’: self.env.user})，而应使用self.write({‘user_id’: self.env.user.id})。</p>
<p>在写入to-many字段时，写入的值必须使用和 XML 数据文件相同的特殊语法，这在第五章 <a target="_blank" rel="noopener" href="https://alanhou.org/odoo12-import-export-data/">Odoo 12开发之导入、导出以及模块数据</a>中有介绍。比如，我们设置图书作者列表为author1和author2，这是两条 Partner 记录。| 管道运算符可拼接记录来创建一个记录集，因此使用对象形式的分配可以这么写：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">publisher.child_ids = author1 | author2</span><br></pre></td></tr></table></figure>

<p>使用write()方法，同样的操作如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">book.write( &#123; &#x27;child_ids&#x27;: [(6, 0, [author1.id, author2.id])] &#125; )</span><br></pre></td></tr></table></figure>

<p>回顾第五章 <a target="_blank" rel="noopener" href="https://alanhou.org/odoo12-import-export-data/">Odoo 12开发之导入、导出以及模块数据</a>的写入语法，最常用的命令如下：</p>
<ul>
<li>(4, id, _)添加一条记录</li>
<li>(6, _, [ids])替换关联记录列表为所传入的列表</li>
</ul>
<h3 id="写入日期和时间值"><a href="#写入日期和时间值" class="headerlink" title="写入日期和时间值"></a>写入日期和时间值</h3><p>从 Odoo 12开始，不论是直接分配还是使用 write()方法，日期和时间字段都可以 Python 原生数据类型写入。我们仍可以使用文本形式值写入日期和时间：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; demo = self.search([(&#x27;login&#x27;, &#x27;=&#x27;, &#x27;demo&#x27;)])</span><br><span class="line">&gt;&gt;&gt; demo.login_date</span><br><span class="line">False</span><br><span class="line">&gt;&gt;&gt; demo.login_date = &#x27;2019-01-01 09:00:00&#x27;</span><br><span class="line">&gt;&gt;&gt; demo.login_date</span><br><span class="line">datetime.datetime(2019, 1, 1, 9, 0)</span><br></pre></td></tr></table></figure>

<h3 id="创建和删除记录"><a href="#创建和删除记录" class="headerlink" title="创建和删除记录"></a>创建和删除记录</h3><p>write()方法用于向已有记录写入日期，但我们还需要创建和删除记录。这通过create()和unlink()模型方法实现。create()接收所需创建记录字段和值组成的字典，语法与 write()一致。没错，默认值会被自动应用，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; Partner = self.env[&#x27;res.partner&#x27;]</span><br><span class="line">&gt;&gt;&gt; new = Partner.create(&#123;&#x27;name&#x27;: &#x27;ACME&#x27;, &#x27;is_company&#x27;: True&#125;)</span><br><span class="line">&gt;&gt;&gt; print(new)</span><br><span class="line">res.partner(64,)</span><br><span class="line">&gt;&gt;&gt; print(new.customer) # customer标记默认为 True</span><br><span class="line">True</span><br></pre></td></tr></table></figure>

<p>unlink()方法会删除记录集中的记录，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; rec = Partner.search([(&#x27;name&#x27;, &#x27;=&#x27;, &#x27;ACME&#x27;)])</span><br><span class="line">&gt;&gt;&gt; rec.unlink()</span><br><span class="line">2019-01-12 06:32:48,601 2612 INFO dev12 odoo.models.unlink: User #1 deleted mail.message records with IDs: [28]</span><br><span class="line">2019-01-12 06:32:48,651 2612 INFO dev12 odoo.models.unlink: User #1 deleted ir.attachment records with IDs: [416, 415, 414]</span><br><span class="line">2019-01-12 06:32:48,655 2612 INFO dev12 odoo.models.unlink: User #1 deleted res.partner records with IDs: [64]</span><br><span class="line">2019-01-12 06:32:48,666 2612 INFO dev12 odoo.models.unlink: User #1 deleted mail.followers records with IDs: [7]</span><br><span class="line">True</span><br></pre></td></tr></table></figure>

<p>以上我们看到日志中几条其它记录被删除的消息，这些是所删除 partner 关联字段的串联删除。</p>
<p>还有copy()模型方法可用于复制已有记录，它接收一个可选参数来在新记录中修改值，如复制demo 用户创建一个新用户：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; demo = self.env.ref(&#x27;base.user_demo&#x27;)</span><br><span class="line">&gt;&gt;&gt; new = demo.copy(&#123;&#x27;name&#x27;: &#x27;Daniel&#x27;, &#x27;login&#x27;: &#x27;daniel&#x27;, &#x27;email&#x27;: &#x27;&#x27;&#125;)</span><br></pre></td></tr></table></figure>

<p>带有copy&#x3D;False属性的字段不会被自动拷贝。to-many关联字段带有该标记时默认被禁用，因此也不可拷贝。</p>
<h2 id="重构记录集"><a href="#重构记录集" class="headerlink" title="重构记录集"></a>重构记录集</h2><p>记录集还支持一些其它运算。我们可查看一条记录是否在记录集中。如果x是一个单例，并且my_recordset是一个包含多条记录的记录集，可使用如下代码：</p>
<ul>
<li>x in my_recordset</li>
<li>x not in my_recordset</li>
</ul>
<p>还能使用如下运算：</p>
<ul>
<li>recordset.ids 返回记录集元素的ID列表</li>
<li>recordset.ensure_one()检查是否为单条记录（单例）；若不是，则抛出ValueError异常</li>
<li>recordset.filtered(func)返回一个过滤了的记录集，func可以是一个函数或一个点号分隔的表达式来表示字段路径，可参见下面的示例。</li>
<li>recordset.mapped(func)返回一个映射值列表。除函数外，还可使用文本字符串作为映射的字段名。</li>
<li>recordset.sorted(func)返回一个排好序的记录值。除函数外，文本字符串可用作排序的字段名。reverse&#x3D;True是其可选参数。</li>
</ul>
<p>以下是这些函数的使用示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; rs0 = self.env[&#x27;res.partner&#x27;].search([])</span><br><span class="line">&gt;&gt;&gt; len(rs0)</span><br><span class="line">48</span><br><span class="line">&gt;&gt;&gt; starts_A = lambda r: r.name.startswith(&#x27;A&#x27;)</span><br><span class="line">&gt;&gt;&gt; rs1 = rs0.filtered(starts_A)</span><br><span class="line">&gt;&gt;&gt; print(rs1)</span><br><span class="line">res.partner(63, 59, 14, 35)</span><br><span class="line">&gt;&gt;&gt; rs1.sorted(key=lambda r: r.id, reverse=True)</span><br><span class="line">res.partner(63, 59, 35, 14)</span><br><span class="line">&gt;&gt;&gt; rs2 = rs1.filtered(&#x27;is_company&#x27;)</span><br><span class="line">&gt;&gt;&gt; print(rs2)</span><br><span class="line">res.partner(14,)</span><br><span class="line">&gt;&gt;&gt; rs2.mapped(&#x27;name&#x27;)</span><br><span class="line">[&#x27;Azure Interior&#x27;]</span><br><span class="line">&gt;&gt;&gt; rs2.mapped(lambda r: (r.id, r.name))</span><br><span class="line">[(14, &#x27;Azure Interior&#x27;)]</span><br></pre></td></tr></table></figure>

<p>我们势必会对这些关联字段中的元素进行添加、删除或替换的操作，那么就带来了一个问题：如何操作这些记录集呢？</p>
<p>记录集是不可变的，也就是说不能直接修改其值。那么修改记录集就意味着在原有的基础上创建一个新的记录集。一种方式是使用所支持的集合运算：</p>
<ul>
<li>rs1 | rs2是一个集合的并运算，会生成一个包含两个记录集所有元素的记录集</li>
<li>rs1 + rs2是集合加法运算，会将两个记录集拼接为一个记录集，这可能会带来集合中有重复记录</li>
<li>rs1 &amp; rs2是集合的交集运算，会生成一个仅在两个记录集中同时出现元素组成的数据集</li>
<li>rs1 - rs2是集合的差集运算，会生成在rs1中有但rs2中没有的元素组成的数据集</li>
</ul>
<p>还可以使用分片标记，例如：</p>
<ul>
<li>rs[0]和rs[-1]分别返回第一个和最后一个元素</li>
<li>rs[1:]返回除第一元素外的记录集拷贝。其结果和rs - rs[0]相同，但保留了排序</li>
</ul>
<blockquote>
<p>ℹ️<strong>Odoo 10中的修改</strong><br>从Odoo 10开始，记录集操作保留了排序。此前的 Odoo 版本中，记录集操作不一定会保留排序，虽然加运算和切片已知是保留排序的。</p>
</blockquote>
<p>我们可以用如下运算通过删除或添加元素来修改记录集：</p>
<ul>
<li>self.author_ids |&#x3D; author1：如果不存在author1，它会将author1加入记录集</li>
<li>self.author_ids -&#x3D; author1：如果author1存在于记录集中，会进行删除</li>
<li>self.author_ids &#x3D; self.author_ids[:-1]删除最后一条记录</li>
</ul>
<p>关联字段包含记录集值。many-to-one 可包含单例记录集，to-many字段包含任意数量记录的记录集。</p>
<h2 id="使用底层-SQL-和数据库事务"><a href="#使用底层-SQL-和数据库事务" class="headerlink" title="使用底层 SQL 和数据库事务"></a>使用底层 SQL 和数据库事务</h2><p>数据库引入运算在一个数据库事务上下文中执行。通常我们无需担心这点，因为服务器在运行模型方法时会进行处理。但有些情况下，可能需要对事务进行更精细控制。这可通过数据库游标self.env.cr来实现，如下所示：</p>
<ul>
<li>self.env.cr.commit()执行事务缓冲的写运算</li>
<li>self.env.cr.rollback()取消上次 commit之后的写运算，如果尚未 commit，则回滚所有操作</li>
</ul>
<blockquote>
<p><strong>小贴士：</strong> 在shell会话中，直到执行self.env.cr.commit()时数据操作才会在数据库中生效</p>
</blockquote>
<p>通过游标execute() 方法，我们可以直接在数据库中运行 SQL 语句。它接收一个要运行的SQL 语句，以及第二个可选参数：一个用作 SQL 参数值的元组或列表。这些值会用在%s占位符之处。</p>
<ul>
<li>ℹ️<strong>注意：</strong><br>在cr.execute() 中我们不应直接编写拼接参数的SQL查询。众所周知这样做会带来SQL注入攻击的安全风险。保持使用%s占位符并通过第二个参数来传值。</li>
</ul>
<p>如果使用SELECT查询，会获取到记录。fetchall() 函数以元组列表的形式获取所有行，dictfetchall()则以字典列表的形式获取，示例如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; self.env.cr.execute(&quot;SELECT id, login FROM res_users WHERE login=%s OR id=%s&quot;, (&#x27;demo&#x27;,1))</span><br><span class="line">&gt;&gt;&gt; self.env.cr.fetchall()</span><br><span class="line">[(1, &#x27;__system__&#x27;), (6, &#x27;demo&#x27;)]</span><br><span class="line">&gt;&gt;&gt; self.env.cr.execute(&quot;SELECT id, login FROM res_users WHERE login=%s OR id=%s&quot;, (&#x27;demo&#x27;,1))</span><br><span class="line">&gt;&gt;&gt; self.env.cr.dictfetchall()</span><br><span class="line">[&#123;&#x27;id&#x27;: 1, &#x27;login&#x27;: &#x27;__system__&#x27;&#125;, &#123;&#x27;id&#x27;: 6, &#x27;login&#x27;: &#x27;demo&#x27;&#125;]</span><br></pre></td></tr></table></figure>

<p>还可以使用数据操纵语言(DML) 来运行指令，如UPDATE和INSERT。因为服务器保留数据缓存，这可能导致与数据库中实际数据的不一致。出于这个原因，在使用原生DML后，应使用self.env.cache.invalidate()清除缓存。</p>
<blockquote>
<p>ℹ️<strong>注意：</strong><br>直接在数据库中执行SQL语句可能会导致数据不一致，请仅在确定时进行该操作。</p>
</blockquote>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在本文中，我们学习了如何操作模型数据以及执行 CRUD 运算：创建、读取、更新和删除数据。这是实现我们的业务逻辑和自动化的基石。</p>
<p>对于ORM API的测试，我们使用了Odoo交互式 shell 命令行。我们通过self.env环境运行了命令，该环境可访问模型注册表并提供命令运行相关信息的上下文，如当前语言 lang 和时区 tz。</p>
<p>记录集使用search(<domain>)或browse([<ids>])ORM 方法创建。之后可对其进行遍历访问每个单例(一条独立的记录)。我们还可以使用对象样式的点号标记在单例中获取和设置记录值。</p>
<p>除直接为单例分配值外，我们还可以使用write(<dict>)来通过单条命令更新记录集中的所有元素。create(), copy()和unlink()命令用于创建、拷贝和删除记录。</p>
<p>记录集可被检查和操作，检查运算符包含in和not in。重构运算符包含并集的|，交集的&amp;以及切片:。可用的转换包含提取 ID 列表的.ids、.mapped(<field>)、.filtered(<func>) 或.sorted(<func>)。</p>
<p>最后，通过self.env.cr中暴露的游标对象可控制底层 SQL 运行和事务控制。</p>
<p>在下一篇文章中，我们将为模型添加业务逻辑层，实现通过ORM API来自动化操作的模型方法。</p>
<p> </p>
<p>☞☞☞第八章 <a target="_blank" rel="noopener" href="https://alanhou.org/odoo12-business-logic/">Odoo 12开发之业务逻辑 - 业务流程的支持</a></p>
<p>本文首发地址：<a target="_blank" rel="noopener" href="https://alanhou.org/developer-mode-odoo12/">Alan Hou 的个人博客</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://alanhou.github.io/2019/01/11/odoo-essentials-12-chapter6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Alan Hou">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Alan Hou的个人博客">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Alan Hou的个人博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2019/01/11/odoo-essentials-12-chapter6/" class="post-title-link" itemprop="url">第六章 Odoo 12开发之模型 – 结构化应用数据</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2019-01-11 00:00:00" itemprop="dateCreated datePublished" datetime="2019-01-11T00:00:00+08:00">2019-01-11</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2023-02-03 13:40:02" itemprop="dateModified" datetime="2023-02-03T13:40:02+08:00">2023-02-03</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>本文为<a target="_blank" rel="noopener" href="https://alanhou.org/odoo-12-development/">最好用的免费ERP系统Odoo 12开发手册</a>系列文章第六篇。</p>
<p>在本系列文章第三篇<a target="_blank" rel="noopener" href="https://alanhou.org/odoo12-first-application/">Odoo 12 开发之创建第一个 Odoo 应用</a>中，我们概览了创建 Odoo 应用所需的所有组件。本文及接下来的一篇我们将深入到组成应用的每一层：模型层、视图层和业务逻辑层。</p>
<p>本文中我们将深入学习模型层，以及学习如何使用模型来设计应用所需的数据结构。我们会探索模型和字段的各项作用，包括定义模型关系、添加计算字段、创建数据约束。</p>
<p>本文的主要内容有：</p>
<ul>
<li>学习项目 - 优化图书馆应用</li>
<li>创建模型</li>
<li>创建字段</li>
<li>模型间的关系</li>
<li>计算字段</li>
<li>模型约束</li>
<li>了解 Odoo的 base 模型</li>
</ul>
<h2 id="开发准备"><a href="#开发准备" class="headerlink" title="开发准备"></a>开发准备</h2><p>本文代码基于第三章 <a target="_blank" rel="noopener" href="https://alanhou.org/odoo12-first-application/">Odoo 12 开发之创建第一个 Odoo 应用</a>中所创建的代码。相关代码参见<a target="_blank" rel="noopener" href="https://github.com/alanhou/odoo12-development/tree/b7207ba4acae69e5055ac3e2273328610aef3246"> GitHub 仓库</a>，本文学习完成项目请参见<a target="_blank" rel="noopener" href="https://github.com/alanhou/odoo12-development/tree/master/chapter6">GitHub 仓库</a>。相关代码需放在一个 addons 路径中，然后在 Odoo中安装了 library_app 模型，本文中例子将会对该模块修改和新增代码。</p>
<h2 id="学习项目-优化图书应用"><a href="#学习项目-优化图书应用" class="headerlink" title="学习项目 - 优化图书应用"></a>学习项目 - 优化图书应用</h2><p>在第三章 <a target="_blank" rel="noopener" href="https://alanhou.org/odoo12-first-application/">Odoo 12 开发之创建第一个 Odoo 应用</a>中，我们创建了一个library_app插件模块，实现了一个简单的library.book模型用于展示图书目录。本文中，我们将回到该模块来丰富图书数据。我们将添加一个分类层级，添加如下用作图书分类：</p>
<ul>
<li>Name：分类标题</li>
<li>Parent：所属父级分类</li>
<li>Subcategories：将此作为父级分类的子分类</li>
<li>Featured book或author: 此分类中所选图书或作者</li>
</ul>
<p>图书模型中已有一些基本信息字段，我们会添加一些字段来展示 Odoo中的数据类型。我们还会为图书模型添加一些约束：</p>
<ul>
<li>标题和出版日期应唯一</li>
<li>输入的ISBN应为有效</li>
</ul>
<h2 id="创建模型"><a href="#创建模型" class="headerlink" title="创建模型"></a>创建模型</h2><p>模型是 Odoo 框架的核心，它们描述应用的数据结构，是应用服务和数据库存储之间的桥梁。可围绕模型实现业务逻辑来为应用添加功能，用户界面也建立在模型之上。下面我们将学习模型的通用属性，用于影响行为，以及几种模型类型：普通(regular)、临时(transient)和抽象(abstract)类型。</p>
<h3 id="模型属性"><a href="#模型属性" class="headerlink" title="模型属性"></a>模型属性</h3><p>模型类可以使用控制其部分行为的额外属性，以下是最常用的属性：</p>
<ul>
<li>_name 是我们创建的 Odoo 模型的内部标识符，在创建新模型时为必填。</li>
<li>_description是对用户友好的模块记录标题，在用户界面中查看模型时显示。可选但推荐添加。</li>
<li>_order设置浏览模型记录时或列表视图的默认排序。其值为 SQL 语句中 order by 使用的字符串，所以可以传入符合 SQL 语法的任意值，它有智能模式并支持可翻译及many-to-one字段名。</li>
</ul>
<p>我们的图书模型中已使用了_name 和_description属性，可以添加一个_order属性来默认以图书名排序，然后按出版日期倒序排（新出版在前）。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class Book(models.Model):</span><br><span class="line">    _name = &#x27;library.book&#x27;</span><br><span class="line">    _description = &#x27;Book&#x27;</span><br><span class="line">    _order = &#x27;name, date_published desc&#x27;</span><br></pre></td></tr></table></figure>

<p>在高级用例中还会用到如下属性：</p>
<ul>
<li>_rec_name在从关联字段（如many-to-one关联）中引用时作为记录描述。默认使用模型中常用的 name字段，但可以指定任意其它字段。</li>
<li>_table是模型对应的数据表名。默认表名由 ORM 通过替换模块名中的点为下划线来自动定义，但是可通过该属性指定表名。</li>
<li>_log_access&#x3D;False用于设置不自动创建审计追踪字段：create_uid, create_date, write_uid和write_date。</li>
<li>_auto&#x3D;False 用于设置不自动创建模型对应的数据表。如有需要，可通过重载init()方法来创建数据库对象：数据表或视图。</li>
</ul>
<p>还有用于继承模块的_inherit和_inherits属性，在本文后续会深入学习。</p>
<h3 id="模型和-Python-类"><a href="#模型和-Python-类" class="headerlink" title="模型和 Python 类"></a>模型和 Python 类</h3><p>Odoo 模型以 Python 类的形式展现，在前面的代码中，有一个继承了 models.Model类的 Python 类：Book，创建了新 Odoo 模型：library.book。Odoo的模型保存在中央注册表(central registry)中，可通过 env 环境对象(老 API 中称为 pool)获取。 它是一个数据库保存所有可用模型类引用的字典，其中的词条可通过模型名引用 。具体来说，模型方法中的代码可使用self.env[‘library.book’]来获取表示 library.book模型的模型类。</p>
<p>可以看出模型名非常重要，因为它是访问该注册表的关键。模型名的规则是以点号连接的小写单词，如library.book或library.book.category。内核模块中的其它示例有project.project, project.task和project.task.type。模型名应使用单数，如library.book而非library.books。</p>
<blockquote>
<p>ℹ️由于历史原因，有些内核模型没有遵循这一规则，如res.users。</p>
</blockquote>
<p>模型名必须全局唯一，因此第一个单词应使用模块关联的主应用对应，以图书应用而言，模型名前缀使用 library。其它示例如内核模块的project, crm和sale。另一方面 Python 类仅为所声明文件本地内容，名称仅需在代码文件中唯一即可。因为类名不会与其它模块中的类产生冲突，也就不需为其添加主应用相关的前缀。</p>
<p>类的命名规范是使用驼峰命名法（CamelCase），这与 Python 标准的 PEP8编码规范一致。</p>
<h3 id="临时-Transient-模型和抽象模型"><a href="#临时-Transient-模型和抽象模型" class="headerlink" title="临时(Transient)模型和抽象模型"></a>临时(Transient)模型和抽象模型</h3><p>在前述代码中以及在大多数据 Odoo 模型中的类会继承models.Model类。这类模型在数据库中持久化存储：会为模型创建数据表并存储记录直至删除。但 Odoo 中还有另外两种模型类型：临时模型和抽象模型。</p>
<p>临时模型继承models.TransientModel类，用于向导式的用户交互。这类数据会存储在数据库中，但仅是临时性的。会定时运行清空 job 来清除这些表中的老数据。比如Settings &gt; Translations菜单下的Load a Language对话窗口，就使用了临时模型来存储用户选择并实现向导逻辑。在第八章 <a target="_blank" rel="noopener" href="https://alanhou.org/odoo12-business-logic/">Odoo 12开发之业务逻辑 - 业务流程的支持</a>中会有讨论临时模型的示例。</p>
<p>抽象模型继承models.AbstractModel类，它不带有数据存储。抽象模型用作可复用的功能集，与使用 Odoo 继承功能的其它模型配合使用。例如mail.thread是 Discuss 应用中的一个抽象模型，用于为其它模型添加消息和follower 功能。</p>
<h3 id="检查已有模型"><a href="#检查已有模型" class="headerlink" title="检查已有模型"></a>检查已有模型</h3><p>通过 Python 类创建的模型和字段在用户界面中有自己的元标签。启动开发者模式，访问菜单Settings &gt; Technical &gt; Database Structure &gt; Models，这里有数据库中的所有模型。点击列表中的模型会打开详情表单：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/634beb737f534e429234aeae938ae54c~tplv-k3u1fbpfcp-zoom-1.image" alt="Odoo 12图书模型"></p>
<p>这是一个检查模型结构很好的工具，因为在这里可以看到不同模块所有自定义结果。上图中在右上角 In Apps字段中可以看到library.book模型的定义来自library_app和library_member两个模块。下方区域中还有几个包含附加信息的标签：</p>
<ul>
<li>Fields可快速查看模型字段</li>
<li>Access Rights是授予不同权限组的访问控制规则</li>
<li>Views显示模型所带的视图列表</li>
</ul>
<p>我们可以通过开发者菜单下的View Metadata选项查看模型的外部标识符。模型的外部标识符或XML ID由 ORM 自动生成，但根据规则可预知，如library.book模型的外部标识符为model_library_book。在定义安全访问控制列表经常在 CSV 文件中使用到这些XML ID。</p>
<blockquote>
<p><strong>小贴士：</strong> 如第一章 <a target="_blank" rel="noopener" href="https://alanhou.org/developer-mode-odoo12/">使用开发者模式快速入门 Odoo 12</a>中所见，模型表单是可编辑的。通过这里是可以创建并修改模型、字段和视图的。可在此处创建原型然后在插件模块中实现。</p>
</blockquote>
<h2 id="创建字段"><a href="#创建字段" class="headerlink" title="创建字段"></a>创建字段</h2><p>创建新模型后的第一步是添加字段。Odoo 支持我们能想到的所有基本数据类型，如文本字符串、整型、浮点型、布尔型、日期、日期时间以及图片或二进制数据。下面就来看看 Odoo 中一些可用的字段类型吧。</p>
<h3 id="基本字段类型"><a href="#基本字段类型" class="headerlink" title="基本字段类型"></a>基本字段类型</h3><p>我们将为图书模型添加几种可用的字段类型，编辑library_app&#x2F;models&#x2F;library_book.py文件后 Book 类会长这样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">class Book(models.Model):</span><br><span class="line">...</span><br><span class="line">    # String fields</span><br><span class="line">    name = fields.Char(&#x27;Title&#x27;, required=True)</span><br><span class="line">    isbn = fields.Char(&#x27;ISBN&#x27;)</span><br><span class="line">    book_type = fields.Selection(</span><br><span class="line">        [(&#x27;paper&#x27;, &#x27;Paperback&#x27;),</span><br><span class="line">        (&#x27;hard&#x27;, &#x27;Hardcover&#x27;),</span><br><span class="line">        (&#x27;electronic&#x27;, &#x27;Electronic&#x27;),</span><br><span class="line">        (&#x27;other&#x27;, &#x27;Other&#x27;)],</span><br><span class="line">        &#x27;Type&#x27;)</span><br><span class="line">    notes = fields.Text(&#x27;Internal Notes&#x27;)</span><br><span class="line">    descr = fields.Html(&#x27;Description&#x27;)</span><br><span class="line"></span><br><span class="line">    # Numeric fields:</span><br><span class="line">    copies = fields.Integer(default=1)</span><br><span class="line">    avg_rating = fields.Float(&#x27;Average Rating&#x27;, (3,2))</span><br><span class="line">    price = fields.Monetary(&#x27;Price&#x27;, &#x27;currency_id&#x27;)</span><br><span class="line">    currency_id = fields.Many2one(&#x27;res.currency&#x27;) # price helper</span><br><span class="line"></span><br><span class="line">    # Date and time fields</span><br><span class="line">    date_published = fields.Date()</span><br><span class="line">    last_borrow_date = fields.Datetime(</span><br><span class="line">        &#x27;Last Borrowed On&#x27;,</span><br><span class="line">        default=lambda self: fields.Datetime.now())</span><br><span class="line"></span><br><span class="line">    # Other fields</span><br><span class="line">    active = fields.Boolean(&#x27;Active?&#x27;, default=True)</span><br><span class="line">    image = fields.Binary(&#x27;Cover&#x27;)</span><br><span class="line"></span><br><span class="line">    # Relational Fields</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>此处是 Odoo 中所带的非关联字段示例，每个字段都带有所需的位置参数。</p>
<blockquote>
<p>ℹ️Python 中有两类参数：位置参数和关键字参数。位置参数需按指定顺序使用。例如，f(x, y)应以f(1, 2)方式调用。关键字参数通过参数名传递。如同一个例子，可使用f(x&#x3D;1, y&#x3D;2)甚至是f(1, y&#x3D;2)两种传参方式混用。更多有关关键字参数知识参见 Python <a target="_blank" rel="noopener" href="https://docs.python.org/3/tutorial/controlflow.html#keyword-arguments">官方文档</a>。</p>
</blockquote>
<p>对于大多数非关联字段，第一个参数是字段标题，与字符串字段参数相对应。它用作用户界面标签的默认文本。这个参数是可选的，如未传入，会根据字段名将下划线替换为空格并将单词首字母大写来自动生成。以下为可用的非关联字段类型以及其对应的位置参数：</p>
<ul>
<li>Char(string)是一个单行文本，唯一位置参数是string字段标签。</li>
<li>Text(string)是一个多行文本，唯一位置参数是string字段标签。</li>
<li>Selection(selection, string)是一个下拉选择列表。选项位置参数是一个[(‘value’, ‘Title’),]元组列表。元组第一个元素是存储在数据库中的值，第二个元素是展示在用户界面中的描述。该列表可由其它模块使用selection_add关键字参数扩展。</li>
<li>Html(string)存储为文本字段，但有针对用户界面 HTML 内容展示的特殊处理。出于安全考虑，该字段会被清洗，但清洗行为可被重载。</li>
<li>Integer(string)仅需字段标题字符串参数。</li>
<li>Float(string, digits)带有第二个可选参数digits，该字段是一个指定字段精度的(x,y)元组，x 是数字总长，y 是小数位。</li>
<li>Monetary(string, currency_field)与浮点字段类似，但带有货币的特殊处理。第二个参数currency_field用于存储所使用货币，默认应传入currency_id字段。</li>
<li>Date(string)和Datetime(string)字段只需一个字符串文本位置参数。</li>
<li>Boolean(string)的值为True 或False，可传入一个字符串文本位置参数。</li>
<li>Binary(string)存储文件类二进制文件，只需一个字符串文本位置参数。它可由Python使用 base64编码字符串进行处理。</li>
</ul>
<blockquote>
<p><strong>ℹ️Odoo 12中的修改</strong><br>Date和Datetime 字段现在 ORM 中作为日期对象处理。此前的版本中作为文本字符串处理，进行操作时需与 Python 日期对象间进行转换。</p>
</blockquote>
<p>文本字符串：Char, Text和Html有一些特有属性：</p>
<ul>
<li>size (Char)设置最大允许尺寸。无特殊原因建议不要使用，例如可用于带有最大允许长度的社保账号。</li>
<li>translate使用得字段内容可翻译，带有针对不同语言的不同值。</li>
<li>trim默认值为 True，启动在网络客户端中自动去除周围的空格。可通过设置trim&#x3D;false来取消。</li>
</ul>
<blockquote>
<p><strong>ℹ️Odoo 12中的修改</strong><br>trim字段属性在 Odoo 12中引入，此前版本中文本字段保存前后的空格。</p>
</blockquote>
<p>除这些以外，还有在后面会介绍到的关联字段。不过， 我们还要先了解下有关字段属性的其它知识。</p>
<h3 id="常用字段属性"><a href="#常用字段属性" class="headerlink" title="常用字段属性"></a>常用字段属性</h3><p>字段还有一些其它属性供我们定义其行为。以下是常用的属性，通常都作为关键字参数：</p>
<ul>
<li>string是字段的默认标签，在用户界面中使用。除Selection和关联字段外，它都是第一个位置参数，所以大多数情况下它用作关键字参数。如未传入，将由字段名自动生成。</li>
<li>default设置字段默认值。可以是具体值（如 active字段中的default&#x3D;True），或是可调用引用，有名函数或匿名函数均可。</li>
<li>help提供 UI 中鼠标悬停字段向用户显示的提示文本。</li>
<li>readonly&#x3D;True会使用户界面中的字段默认不可编辑。在 API 层面并没有强制，模型方法中的代码仍然可以向其写入。仅针对用户界面设置。</li>
<li>required&#x3D;True使得用户界面中字段默认必填。这通过在数据库层面为列添加NOT NULL 约束来实现。</li>
<li>index&#x3D;True为字段添加数据库索引，让搜索更快速，但同时也会部分降低写操作速度。</li>
<li>copy&#x3D;False让字段在使用 ORM copy()方法复制字段时忽略该字段。除 to-many 关联字段外，其它字段值默认会被复制。</li>
<li>groups可限制字段仅对一些组可访问并可见。值为逗号分隔的安全组XML ID列表，如groups&#x3D;’base.group_user,base.group_system’。</li>
<li>states传入依赖 state字段值的 UI 属性的字典映射值。可用属性有readonly, required和invisible，例如states&#x3D;{‘done’:[(‘readonly’,True)]}。</li>
</ul>
<blockquote>
<p>ℹ️注意states 字段等价于视图中的 attrs 属性。同时注意视图也支持 states 属性，但用途不同，传入逗号分隔的状态列表来控制元素什么时候可见。</p>
</blockquote>
<p>以下为字段属性关键字参数的使用示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">name = fields.Char(</span><br><span class="line">    &#x27;Title&#x27;,</span><br><span class="line">    default=None,</span><br><span class="line">    index=True,</span><br><span class="line">    help=&#x27;Book cover title&#x27;,</span><br><span class="line">    readonly=False,</span><br><span class="line">    required=True,</span><br><span class="line">    translate=False,</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>如前所述，default 属性可带有固定值，或引用函数来自动计算默认值。对于简单运算，可使用 lambda 函数来避免过重的有名函数或方法的创建。以下是一个计算当前日期和时间默认值的常用示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">last_borrow_date = fields.Datetime(</span><br><span class="line">    &#x27;Last Borrowed On&#x27;,</span><br><span class="line">    default=lambda self: fields.Datetime.now(),</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>默认值也可以是一个函数引用，或待定义函数名字符串：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">last_borrow_date = fields.Datetime(</span><br><span class="line">    &#x27;Last Borrowed On&#x27;,</span><br><span class="line">    default=&#x27;_default_last_borrow_date&#x27;,</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">def _default_last_borrow_date(self):</span><br><span class="line">    return fields.Datetime.now()</span><br></pre></td></tr></table></figure>

<p>当模块数据结构在不同版本中变更时以下两个属性非常有用：</p>
<ul>
<li>deprecated&#x3D;True在字段被使用时记录一条 warning 日志</li>
<li>oldname&#x3D;’field’是在新版本中重命名字段时使用，可在升级模块时将老字段中的数据自动拷贝到新字段中</li>
</ul>
<h3 id="特殊字段名"><a href="#特殊字段名" class="headerlink" title="特殊字段名"></a>特殊字段名</h3><p>一些字段名很特别，可能是因为它们出于特殊目的作为 ORM 保留字，或者是由于内置功能使用了一些默认字段名。id 字段保留以用作标识每条记录的自增数字以及数据库主键，每个模型都会自动添加。</p>
<p>以下字段只要模型中没设置_log_access&#x3D;False都会在新模型中自动创建：</p>
<ul>
<li>create_uid为创建记录的用户</li>
<li>create_date是记录创建的日期和时间</li>
<li>write_uid是最后写入记录的用户</li>
<li>write_date是最后修改记录的日期和时间</li>
</ul>
<p>每条记录的这些字段信息都可通过开发者菜单下的View Metadata进行查看。一些内置 API 功能默认需要一些指定字段名。避免在不必要的场合使用这些字段名会让开发更轻松。其中有些字段名被保留并且不能在其它地方使用：</p>
<ul>
<li>name (通常为 Char)默认作为记录的显示名称。通过是一个 Char，但也可以是 Text 或Many2one字段类型。用作显示名的字段可修改为_rec_name模型属性。</li>
<li>active (Boolean型)允许我们关闭记录。带有active&#x3D;False的记录会自动从查询中排除掉。可在当前上下文中添加{‘active_test’: False} 来关闭这一自动过滤。可用作记录存档或假删除（soft delete）。</li>
<li>state (Selection类型) 表示记录生命周期的基本状态。它允许使用states字段属性来根据记录状态以具备不同的 UI 行为。动态修改视图：字段可在特定记录状态下变为readonly, required或invisible。</li>
<li>parent_id和parent_path Integer和Char型)对于父子层级关系具有特殊意义。本文后续会进行讨论。</li>
</ul>
<blockquote>
<p>ℹ️<strong>Odoo 12中的修改</strong><br>层级关联现在使用parent_path字段，它替代了老版本中已淘汰的parent_left和 parent_right字段(整型)。</p>
</blockquote>
<p>到目前为止我们讨论的都是非关联字段。但应用数据结构中很大一部分是描述实体间关联的。下面就一起来学习。</p>
<h2 id="模型间的关系"><a href="#模型间的关系" class="headerlink" title="模型间的关系"></a>模型间的关系</h2><p>中、大型业务应用有一个结构数据模型，需要关联所涉及到的不同实体间的数据。要实现这点，需要使用关联字段。再来看看我们的图书应用，图书模型中有如下关系：</p>
<ul>
<li>每本书有一个出版商。这是一个many-to-one 关联，在数据库引擎中通过外键实现。反过来则是one-to-many关联，表示一个出版商可出版多本书。</li>
<li>每本书可以有多名作者。这是一个many-to-many关联，反过来还是many-to-many关联，因为一个作者也可以有多本书。</li>
</ul>
<p>下面我们就会分别讨论这些关联。具体的用例就是层级关联，即一个模型中的记录与同模型中的其它记录关联。我们将引入一个图书分类模型解释这一情况。最后，Odoo 框架还支持弹性关系，即一个字段可指向其它表中的字段，这称为引用字段。</p>
<h3 id="Many-to-one关联"><a href="#Many-to-one关联" class="headerlink" title="Many-to-one关联"></a>Many-to-one关联</h3><p>many-to-one关联是对其它模型中记录的引用，例如在图书模型中，publisher_id表示图书出版商，是对partner记录的一个引用：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">publisher_id = fields.Many2one(</span><br><span class="line">    &#x27;res.partner&#x27;, string=&#x27;Publisher&#x27;)</span><br></pre></td></tr></table></figure>

<p>与所有关联字段一样，Many2one字段的第一个位置参数是关联模型(comodel关键字参数)。第二位置参数是字段标签(string关键字参数)，但这和其它关联字段不同，所以推荐使用像以上代码一样一直使用string关键字参数。</p>
<p>many-to-one模型字段在数据表中创建一个字段，并带有指向关联表的外键，其中为关联记录的数据库 ID。以下是many-to-one字段可用的关键字参数：</p>
<ul>
<li><p>ondelete定义关联记录删除时执行的操作：</p>
<ul>
<li>set null (默认值): 关联字段删除时会置为空值</li>
<li>restricted：抛出错误阻止删除</li>
<li>cascade：在关联记录删除时同时删除当前记录</li>
</ul>
</li>
<li><p>context是一个数据字典，可在浏览关联时为网页客户端传递信息，比如设置默认值。第八章 <a target="_blank" rel="noopener" href="https://alanhou.org/odoo12-business-logic/">Odoo 12开发之业务逻辑 - 业务流程的支持</a>中会做深入说明。</p>
</li>
<li><p>domain是一个域表达式：使用一个元组列表过滤记录来作为关联记录选项，第八章 <a target="_blank" rel="noopener" href="https://alanhou.org/odoo12-business-logic/">Odoo 12开发之业务逻辑 - 业务流程的支持</a>中会详细说明。</p>
</li>
<li><p>auto_join&#x3D;True允许ORM在使用关联进行搜索时使用SQL连接。使用时会跳过访问安全规则，用户可以访问安全规则不允许其访问的关联记录，但这样 SQL 的查询会更有效率且更快。</p>
</li>
<li><p>delegate&#x3D;True 创建一个关联记录的代理继承。使用时必须设置required&#x3D;True和ondelete&#x3D;’cascade’。代理继承更多知识参见第四章 <a target="_blank" rel="noopener" href="https://alanhou.org/odoo12-extending-modules/">Odoo 12 开发之模块继承</a>。</p>
</li>
</ul>
<h3 id="One-to-many反向关联"><a href="#One-to-many反向关联" class="headerlink" title="One-to-many反向关联"></a>One-to-many反向关联</h3><p>one-to-many关联是many-to-one的反向关联。它列出引用该记录的关联模型记录。比如在图书模型中，publisher_id与 parnter 模型是一个many-to-one关联。这说明partner与图书模型可以有一个one-to-many的反向关联，列出每个出版商出版的图书。</p>
<p>要让关联可用，我们可在 partner 模型中添加它，在library_app&#x2F;models&#x2F;res_partner.py文件中添加如下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">from odoo import fields, models</span><br><span class="line"></span><br><span class="line">class Partner(models.Model):</span><br><span class="line">    _inherit = &#x27;res.partner&#x27;</span><br><span class="line">    published_book_ids = fields.One2many(</span><br><span class="line">        &#x27;library.book&#x27;, # related model</span><br><span class="line">        &#x27;publisher_id&#x27;, # fields for &quot;this&quot; on related model</span><br><span class="line">        string=&#x27;Published Books&#x27;)</span><br></pre></td></tr></table></figure>

<p>我们向模块添加了新文件，所以不要忘记在library_app&#x2F;models&#x2F;<strong>init</strong>.py中导入该文件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">from . import library_book</span><br><span class="line">from . import res_partner</span><br></pre></td></tr></table></figure>

<p>One2many字段接收三个位置参数：</p>
<ul>
<li>关联模型 (comodel_name关键字参数)</li>
<li>引用该记录的模型字段 (inverse_name关键字参数)</li>
<li>字段标签 (string关键字参数)</li>
</ul>
<p>其它可用的关键字参数与many-to-one字段相同：context, domain和ondelete（此处作用于关联中的 many 这一方）。</p>
<h3 id="Many-to-many关联"><a href="#Many-to-many关联" class="headerlink" title="Many-to-many关联"></a>Many-to-many关联</h3><p>在两端都存在to-many关联时使用many-to-many关联。还是以我们的图书应用为例，书和作者之间是many-to-many关联：一本书可以有多个作者，一个作者可以有多本书。图书端有一个library.book模型：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class Book(models.Model):</span><br><span class="line">    _name = &#x27;library.book&#x27;</span><br><span class="line">...</span><br><span class="line">    author_ids = fields.Many2many(</span><br><span class="line">        &#x27;res.partner&#x27;, string=&#x27;Authors&#x27;)</span><br></pre></td></tr></table></figure>

<p>在作者端，我们也可以为res.partner添加一个反向关联：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class Partner(models.Model):</span><br><span class="line">    _inherit = &#x27;res.partner&#x27;</span><br><span class="line">    book_ids = fields.Many2many(</span><br><span class="line">        &#x27;library.book&#x27;, string=&#x27;Authored Books&#x27;)</span><br></pre></td></tr></table></figure>

<p>Many2many最少要包含一个关联模型位置参数（comodel_name关键字参数），推荐为字段标签提供一个string参数。</p>
<p>在数据库层面上，many-to-many关联不会在已有表中添加任何列。而是自动创建一个关联表来存储记录间的关联，该表仅有两个 ID 字段，为两张关联表的外键。默认关联表名由两个表名中间加下划线并在最后加上_rel 来组成。我们图书和作者关联，表名应为library_book_res_partner_rel。</p>
<p>有时我们可能需要重写这种自动生成的默认值。一种情况是关联模型名称过长，导致关联表名的长度超出PostgreSQL数据库63个字符的上限。这时就需要手动选择一个关联表名来符合字符数据要求。另一种情况是我们需要在相同模型间建立第二张many-to-many关联表。这时也需要手动提供一个关联表名来避免与已存在的第一张表名冲突。</p>
<p>有两种方案来重写关联表名：位置参数或关键字参数。通过字段位置参数定义示例如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># Book &lt;-&gt; Authors关联(使用位置参数)</span><br><span class="line">author_ids = fields.Many2many(</span><br><span class="line">    &#x27;res.partner&#x27;, # 关联模型（尾款）</span><br><span class="line">    &#x27;library_book_res_partner_rel&#x27;, # 要使用的关联表名</span><br><span class="line">    &#x27;a_id&#x27;, # 本记录关联表字段</span><br><span class="line">    &#x27;p_id&#x27;, # 关联记录关联表字段</span><br><span class="line">    &#x27;Authors&#x27;) # string标签文本</span><br></pre></td></tr></table></figure>

<p>要使可读性更强，也可使用关键字参数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># Book &lt;-&gt; Authors关联(使用关键字参数)</span><br><span class="line">author_ids = fields.Many2many(</span><br><span class="line">    comodel_name=&#x27;res.partner&#x27;, # 关联模型(必填)</span><br><span class="line">    relation=&#x27;library_book_res_partner_rel&#x27;, # 关联表名</span><br><span class="line">    column1=&#x27;a_id&#x27;, # 本记录关联表字段</span><br><span class="line">    column2=&#x27;p_id&#x27;, # 关联记录关联表字段</span><br><span class="line">    string=&#x27;Authors&#x27;) # string标签文本</span><br></pre></td></tr></table></figure>

<p>与one-to-many relational字段相似，many-to-many 字段还可以使用context, domain和auto_join这些关键字参数。</p>
<blockquote>
<p>ℹ️在创建抽象模型时，many-to-many中不要使用column1和column2属性。在 ORM 设计中对抽象模型有一个限制，如果指定关联表列名，就无法再被正常继承。</p>
</blockquote>
<h3 id="层级关联"><a href="#层级关联" class="headerlink" title="层级关联"></a>层级关联</h3><p>父子树状关联使用同一模型中many-to-one关联表示，来将每条记录引用其父级。反向的one-to-many关联对应记录的子级。Odoo 通过域表达式附加的child_of和parent_of操作符改良了对这些层级数据结构的支持。只要这些模型有parent_id字段（或_parent_name有效模型定义）就可以使用这些操作符。</p>
<p>通过设置_parent_store&#x3D;True和添加parent_path帮助字段可加快层级树的查询速度。该字段存储用于加速查询速度的层级树结构信息。</p>
<blockquote>
<p><strong>ℹ️Odoo 12中的修改</strong><br>parent_path帮助字段在 Odoo 12中引入。此前版本中使用parent_left和parent_right整型字段来实现相同功能，但在 Odoo 12中淘汰了这些字段。</p>
</blockquote>
<p>注意这些附加操作会带来存储和执行速度的开销，所以最好是用到读的频率大于写的情况下，比如本例中的分类树。仅在优化多节点深度层级时才需要使用，对于小层级或浅层级的可能会被误用。</p>
<p>为演示层级结构，我们将为图书应用添加一个分类树，用于为图书分类。在library_app&#x2F;models&#x2F;library_book_category.py文件中添加如下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">from odoo import api, fields, models</span><br><span class="line"></span><br><span class="line">class BookCategory(models.Model):</span><br><span class="line">    _name = &#x27;library.book.category&#x27;</span><br><span class="line">    _description = &#x27;Book Category&#x27;</span><br><span class="line">    _parent_store = True</span><br><span class="line"></span><br><span class="line">    name = fields.Char(translate=True, required=True)</span><br><span class="line">    # Hierarchy fields</span><br><span class="line">    parent_id = fields.Many2one(</span><br><span class="line">        &#x27;library.book.category&#x27;,</span><br><span class="line">        &#x27;Parent Category&#x27;,</span><br><span class="line">        ondelete=&#x27;restrict&#x27;)</span><br><span class="line">    parent_path = fields.Char(index=True)</span><br><span class="line"></span><br><span class="line">    # Optional but good to have:</span><br><span class="line">    child_ids = fields.One2many(</span><br><span class="line">        &#x27;library.book.category&#x27;,</span><br><span class="line">        &#x27;parent_id&#x27;,</span><br><span class="line">        &#x27;Subcategories&#x27;)</span><br></pre></td></tr></table></figure>

<p>这里定义了一个基本模型，包含引用父级记录的parent_id字段。为启用层级索引来加快树级搜索，添加了一个_parent_store&#x3D;True 模型属性。使用该属性必须要添加且必须要索引parent_path字段。引用父级的字段名应为parent_id，但如果声明了可选的_parent_name模型属性，则可以使用任意其它字段名。</p>
<p>添加字段列出直接的子级非常方便，即为上述代码中的one-to-many反向关联。还有不要忘记在library_app&#x2F;models&#x2F;<strong>init</strong>.py文件中添加对以上代码的引用：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">from . import library_book</span><br><span class="line">from . import res_partner</span><br><span class="line">from . import library_book_category</span><br></pre></td></tr></table></figure>

<h3 id="使用引用字段的弹性关联"><a href="#使用引用字段的弹性关联" class="headerlink" title="使用引用字段的弹性关联"></a>使用引用字段的弹性关联</h3><p>普通关联字段指定固定的引用co-model模型，但Reference字段类型不受这一限制，它支持弹性关联，因此相同字段不用限制只指向相同的目标模型。作为示例，我们使用图书分类模型来添加引用重点图书或作者。因此该字段可引用图书或 partner：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class BookCategory(models.Model):</span><br><span class="line">...   </span><br><span class="line">    highlighted_id = fields.Reference(</span><br><span class="line">        [(&#x27;library.book&#x27;, &#x27;Book&#x27;), (&#x27;res.partner&#x27;, &#x27;Author&#x27;)],</span><br><span class="line">        &#x27;Category Highlight&#x27;</span><br><span class="line">    )</span><br></pre></td></tr></table></figure>

<p>该字段定义与 selection 字段相似，但这里选择项为该字段中可以使用的模型。在用户界面中，用户会先选择列表中的模型，然后选择模型中的指定记录。</p>
<blockquote>
<p>ℹ️<strong>Odoo 12中的修改</strong><br>删除了可引用模型配置表。在此前版本中，可用于配置在 Reference 字段中可用的模型。通过菜单Settings &gt; Technical &gt; Database Structure可进行查看。这些配置可在 Reference 字段中使用odoo.addons.res.res_request.referenceable_models函数来替代模型选择列表。</p>
</blockquote>
<p>以下为有关引用字段的一些其它有用技术细节：</p>
<ul>
<li>引用字段在数据库中以model,id字符串形式存储</li>
<li>read()方法供外部应用使用，以格式化的(‘model_name’, id)元组返回，而不是常用的many-to-one字段的(id, ‘display_name’)形式</li>
</ul>
<h2 id="计算字段"><a href="#计算字段" class="headerlink" title="计算字段"></a>计算字段</h2><p>字段值除普通的读取数据库中存储值外，还可自动由函数计算。计算字段的声明和普通字段相似，但有一个额外的compute参数来定义用于计算的函数。大多数情况下，计算字段包含书写业务逻辑。因此要完全使用这一功能，还要学习第八章 <a target="_blank" rel="noopener" href="https://alanhou.org/odoo12-business-logic/">Odoo 12开发之业务逻辑 - 业务流程的支持</a>。此处我们将解释计算字段用法，但会使用简单的业务逻辑。</p>
<p>图书有出版商，我们的例子是在图书表单中添加出版商的国别。实现该功能，我们会使用基于publisher_id的计算字段，将会从出版商的country_id字段中获取值。</p>
<p>编辑library_app&#x2F;models&#x2F;library_book.py文件中的图书模型，代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Book(models.Model):</span><br><span class="line">...</span><br><span class="line">    publisher_country_id = fields.Many2one(</span><br><span class="line">        &#x27;res.country&#x27;, string=&#x27;Publisher Country&#x27;,</span><br><span class="line">        compute=&#x27;_compute_publisher_country&#x27;</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    @api.depends(&#x27;publisher_id.country_id&#x27;)</span><br><span class="line">    def _compute_publisher_country(self):</span><br><span class="line">        for book in self:</span><br><span class="line">            book.publisher_country_id = book.publisher_id.country_id</span><br></pre></td></tr></table></figure>

<p>以上代码添加了一个publisher_country_id字段，和一个计算其值的_compute_publisher_country方法。方法名作为字符串参数传入字段中，但也可以传递一个可调用引用(方法标识符，不带引号)。但这时需确定Python 文件中方法在字段之前定义。</p>
<p>计算如果依赖其它字段的话就需要使用@api.depends装饰器，通常都会依赖其它字段。它告诉服务器何时重新计算或缓存值。参数可接受一个或多个字段名，点号标记可用于了解字段关联。本例中，只要图书publisher_id的country_id变更了就会重新进行计算。</p>
<p>和平常一样，self 参数是要操作的字符集对象。我们需要对其遍历来作用于每条记录。计算值通过常用(写)操作来设置，本例中计算相当简单，我们为其分配当前图书的publisher_id.country_id值。</p>
<p>同样的计算方法可用于一个以上字段。这时同一方法在多个compute 字段参数中使用，计算方法将为所有计算字段分配值。</p>
<blockquote>
<p><strong>小贴士：</strong> 计算函数必须为一个或多个字段分配值用于计算。如果计算方法有 if 条件分支，确保每个分支中为计算字段分配了值。否则在未分配置值的分支中将会报错。</p>
</blockquote>
<p>现在我们还不会修改该模块的视图，但可通过在图书表单视图中点击开发者菜单中的Edit View选项，直接在表单 XML 中添加该字段查看效果。不必担心出问题，在下次模块升级时会进行覆盖。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bd2a6c1deeb643fdbb30f949aae26cf1~tplv-k3u1fbpfcp-zoom-1.image" alt="Odoo 12图书项目出版商国家"></p>
<h3 id="搜索和写入计算字段"><a href="#搜索和写入计算字段" class="headerlink" title="搜索和写入计算字段"></a>搜索和写入计算字段</h3><p>我们刚刚创建的计算字段可读取但不可搜索或写入。默认情况下计算字段是实时计算，而不存储在数据库中。这也是无法像普通字段那样进行搜索的原因。</p>
<p>我们可通过实现特殊方法来开启搜索和写入操作。计算字段可与 compute 方法一起设置实现搜索逻辑的 search 方法，以及实现写入逻辑的 inverse 方法。使用这些方法，计算字段可修改如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Book(models.Model):</span><br><span class="line">...</span><br><span class="line">    publisher_country_id = fields.Many2one(</span><br><span class="line">        &#x27;res.country&#x27;, string=&#x27;Publisher Country&#x27;,</span><br><span class="line">        compute=&#x27;_compute_publisher_country&#x27;，</span><br><span class="line">        # store = False, # 默认不在数据库中存储</span><br><span class="line">        inverse=&#x27;_inverse_publisher_country&#x27;,</span><br><span class="line">        search=&#x27;_search_publisher_country&#x27;,</span><br><span class="line">    )</span><br></pre></td></tr></table></figure>

<p>计算字段中的写入是计算的反向(inverse)逻辑。因此处理写入操作的方法称为 inverse，本例中 inverse 方法很简单。计算将book.publisher_id.country_id 的值复制给book.publisher_country_id，反向操作是将写入book.publisher_country_id的值拷贝给book.publisher_id.country_id field字段：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">def _inverse_publisher_country(self):</span><br><span class="line">    for book in self:</span><br><span class="line">        book.publisher_id.country_id = book.publisher_country_id</span><br></pre></td></tr></table></figure>

<p>注意这会修改出版商partner记录数据，因此也会修改相同出版商图书的相关字段。常规权限控制对这类写操作有效，因此仅有对 partner 模型有写权限的当前用户才能成功执行操作。</p>
<p>要为计算字段开启搜索操作，需要实现search 方法。为此我们需要能够将计算字段的搜索转换为使用常规存储字段的搜索域。本例中，实际的搜索可通过关联的publisher_id Partner 记录的country_id来实现：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">def _search_publisher_country(self, opearator, value):</span><br><span class="line">    return [(&#x27;publisher_id.country_id&#x27;, operator, value)]</span><br></pre></td></tr></table></figure>

<p>在模型上执行搜索时，域表达式用作实施过滤的参数。域表达式在第八章 <a target="_blank" rel="noopener" href="https://alanhou.org/odoo12-business-logic/">Odoo 12开发之业务逻辑 - 业务流程的支持</a>会做详细讲解，现在我们应了解它是一系列(field, operator, value)条件。</p>
<p>当域表达式的条件中出现该计算字段时就会调用这个搜索方法。它接收搜索的操作符和值，并将原搜索元素转换为一个域搜索表达式。country_id字段存储在关联的partner模型中，因此我们的搜索实现仅需修改原搜索表达式来使用publisher_id.country_id字段。</p>
<h3 id="存储计算字段"><a href="#存储计算字段" class="headerlink" title="存储计算字段"></a>存储计算字段</h3><p>通过在定义时设置store &#x3D; True还可以将计算字段值保存到数据库中。在任意依赖变更时值就会重新计算。因为值已被存储，所以可以像普通字段一样被搜索，也就不需要使用 search 方法了。</p>
<h3 id="关联字段"><a href="#关联字段" class="headerlink" title="关联字段"></a>关联字段</h3><p>前面我们实现的计算字段仅仅是从关联记录中将值拷贝到模型自己的字段中。这种常用情况可以由 Odoo 使用关联字段功能自动处理。关联字段通过关联模型的字段可在模型中直接可用，并且可通过点号标记法直接访问。这样在点号标记法不可用时(如 UI 表单视图)也可以使用该字段。</p>
<p>要创建关联字段，我们像普通计算字段那样声明一个所需类型的字段，但使用的不是 compute 属性，而是 related属性，设置用点号标记链来使用所需字段。我们可以使用引用字段来获取与上例publisher_country_id计算字段相同的效果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">publisher_country_id = fields.Many2one(</span><br><span class="line">    &#x27;res.country&#x27;, string=&#x27;Publisher Country&#x27;,</span><br><span class="line">    related=&#x27;publisher_id.country_id&#x27;,</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>本质上关联字段仅仅是快捷实现 search 和 inverse 方法的计算字段。也就是说可以直接对其进行搜索和写入，而无需书写额外的代码。默认关联字段是只读的，因inverse写操作不可用，可通过readonly&#x3D;False字段属性来开启写操作。</p>
<blockquote>
<p>ℹ️<strong>Odoo 12中的修改</strong><br>现在关联字段默认为只读：readonly&#x3D;True。此前版本中它默认可写，但事实证明这是一个默认值，因为它可能会允许修改配置或主数据这些不应被修改的数据。</p>
</blockquote>
<p>还应指出这些关联字段和计算字段一样可使用store&#x3D;True来在数据库中存储。</p>
<h2 id="模型约束"><a href="#模型约束" class="headerlink" title="模型约束"></a>模型约束</h2><p>通常应用需保证数据完整性，并执行一些验证来保证数据是完整和正确的。PostgreSQL数据库管理器支持很多可用验证：如避免重复，或检查值以符合某些简单条件。模型为此可声明并使用 PostgreSQL约束。一些检查要求更复杂的逻辑，最好是使用 Python 代码来实现。对这些情况，我们可使用特定的模型方法来实现 Python 约束逻辑。</p>
<h3 id="SQL模型约束"><a href="#SQL模型约束" class="headerlink" title="SQL模型约束"></a>SQL模型约束</h3><p>SQL约束加在数据表定义中，并由PostgreSQL直接执行。它由_sql_constraints类属性来定义。这是一个元组组成的列表，并且每个元组的格式为(name, code, error)：</p>
<ul>
<li>name是约束标识名</li>
<li>code是约束的PostgreSQL语法</li>
<li>error是在约束验证未通过时向用户显示的错误消息</li>
</ul>
<p>我们将向图书模型添加两个SQL约束。一条是唯一性约束，用于通过标题和出版日期是否相同来确保没有重复的图书；另一条是检查出版日期是否为未出版：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Book(models.Model):</span><br><span class="line">...</span><br><span class="line">    _sql_constraints = [</span><br><span class="line">        (&#x27;library_book_name_date_uq&#x27;, # 约束唯一标识符</span><br><span class="line">        &#x27;UNIQUE (name, date_published)&#x27;, # 约束 SQL 语法</span><br><span class="line">        &#x27;Book title and publication date must be unique&#x27;), # 消息</span><br><span class="line">        (&#x27;library_book_check_date&#x27;,</span><br><span class="line">        &#x27;CHECK (date_published &lt;= current_date)&#x27;,</span><br><span class="line">        &#x27;Publication date must not be in the future.&#x27;),</span><br><span class="line">    ]</span><br></pre></td></tr></table></figure>

<p>更多有关PostgreSQL约束语法，请参见<a target="_blank" rel="noopener" href="https://www.postgresql.org/docs/10/ddl-constraints.html">官方文档</a>。</p>
<h3 id="Python模型约束"><a href="#Python模型约束" class="headerlink" title="Python模型约束"></a>Python模型约束</h3><p>Python 约束可使用自定义代码来检查条件。检查方法应添加@api.constrains装饰器，并且包含要检查的字段列表，其中任意字段被修改就会触发验证，并且在未满足条件时抛出异常。就图书应用来说，一个明显的示例就是防止插入不正确的 ISBN 号。我们已经在_check_isbn()方法中书写了 ISBN 的校验逻辑。可以在模型约束中使用它来防止保存错误数据：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">from odoo.exceptions import ValidationError</span><br><span class="line"></span><br><span class="line">class Book(models.Model):</span><br><span class="line">...</span><br><span class="line">    @api.constrains(&#x27;isbn&#x27;)</span><br><span class="line">    def _constrain_isbn_valid(self):</span><br><span class="line">        for book in self:</span><br><span class="line">            if book.isbn and not book._check_isbn():</span><br><span class="line">                raise ValidationError(&#x27;%s is an invalid ISBN&#x27; % book.isbn)</span><br></pre></td></tr></table></figure>

<h2 id="了解-Odoo的-base-模型"><a href="#了解-Odoo的-base-模型" class="headerlink" title="了解 Odoo的 base 模型"></a>了解 Odoo的 base 模型</h2><p>在前面文章中，我们一起创建了新模型，如图书模型，但也使用了已有的模型，如  Odoo 自带的Partner 模型。下面就来介绍下这些内置模型。Odoo 内核中有一个base插件模块。它提供了 Odoo 应用所需的基本功能。然后有一组内置插件模块来提供标准产品中的官方应用和功能。base模块中包含两类模型：</p>
<ul>
<li>信息仓库(Information Repository)， ir.*模型</li>
<li>资源(Resources)， res.*模型</li>
</ul>
<p>信息仓库用于存储 Odoo 所需数据，以知道如何作为应用来运作，如菜单、视图、模型、Action 等等。Technical菜单下的数据通常都存储在信息仓库中。相关的例子有：</p>
<ul>
<li>ir.actions.act_window用于窗口操作</li>
<li>ir.ui.menu用于菜单项</li>
<li>ir.ui.view用于视图</li>
<li>ir.model用于模型</li>
<li>ir.model.fields用于模型字段</li>
<li>ir.model.data用于XML ID</li>
</ul>
<p>资源包含基本数据，基本上用于应用。以下是一些重要的资源模型：</p>
<ul>
<li>res.partner用于业务伙伴，如客户、供应商和地址等等</li>
<li>res.company用于公司数据</li>
<li>res.currency用于货币</li>
<li>res.country用于国家</li>
<li>res.users用于应用用户</li>
<li>res.groups用于应用安全组</li>
</ul>
<p>这些应该有助于你在未来遇到这些模型时理解它们来自何处。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>学习完本文，我们熟悉了模型带给我们构造数据模型的可能性。我们看到模型通常继承models.Model类，但还可使用models.Abstract来创建可复用的 mixin 模型、使用models.Transient来创建向导或高级用户对话。我们还学习了常见的模型属性，如_order 用于排序，_rec_name用于记录展示的默认值。</p>
<p>模型中的字段定义了所有它存储的数据。我们了解了可用的非关联字段类型以及它们支持的属性。我们还学习了关联字段的几种类型：many-to-one, one-to-many和many-to-many，以及它们如何定义模型间的关系，包括层级父子关系。</p>
<p>大多数字段在数据库中存储用户的输入，但字段也可以通过 Python 代码自动计算值。我们看到了如何实现计算字段，以及一些高级用法，如使计算字段可写及可搜索。</p>
<p>还有模型定义的一部分是约束，保持数据一致性和执行验证，可以通过PostgreSQL或Python代码实现。</p>
<p>一旦我们创建了数据模型，就应该为它提供一些默认和演示数据。在下一篇文章中我们将学习如何使用数据文件在系统中导入、导出和加载数据。</p>
<p> </p>
<p>☞☞☞第七章 <a target="_blank" rel="noopener" href="https://alanhou.org/odoo12-recordsets/">Odoo 12开发之记录集 - 使用模型数据</a></p>
<p>本文首发地址：<a target="_blank" rel="noopener" href="https://alanhou.org/developer-mode-odoo12/">Alan Hou 的个人博客</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://alanhou.github.io/2019/01/09/odoo-essentials-12-chapter5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Alan Hou">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Alan Hou的个人博客">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Alan Hou的个人博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2019/01/09/odoo-essentials-12-chapter5/" class="post-title-link" itemprop="url">第五章 Odoo 12开发之导入、导出以及模块数据</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2019-01-09 00:00:00" itemprop="dateCreated datePublished" datetime="2019-01-09T00:00:00+08:00">2019-01-09</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2023-02-03 13:38:22" itemprop="dateModified" datetime="2023-02-03T13:38:22+08:00">2023-02-03</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>本文为<a target="_blank" rel="noopener" href="https://alanhou.org/odoo-12-development/">最好用的免费ERP系统Odoo 12开发手册</a>系列文章第五篇。</p>
<p>大多数Odoo 模块的定义，如用户界面和安全规则，实际是存储在对应数据表中的数据记录。模块中的 XML 和 CSV 文件不是 Odoo 应用运行时使用，而是载入数据表的手段。正是因为这个原因，Odoo 模块的一个重要部分是在文件中放入数据以在插件安装时将其载入数据库。</p>
<p>模块可以包含初始数据和演示数据，可通过数据文件将它们加入模块。此外，了解 Odoo 数据的格式对于在项目实施上下文中导入导出业务数据也非常重要。</p>
<p>本文的主要内容有：</p>
<ul>
<li>理解外部标识符的概念</li>
<li>导入导出数据文件</li>
<li>使用 CSV 文件</li>
<li>添加模块数据</li>
<li>使用 XML 数据文件</li>
</ul>
<h2 id="开发准备"><a href="#开发准备" class="headerlink" title="开发准备"></a>开发准备</h2><p>本文要求读者可以运行Odoo 服务并已安装前面我们此前开发的图书应用。相关代码请见<a target="_blank" rel="noopener" href="https://github.com/alanhou/odoo12-development/tree/master/custom-addons">GitHub 仓库</a>。你可能也同时安装了第四章 <a target="_blank" rel="noopener" href="https://alanhou.org/odoo12-extending-modules/">Odoo 12 开发之模块继承</a>中创建的library_member模块，但本文并不要求使用该模型。</p>
<p>本文的更新后的代码请见<a target="_blank" rel="noopener" href="https://github.com/alanhou/odoo12-development/tree/master/chapter5">GitHub 仓库</a>。</p>
<h2 id="理解外部标识符的概念"><a href="#理解外部标识符的概念" class="headerlink" title="理解外部标识符的概念"></a>理解外部标识符的概念</h2><p>外部标识符，也称为XML ID，是用于唯一标识 Odoo 中特定记录的有可读性的字符串标识符。在Odoo 中加载数据时它们就很重要了，这样可以对已有数据记录进行修改或在其它数据记录中引用它。</p>
<p>首先我们将讨论外部标识符的工作原理以及如何对其进行检查。然后我们会学习如何使用网页客户端来查找指定数据记录的外部标识符，在创建插件模块或继承已有模块时需要经常用到。</p>
<h3 id="外部标识符的工作原理"><a href="#外部标识符的工作原理" class="headerlink" title="外部标识符的工作原理"></a>外部标识符的工作原理</h3><p>记录在数据库中的真实标识符是自动分配的序列号，在安装模块时没法预先知道将要分配的具体ID的。外部标识符让我们无需知道真实的数据库 ID便可以引用一条相关记录。XML ID 为数据库 ID 提供了一个方便的别名，藉于此我们可以在任何时刻引用某一指定记录。</p>
<p>Odoo 模块数据文件中使用XML ID来定义记录。其中一个原因是避免在升级模块时创建重复的记录，在升级时会再次将数据文件加载到数据库中。我们要检测已有记录来进行更新，而不是重复创建记录。另一个原因是使用XML ID来支持交叉数据：即需引用其它数据记录的数据记录。因为我们无法知道真实数据库 ID，使用XML ID来由 Odoo 框架来进行相应的转换。</p>
<p>Odoo 处理由外部标识符向所分配的真实数据库 ID 的转换。背后的机制相当简单：Odoo 维护一张外部标识符和对应数据库 ID 的映射表：ir.model.data model。</p>
<p>我们需启用开发者模式才能访问下文中的菜单。可通过在右上角头像左侧查看是否有调试图标，如果没有需在 Settings菜单页启用，具体方法可参照第一章 <a target="_blank" rel="noopener" href="https://alanhou.org/developer-mode-odoo12/">使用开发者模式快速入门 Odoo 12</a>中的内容。</p>
<p>通过菜单访问Settings &gt; Technical &gt; Sequences &amp; Identifiers &gt; External Identifiers可查看已有映射。例如访问外部标识符列表并过滤出library_app模块，将可以看到该模块生成的外部标识符：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/186832112e504016871929f26e0f2e41~tplv-k3u1fbpfcp-zoom-1.image" alt="Odoo 12图书项目外部标识符"></p>
<p>可以看到外部标识符有Complete ID标签。注意其组成部分为：模块名+.+标识符名，如library_app.action_library_book。</p>
<p>外部标识符仅需在 Odoo 模块内唯一，两个模块中使用相同标识符不会产生冲突。全局唯一标识符是由模块名和外部标识符共同组成的，在上图Complete ID项中可以看到。</p>
<p>在数据文件中使用外部标识符，我们可以选择完整的标识符或仅外部标识符部分。通常仅使用外部标识符会更简单，但使用完整标识符时我们可以引用其它模块中的数据记录。做引用时不要忘记在模块依赖中加入这些模块以确保在我们的记录之前加载这些记录。</p>
<blockquote>
<p><strong>小贴士：</strong> 有时即便引用相同模块中的XML ID也需使用完整标识符</p>
</blockquote>
<p>在上图列表最上方可以看到library_app.action_library_book完整标识符。这是我们在模块中创建的菜单操作，在相应的菜单项中引用。点击进入表单视图查看详情。图中可以看出library_app模块中的action_library_book外部标识符映射到ir.actions.act_window模型中的记录 ID，此处为85：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6c21eb08750b429eae7cbadc544a39f3~tplv-k3u1fbpfcp-zoom-1.image" alt=" Odoo 12图书项目外部标识符视图表单"></p>
<p>除了作为其它应用引用记录的一种方式外，外部标识符还可以避免重复导入带来的重复数据。一旦外部标识符已存在，则会在原有记录上更新，避免了重复数据的新建。</p>
<h3 id="查找外部标识符"><a href="#查找外部标识符" class="headerlink" title="查找外部标识符"></a>查找外部标识符</h3><p>在为我们的模块写入数据记录时，经常需要查找已有外部标识符来作引用。一种方式是访问菜单Settings &gt; Technical &gt; Sequences &amp; Identifiers &gt; External Identifiers，前面已经演示过。另一种方法是使用开发者菜单。在第一章 <a target="_blank" rel="noopener" href="https://alanhou.org/developer-mode-odoo12/">使用开发者模式快速入门 Odoo 12</a>中介绍了如何激开发者模式。</p>
<p>要查找一个数据记录的外部标识符，我们应打开对应的表单视图，在开发者菜单中选择View Metadata选项。此时会显示一个带有记录数据库 ID 和外部标识符（也称作XML ID）的对话框。比如要查看 demo 用户 ID，需通过 Settings &gt; Users &amp; Companies &gt; Users 进入用户表单视图，然后点击开发者工具菜单中的View Metadata选项。此时可以看到XML ID是base.user_demo，数据库 ID 是6：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/01e294e652c14e129b2ab6e8b30ff3c2~tplv-k3u1fbpfcp-zoom-1.image" alt="Odoo 12图书项目 demo 用户 Metadata"></p>
<p>查看表单、列表、搜索或 action 视图中的外部标识符，都可以使用开发者菜单。下面我们通过Edit View选项来打开相应视图的详情表单。此时可以查看到External ID字段，其值即为外部标识符。例如在下图中，可以看到图书表单视图的External ID为library_app.view_form_book：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/15cafabd62bb47959244858bb7e9d5d7~tplv-k3u1fbpfcp-zoom-1.image" alt="Odoo 图书项目图书表单视图"></p>
<h2 id="导入导出-CSV-数据文件"><a href="#导入导出-CSV-数据文件" class="headerlink" title="导入导出 CSV 数据文件"></a>导入导出 CSV 数据文件</h2><p>导出数据文件并查看文件结构的简易方式是使用内置的导出功能。通过生成 CSV 文件，我们可以了解手动导入系统所需的格式，或编辑该文件批量导入，甚至是使用它生成我们插件模块的演示数据。</p>
<p>下面我们一起来学习从 Odoo 用户界面导入和导出的基础知识。</p>
<h3 id="导出数据"><a href="#导出数据" class="headerlink" title="导出数据"></a>导出数据</h3><p>数据导出是表单视图中的标准功能。要使用该功能， 需要勾选左侧的复选框来选择需导出的行，然后在上方的 Action 菜单中点击 Export 选项。首先我们要在图书应用中添加一些带有出版商和作者的图书。下例中我使用此前添加的书籍。</p>
<p>我们还需要安装 Contacts 应用，这样可以看到 Partner 的列表视图，可从该处导出记录。注意其默认视图为带有名片的看板视图，需要先切换为列表视图：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/962764030a2a4405b9bbfe3a1e8042a2~tplv-k3u1fbpfcp-zoom-1.image" alt="Odoo 12 Contacts导出"></p>
<p>可通过勾选列头的筛选框来选择所有匹配当前搜索条件的记录。</p>
<blockquote>
<p><strong>ℹ️Odoo 9中的修改</strong><br>在 Odoo 更早的版本中，只有屏幕上显示（当页）的记录能被导出。Odoo 9做出了修改，勾选列头的复选框可导出当前过滤的所有匹配记录，而不仅仅是当前显示。这对导出屏幕上无法展示全的大量记录非常有用。</p>
</blockquote>
<p>点击 Export 选项进入Export Data 对话表单，可选择导出方式。我们比较关注的是导出方式可以让我们通过手动或插件模块来导入该文件：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d9255180f05142cb81e08bdd844e6a4f~tplv-k3u1fbpfcp-zoom-1.image" alt="Odoo 12导出数据对话框"></p>
<p> </p>
<p>在对话表单最上方，有两个选项：</p>
<ul>
<li>What do you want do do?（老版本中为Export type），选择Import-Compatible Export选项，这样导出数据在以后导入时格式更友好。</li>
<li>Export formats：可选择CSV或Excel，我们将选择 CSV 格式来更好理解原始导出格式，在很多表单应用中都能被读取。</li>
</ul>
<p>下一步选取要导出的列，本例中简化操作，仅选择External ID和Name。如果我们点击Export To File按钮，就会下载带有导出数据的文件。最终的 CSV 内容类似：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&quot;id&quot;,&quot;name&quot;</span><br><span class="line">&quot;__export__.res_partner_45_5b73e404&quot;,&quot;Kaiwan N Billimoria&quot;</span><br><span class="line">&quot;__export__.res_partner_42_49816b0d&quot;,&quot;Packt&quot;</span><br><span class="line">&quot;__export__.res_partner_44_9e374a59&quot;,&quot;Russ McKendrick&quot;</span><br><span class="line">&quot;__export__.res_partner_43_e38db1b7&quot;,&quot;Scott Gallagher&quot;</span><br></pre></td></tr></table></figure>

<p><strong>补充：</strong> 伸手党请注意这里及后续的 ID 字段都与导出的系统有关，不应直接使用</p>
<p>第一行中包含列名，导入时会使用它们自动匹配目录列。导出内容有两列：</p>
<ul>
<li>id：为每条记录分配的外部 ID，如果不存在，会在模块名处使用__export__ 作为前缀自动生成一条新ID。</li>
<li>name： 联系人&#x2F;Partner 名称</li>
</ul>
<p>带有外部 ID 使我们可以编辑导出数据并重新导入来把修改更新到记录中。</p>
<blockquote>
<p><strong>小贴士：</strong> 由于会自动生成记录 id，导出或导入功能可用于批量编辑 Odoo 数据：将数据导出至 CSV，使用表单软件批量编辑数据，再导入 Odoo。</p>
</blockquote>
<h3 id="导入数据"><a href="#导入数据" class="headerlink" title="导入数据"></a>导入数据</h3><p>首先应确认开启了导入功能，默认是开启的。如果没有，进入Settings &gt; General Settings，在 Users 版块下勾选Import &amp; Export选项即可。启用该选项后，列表视图上方 Create 按钮旁就会显示一个 Import按钮。</p>
<blockquote>
<p><strong>注意：</strong> Import &amp; Export 设置安装base_import模块，该模块用于提供这一功能。</p>
</blockquote>
<p>下面我们尝试批量编辑Contact或Partner数据。使用电子表单或文本编辑器打开CSV并修改几个值。将 id 栏留空即可新增行。前文已经提到第一列 id 作为每行的唯一标识符，这让已有记录可以被更新，而不会因重新导入数据重复创建。我们在导出表中编辑任意字段在导入时对应记录就会被更新。</p>
<p>对于要加入 CSV 文件的新行，我们可以自己添加外部标识符或将 id 列留空。两种方式都会创建新的记录。作为示例，我们添加一行id 留空、name 为Phillip K. Dick，来在数据库中新建这一记录。在 CSV文件中进行保存，点击 Import(Create 按钮旁)，然后点击 Load File 按钮选择磁盘中 CSV 的路径就出会出现如下导入助手：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d6306ec230a244928f37b883d02d300a~tplv-k3u1fbpfcp-zoom-1.image" alt="Odoo 12图书项目 Test Import"></p>
<p>点击右上角的Test Import按钮，检查数据正确性。由于导入的文件是在 Odoo 中导出文件基础上修改的，正常会有效并且各列会自动与数据库中对应字段匹配。因编辑所使用的软件各异，有可能需对分隔符和编码进行处理。现在可以点击 Import 按钮，修改和新建记录就会被载入到 Odoo 中。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7488f94a50054a76a3ed88ad67a0051e~tplv-k3u1fbpfcp-zoom-1.image" alt="Odoo 12 CSV 新增数据"></p>
<h3 id="CSV-数据文件中的关联记录"><a href="#CSV-数据文件中的关联记录" class="headerlink" title="CSV 数据文件中的关联记录"></a>CSV 数据文件中的关联记录</h3><p>前面的示例非常简单，一旦我们开使用关联多张表的关联字段时，数据文件就会变得更为复杂。我们处理过图书中的 Partner 记录，下面就看一下如何在图书 CSV 文件中表示对这些 Partner 的引用。具体来说，有一个出版商(publisher_id字段)的many-to-one(或外键)关联，以及一个作者(author_ids字段)的many-to-many关联。</p>
<p>CSV 文件的表头行中关联列应在名称后添加一个&#x2F;id。它将使用外部标识符来引用关联记录。本例中，我们将在publisher_id&#x2F;id字段中加载图书出版商，使用关联 Partner 的外部 ID 作为其值。</p>
<blockquote>
<p><strong>注意：</strong> 可使用&#x2F;.id来进行替代来使用数据库中的真实 ID（自动分配的数字 id），但极少使用到。除非有特别原因，否则请使用外部 ID 而非数据库ID。同时要记住数据库 ID 针对具体的数据库，所以如果导入到非原始数据库中这种操作大多数情况下都会失败。</p>
</blockquote>
<p>CSV 数据文件中也可导入many-to-many字段，这和添加带双引号并由逗号分隔的外部 ID 列表一样简单。例如，要载入图书作者，将需要一个author_ids&#x2F;id列，并使用一个关联 Partner外部 ID 的逗号分隔列表作为其值：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">id, name, author_ids/id</span><br><span class="line">book_docker, &quot;Mastering Docker - Third Edition&quot;,&quot;__export__.res_partner_44_767f4606,__export__.res_partner_43_b97c9264&quot;</span><br></pre></td></tr></table></figure>

<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/774cee73213444f5824e5f2edd91ed4f~tplv-k3u1fbpfcp-zoom-1.image" alt="Odoo 12 CSV 导入 Many2many"></p>
<p>One-to-many 字段通常是表头和行或父子关系，对于这类关系有特别的支持方式：对于同一条父记录可以有多个关联行。此处我们在 Partner 模型中有一个 one-to-many字段的例子：公司可带有多个联系人。如果从 Partner 模型中导出数据并包含Contacts&#x2F;Name 字段，就可以看到要导入此类型数据的格式(Contacts 中选择Azure Interior：默认应为第一条，并执行前述的导出步骤)：</p>
<table>
<thead>
<tr>
<th>id</th>
<th>name</th>
<th>child_ids&#x2F;id</th>
<th>child_ids&#x2F;name</th>
</tr>
</thead>
<tbody><tr>
<td>base.res_partner_12</td>
<td>Azure Interior</td>
<td>base.res_partner_address_15</td>
<td>Brandon Freeman</td>
</tr>
<tr>
<td></td>
<td></td>
<td>base.res_partner_address_28</td>
<td>Colleen Diaz</td>
</tr>
<tr>
<td></td>
<td></td>
<td>base.res_partner_address_16</td>
<td>Nicole Ford</td>
</tr>
</tbody></table>
<h2 id=""><a href="#" class="headerlink" title=""></a><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ff6583bafd784f14bcaccd26fbc5c551~tplv-k3u1fbpfcp-zoom-1.image" alt="Odoo 12 Partner 模型导出"></h2><p>id和 name 列为父记录的，child_ids两列为子记录的。注意第一行记录以下父记录部分留空。上表中CSV 文件形式显示为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&quot;id&quot;,&quot;name&quot;,&quot;child_ids/id&quot;,&quot;child_ids/name&quot;</span><br><span class="line">&quot;base.res_partner_12&quot;,&quot;Azure Interior&quot;,&quot;base.res_partner_address_15&quot;,&quot;Brandon Freeman&quot;</span><br><span class="line">&quot;&quot;,&quot;&quot;,&quot;base.res_partner_address_28&quot;,&quot;Colleen Diaz&quot;</span><br><span class="line">&quot;&quot;,&quot;&quot;,&quot;base.res_partner_address_16&quot;,&quot;Nicole Ford&quot;</span><br></pre></td></tr></table></figure>

<p>可以看到id和name这两列第一行有值，后两行都为空。其中的父记录为联系人的公司信息。另两行的前缀都是child_ids&#x2F;并且在三行中都有数据。这些是父公司的联系人信息。第一行包含公司和第一个联系人，其余行仅包含联系人这一子信息。</p>
<h2 id="添加模块数据"><a href="#添加模块数据" class="headerlink" title="添加模块数据"></a>添加模块数据</h2><p>模块使用数据文件来加载默认数据、演示数据、用户界面定义和其它需存入数据库的配置。可以选择使用 CSV 或 XML 文件。</p>
<blockquote>
<p><strong>ℹ️Odoo 12中的修改</strong><br>Odoo 11及之前版本支持YAML格式文件，但在 Odoo 12移除了相关支持。相关使用示例可参考 Odoo 11官方模块l10n_be，更多YAML格式相关信息，可访问<a target="_blank" rel="noopener" href="http://yaml.org/%E3%80%82">http://yaml.org/。</a></p>
</blockquote>
<p>模块所使用的 CSV 和我们前述使用导入功能时用的文件是一样的。在模块中使用这些文件时，文件名须与要导入数据的模型名一致。例如，导入library.book模型的 CSV 数据文件名应为library.book.csv。CSV 数据文件经常用作导入ir.model.access模型来获取权限定义，通常放在security&#x2F;子目录下并命名为ir.model.access.csv。</p>
<h3 id="演示数据"><a href="#演示数据" class="headerlink" title="演示数据"></a>演示数据</h3><p>Odoo插件模块可安装演示数据，推荐支持该安装。为模块提示使用示例和测试用的数据集会非常有用。模块的演示数据通过__manifest__.py文件中的 demo 属性来声明。和 data 属性一样，后接一个包含模块相对路径的文件名列表。我们应为library.book模块添加一些演示数据，一个简易方式是从安装了模块的开发数据库中导出数据。</p>
<p>按惯例数据文件放在data&#x2F;子目录下，应以data&#x2F;library.book.csv保存在library_app模块下。因这个数据为模块所有，应在导出的数据中将标识符的前缀__export__去除。</p>
<p>例如res.partner.csv文件可能长这样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">id,name</span><br><span class="line">res_partner_alexandre,&quot;Alexandre Fayolle&quot;</span><br><span class="line">res_partner_daniel,&quot;Daniel Reis&quot;</span><br><span class="line">res_partner_holger,&quot;Holger Brunn&quot;</span><br><span class="line">res_partner_packt,&quot;Packt Publishing&quot;</span><br></pre></td></tr></table></figure>

<p>那么图书演示数据文件library.book.csv就应该是这样的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&quot;id&quot;,&quot;name&quot;,&quot;date_published&quot;,&quot;publisher_id/id&quot;,&quot;author_ids/id&quot;</span><br><span class="line">library_book_ode11,&quot;Odoo Development Essentials 11&quot;,&quot;2018-03-01&quot;,res_partner_packt,res_partner_daniel</span><br><span class="line">library_book_odc11,&quot;Odoo 11 Development Cookbook&quot;,&quot;2018-01-01&quot;,res_partner_packt,&quot;res_partner_alexandre,res_partner</span><br><span class="line">_holger&quot;</span><br></pre></td></tr></table></figure>

<p>注意文件中同一条数据因显示原因可能在不同行中，但实际是不能换行的。还应记得在__manifest__.py的 demo 属性中声明数据文件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x27;demo&#x27;: [</span><br><span class="line"> &#x27;data/res.partner.csv&#x27;,</span><br><span class="line"> &#x27;data/library.book.csv&#x27;,</span><br><span class="line">],</span><br></pre></td></tr></table></figure>

<p>文件会以声明的顺序来加载，这个很重要，因为文件可能会因为未被安装而无法引用其记录。只要启用了安装演示数据，下次更新时，这些内容就会被导入。</p>
<blockquote>
<p><strong>ℹ️</strong>数据文件会在模块升级时重新导入，但演示文件则并非如此，它们仅在安装时导入。</p>
</blockquote>
<p>当然 XML 文件也可用于加载或初始化数据，还可使用普通 CSV 文件所不具备的功能。</p>
<h2 id="使用-XML-数据文件"><a href="#使用-XML-数据文件" class="headerlink" title="使用 XML 数据文件"></a>使用 XML 数据文件</h2><p>CSV 文件是一种展示数据方便简洁的格式，但 XML 文件更为强大，可在加载过程中提供更多的控制。比如，其文件名无需与所导入到的模型名称一致。因为XML格式通过文件内的XML元素可以提供更丰富的信息、更多的内容。</p>
<p>在前面的文章中我们已经使用过XML数据文件。视图和菜单项这类用户界面组件实际上都是存储在系统模型中的记录。模块中的XML文件是将这些记录加载到实例数据库的方式。我们将在library_app模块中添加一个数据文件data&#x2F;book_demo.xml来作为展示，文件内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot;?&gt;</span><br><span class="line">&lt;odoo noupdate=&quot;1&quot;&gt;</span><br><span class="line">    &lt;!-- Data to load --&gt;</span><br><span class="line">    &lt;record model=&quot;res.partner&quot; id=&quot;res_partner_huxley&quot;&gt;</span><br><span class="line">        &lt;field name=&quot;name&quot;&gt;Aldous Huxley&lt;/field&gt;</span><br><span class="line">    &lt;/record&gt;</span><br><span class="line">    &lt;record model=&quot;library.book&quot; id=&quot;library_book_bnw&quot;&gt;</span><br><span class="line">        &lt;field name=&quot;name&quot;&gt;Brave New World&lt;/field&gt;</span><br><span class="line">        &lt;field name=&quot;author_ids&quot;</span><br><span class="line">                eval=&quot;[(4, ref(&#x27;res_partner_huxley&#x27;))]&quot; /&gt;</span><br><span class="line">        &lt;field name=&quot;date_published&quot;&gt;1932-01-01&lt;/field&gt;</span><br><span class="line">    &lt;/record&gt;</span><br><span class="line">&lt;/odoo&gt;</span><br></pre></td></tr></table></figure>

<p>老规矩，新的数据文件应在__manifest__.py中声明：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">    &#x27;demo&#x27;: [</span><br><span class="line">...</span><br><span class="line">        &#x27;data/book_demo.xml&#x27;,</span><br><span class="line">    ],</span><br></pre></td></tr></table></figure>

<p>类似 CSV 文件，该文件也会将数据加载到图书模型中。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c410cd7e7cab42018513571b5cab4c7b~tplv-k3u1fbpfcp-zoom-1.image" alt="Odoo 12使用 XML 导入数据"></p>
<p>XML文件包含一个外层<odoo>元素，内部可包含多个<record>元素与对应 CSV 数据行。</p>
<blockquote>
<p><strong>ℹ️</strong>数据文件中的外层<odoo>元素在9.0中才引入用于替换此前的<openerp>标签。现在仍支持外层元素内的<data>标签，为可选项。事实上现在<odoo>和<data>是等价的，我们可以在数据文件中使用任意一个作为外层元素。</p>
</blockquote>
<p><record>元素有两个强制属性： model 和作为记录外部标识符的 id，每个字段使用一个<field>标签来进行写入。注意此处字段名内不可使用斜杠标记，如不可使用<field name="publisher_id/id">。应使用 ref 属性来引用外部标识符，一会儿就会讨论到关联 to-many 字段。</p>
<p>你可能注意到在外层元素中使用了noupdate&#x3D;”1”属性。这防止了在模块升级时数据记录的载入，不至于在后续编辑中丢失数据。</p>
<h3 id="noupdate-数据属性"><a href="#noupdate-数据属性" class="headerlink" title="noupdate 数据属性"></a>noupdate 数据属性</h3><p>升级模块时，会重新加载数据并重写模块记录。要谨记这可能意味着在升级模块时会重写任何对模块数据的手动更改。</p>
<blockquote>
<p><strong>小贴士：</strong> 值得注意的是，手动对视图所做的自定义修改会在下一次模块升级时丢失。避免这一问题正确的方法是创建继承视图来引入要做的修改。</p>
</blockquote>
<p>这种重写行为是默认的，但可以修改有些数据仅在安装时导入，后续模块更新时则予以忽略，这正是通过<odoo>或<data>元素中的noupdate&#x3D;”1”来实现的。</p>
<p>这对于需初始化配置且预期需自定义的数据来说非常有用，因为这些手动修改在模块更新时是安全的。例如在记录访问规则中经常使用，可以适应具体的实施需求。</p>
<p>在同一 XML 文件中可以有多个<data>版块。可通过这个来分隔仅需导入一次的数据（noupdate&#x3D;”1”）和需在每次更新时重新导入的数据（noupdate&#x3D;”0”）。noupdate&#x3D;”0”是默认值，所以可以省略不写。注意还必须要有一个外层 XML 元素，就这个例子而言，使用两个<data>标签，并在外层包裹一个<odoo>或<data>元素。</p>
<blockquote>
<p><strong>小贴士：</strong> noupdate属性在开发模块时可能会引起不适，因为会忽略后续修改。一个解决方案是，使用-i 参数重新安装模块而不是使用-u 参数进行更新。命令行中使用-i 参数重新安装会忽略数据记录中的noupdate标记。</p>
</blockquote>
<p>noupdate标记存储在每条记录的外部标识符信息中。可通过 Technical 菜单中的External Identifiers表单手动编辑，勾选Non Updatable 复选框即可。</p>
<blockquote>
<p><strong>ℹ️Odoo 12中的修改</strong><br>点击开发者菜单中的View Metadata时，现在在弹出的对话框中 XML ID 下面还会显示No Update的值。并且在该处可通过点击来修改该标记的值。</p>
</blockquote>
<h3 id="在-XML-中定义记录"><a href="#在-XML-中定义记录" class="headerlink" title="在 XML 中定义记录"></a>在 XML 中定义记录</h3><p>在 XML 文件中，每个<record>元素有两个基本属性：id 和 model，并包含为对应列设置的值。 id 属性对应记录外部标识符，model 对应目标模型。<field>元素有几种分配值的方法，下面一起来看看。</p>
<h3 id="直接为字段设置值"><a href="#直接为字段设置值" class="headerlink" title="直接为字段设置值"></a>直接为字段设置值</h3><p><field>元素的 name 属性标识要写入的字段。写入的值是元素内容：字段开、闭标签之间的文本。对于 date 和datetime，带有返回 date 或 datetime 对象表达式的 eval 属性可进行设置。返回的”YYYY-mm-dd”和”YYYY-mm-dd HH:MM:SS”字符串会进行转化。对于布尔字段，”0” and “False”都会转换成 False，而任意非空值都会转换成 True。</p>
<blockquote>
<p><strong>小贴士：Odoo 10中的修改</strong><br>Odoo 10中改进了从数据文件中读取布尔值 False的方式。在老版本中，包含”0” and “False”在内的非空值都会转换成 True，直至 Odoo 9，布尔值仍需使用 eval 属性进行设置，如 eval&#x3D;”False”。</p>
</blockquote>
<h3 id="通过表达式设置值"><a href="#通过表达式设置值" class="headerlink" title="通过表达式设置值"></a>通过表达式设置值</h3><p>设置字段值更复杂的方式是通过 eval 属性，它会运行 Python 表达式并将结果分配给字段。表达式通过 Python 内置的以及一些其它可创建表达式标识符的上下文求值。</p>
<p>可使用如下 Python 模块来处理日期：time, datetime, timedelta和relativedelta。通过它们可以计算日期值，在演示和测试数据经常会用到，以让日期和模块安装日期较近。关于 Python 模块更多这类知识，请参考<a target="_blank" rel="noopener" href="https://docs.python.org/3/library/datatypes.html">官方文档</a>。</p>
<p>比如，把值设为前一天，可使用如下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;field name=&quot;date_published&quot;</span><br><span class="line">    eval=&quot;(datetime.now() + timedelta(-1))&quot; /&gt;</span><br></pre></td></tr></table></figure>

<p>求值上下文还可使用ref()函数，用于将外部标识符转换为对应的数据库 ID。这可用于为关联字段设置值。比如，可以使用它为publisher_id设置值：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;field name=&quot;publisher_id&quot; eval=&quot;ref(&#x27;res_partner_packt&#x27;)&quot; /&gt;</span><br></pre></td></tr></table></figure>

<h3 id="在-many-to-one-关联字段上设置值"><a href="#在-many-to-one-关联字段上设置值" class="headerlink" title="在 many-to-one 关联字段上设置值"></a>在 many-to-one 关联字段上设置值</h3><p>对于many-to-one关联字段，要写入的是关联记录的数据库 ID。在 XML 文件中，我们一般会知道记录的XML ID，然后就需要把它转换成实际的数据库 ID。</p>
<p>一种方式是像前文那样使用带有 ref()函数的 eval 属性。更简单的替代方式是使用在元素中可用的ref 属性，使用它设置publisher_id many-to-one字段的值，我们可以这么写：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;field name=&quot;publisher_id&quot; ref=&quot;res_partner_packt&quot; /&gt;</span><br></pre></td></tr></table></figure>

<h3 id="在-to-many-关联字段上设置值"><a href="#在-to-many-关联字段上设置值" class="headerlink" title="在 to-many 关联字段上设置值"></a>在 to-many 关联字段上设置值</h3><p>对于one-to-many和many-to-many字段，设置的不是单个 ID，而是一组关联 ID。并且还进行几种操作-我们可能需要将当前的关联记录列表替换成另外一个，或为其添加几次记录，甚至是删除其中的一些记录。</p>
<p>要让to-many字段支持写操作，我们要在 eval 属性中使用一种特殊的语法。我们使用一个元组组成的列表来写入to-many字段。每个元组有三个元素，构成一个写入命令，根据第一个元素中的代码进行对应操作。要重写图书作者列表，要使用如下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;field</span><br><span class="line">    name = &quot;author_ids&quot;</span><br><span class="line">    eval = &quot;[(6, 0,</span><br><span class="line">        [ref(&#x27;res_partner_alexandre&#x27;),</span><br><span class="line">        ref(&#x27;res_partner_holger&#x27;)]</span><br><span class="line">    )]&quot;</span><br><span class="line">/&gt;</span><br></pre></td></tr></table></figure>

<p>要往当前图书作者列表添加关联记录，需要添加如下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;field name=&quot;author_ids&quot;</span><br><span class="line">    eval=&quot;[(4, ref(&#x27;res_partner_daniel&#x27;))]&quot;</span><br><span class="line">/&gt;</span><br></pre></td></tr></table></figure>

<p>上述的例子非常常见。这里仅使用了一个命令，但在外层列中可以串联多条命令。添加(4)和 替换(6)是最常用的命令。在进行添加(4)时，不需要使用最后一个元素，因此在以上代码中省略了。</p>
<p>完整的可用命令如下：</p>
<ul>
<li>(0, _ , {‘field’: value})新建一条记录并将其与之关联</li>
<li>(1, id, {‘field’: value})更新已关联记录的值</li>
<li>(2, id, _)移除关联并删除 id 关联的记录</li>
<li>(3, id, _)移除关联但不删除 id 关联的记录。通常使用它来删除many-to-many字段的关联记录</li>
<li>(4, id, _)关联已存在记录，仅适用于many-to-many字段</li>
<li>(5, _, _)删除所有关联，但不删除关联记录</li>
<li>(6, _, [ids])替换已关联记录列表为此处的列表</li>
</ul>
<p>上述下划线_字符代表非关联值，通常填入 o 或 False。</p>
<blockquote>
<p><strong>小贴士：</strong> 后面的非关联值可以放心地省略掉，如(4, id, _) 可使用(4, id)</p>
</blockquote>
<h3 id="常用模型的简写"><a href="#常用模型的简写" class="headerlink" title="常用模型的简写"></a>常用模型的简写</h3><p>如果回到第三章 <a target="_blank" rel="noopener" href="https://alanhou.org/odoo12-first-application/">Odoo 12 开发之创建第一个 Odoo 应用</a>，我们在 XML 中还发现<record>之外的元素，如<act_window>和<menuitem>。这些是常用模型的简写方式，是比常用的<record>更为简练的符号。它们用于向 base 模型加载数据、组成用户界面，在第十章 <a target="_blank" rel="noopener" href="https://alanhou.org/odoo12-backend-views/">Odoo 12开发之后台视图 - 设计用户界面</a>会作更详细的探讨。</p>
<p>为便于查看，以下是可用的简写元素以及加载数据的对应模型：</p>
<ul>
<li><act_window>是窗口操作模型ir.actions.act_window</li>
<li><menuitem>是菜单项模型ir.ui.menu</li>
<li><report>是报表操作模型ir.actions.report.xml</li>
<li><template>是存储在ir.ui.view模型中的 QWeb 模板</li>
</ul>
<blockquote>
<p><strong>ℹ️Odoo 11中的修改</strong><br><url>标签已被淘汰并删除。此前的版本中它用作为 URL 操作模型ir.actions.act_url加载记录。</p>
</blockquote>
<p>应当注意在用于修改已有记录时，简写元素会覆盖所有字段。这与仅写入所提供字段的<record>基础元素不同。因此在需修改用户界面元素指定字段时，应使用<record>元素。</p>
<h2 id="XML-文件中的其它操作"><a href="#XML-文件中的其它操作" class="headerlink" title="XML 文件中的其它操作"></a>XML 文件中的其它操作</h2><p>截至目前我们了解了如何使用 XML 文件添加和更新数据。但也可以通过 XML 文件删除数据以及执行指定模型方法。对更复杂的数据场景会非常有用。</p>
<h3 id="删除记录"><a href="#删除记录" class="headerlink" title="删除记录"></a>删除记录</h3><p>我们可以使用<delete>元素删除数据记录，使用 ID 或搜索域来定位要删除的记录。例如，使用搜索域查找记录并删除：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;delete</span><br><span class="line">    model=&quot;res.partner&quot;</span><br><span class="line">    search=&quot;[(&#x27;id&#x27;,&#x27;=&#x27;,ref(&#x27;library_app.res_partner_daniel&#x27;))]&quot;</span><br><span class="line">/&gt;</span><br></pre></td></tr></table></figure>

<p>如果知道要删除记录的具体 ID，可使用 id 属性。上例还可以写成这样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;delete model=&quot;res.partner&quot; id=&quot;library_app.res_partner_daniel&quot; /&gt;</span><br></pre></td></tr></table></figure>

<h3 id="调用模型方法"><a href="#调用模型方法" class="headerlink" title="调用模型方法"></a>调用模型方法</h3><p>XML 文件还可以通过<function>元素在加载过程中执行任意方法，可用于设定演示和测试数据。比如 Odoo 捆绑的 Notes 应用，使用它来设定演示数据：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;data noupdate=&quot;1&quot;&gt;</span><br><span class="line">&lt;function</span><br><span class="line">    model=&quot;res.users&quot;</span><br><span class="line">    name=&quot;_init_data_user_note_stages&quot;</span><br><span class="line">    eval=&quot;[]&quot; /&gt;</span><br><span class="line">&lt;/data&gt;</span><br></pre></td></tr></table></figure>

<p>这会调用res.users模型中的_init_data_user_note_stages方法，不传任何参数。由参数列表eval传递，此处为空列表。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文中我们学习了如何在文件文中展示数据。可用作手动向 Odoo 导入数据，或放在插件模块中作为默认或演示数据。通过学习我们可以通过网页界面导出并导入 CSV 数据文件了，以及通过外部 ID 来检测并更新数据库中已有的记录。也可用作批量编辑数据，只需编辑导出的 CSV 文件再重新导入即可。</p>
<p>我们还详细学习了 XML 数据文件的结构以及所提供功能。不仅可以为字段设置值，还可以执行删除记录和调用方法一类的操作。</p>
<p>下一篇文章中，我们将集中学习如何使用记录来与模型中所含数据协作。这些工具可供我们实现应用的业务逻辑和规则。</p>
<p>☞☞☞第六章 <a target="_blank" rel="noopener" href="https://alanhou.org/odoo12-structuring-data/">Odoo 12开发之模型 - 结构化应用数据</a></p>
<h2 id="学霸专区"><a href="#学霸专区" class="headerlink" title="学霸专区"></a>学霸专区</h2><ol>
<li><p>XML ID 与外部 ID 的区别是什么？</p>
</li>
<li><p>插件模块中可使用什么类型的数据文件？</p>
</li>
<li><p>以下 XML 片段有什么问题？  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;field name=&quot;user_id&quot;&gt;[(4, 0, [ref(base.user_demo)])]&lt;/field&gt;?</span><br></pre></td></tr></table></figure>
</li>
<li><p>一个插件模块中的数据文件是否可以覆盖另一个模块中创建的记录？</p>
</li>
<li><p>插件模块升级时，是否所有数据记录都会被重写为模块默认值？</p>
</li>
</ol>
<h2 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h2><p>Odoo <a target="_blank" rel="noopener" href="https://www.odoo.com/documentation/12.0/reference/data.html">官方文档</a>中提供了有关数据文件的更多资料。</p>
<p>本文首发地址：<a target="_blank" rel="noopener" href="https://alanhou.org/developer-mode-odoo12/">Alan Hou 的个人博客</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://alanhou.github.io/2019/01/08/odoo-essentials-12-chapter4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Alan Hou">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Alan Hou的个人博客">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Alan Hou的个人博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2019/01/08/odoo-essentials-12-chapter4/" class="post-title-link" itemprop="url">第四章 Odoo 12 开发之模块继承</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2019-01-08 00:00:00" itemprop="dateCreated datePublished" datetime="2019-01-08T00:00:00+08:00">2019-01-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2023-02-03 13:37:20" itemprop="dateModified" datetime="2023-02-03T13:37:20+08:00">2023-02-03</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>本文为<a target="_blank" rel="noopener" href="https://alanhou.org/odoo-12-development/">最好用的免费ERP系统Odoo 12开发手册</a>系列文章第四篇。</p>
<p>Odoo 的一个强大功能是无需直接修改底层对象就可以添加功能。这是通过其继承机制来实现的，采取在已有对象之上修改层来完成。这种修改可以在不同层上进行-模型层、视图层和业务逻辑层。我们创建新的模块来做出所需修改而无需在原有模块中直接修改。</p>
<p><a target="_blank" rel="noopener" href="https://alanhou.org/odoo12-first-application/">上一篇文章</a>中我们从零开始创建了一个新应用，本文中我们学习如何通过继承已有的核心应用或第三方模块来创建新的模块。实现以上本文将主要涵盖：</p>
<ul>
<li>原模型扩展，为已有模型添加功能</li>
<li>修改数据记录来继承视图，添加功能或修改数据来修改其它模块创建的数据记录</li>
<li>其它模型继承机制，如代理继承和 mixin 类</li>
<li>继承 Python 方法来为应用业务逻辑添加功能</li>
<li>继承 Web 控制器和模板来为网页添加功能</li>
</ul>
<h2 id="开发准备"><a href="#开发准备" class="headerlink" title="开发准备"></a>开发准备</h2><p>本文要求可通过命令行来启动 Odoo 服务。代码将在第三章 <a target="_blank" rel="noopener" href="https://alanhou.org/odoo12-first-application/">Odoo 12 开发之创建第一个 Odoo 应用</a>的基础上进行修改。通过该文的学习现在我们已经有了library_app模块。本系列文章代码请参见 <a target="_blank" rel="noopener" href="https://github.com/alanhou/odoo12-development">GitHub 仓库</a>。</p>
<h2 id="学习项目-继承图书馆应用"><a href="#学习项目-继承图书馆应用" class="headerlink" title="学习项目-继承图书馆应用"></a>学习项目-继承图书馆应用</h2><p>在第三章 <a target="_blank" rel="noopener" href="https://alanhou.org/odoo12-first-application/">Odoo 12 开发之创建第一个 Odoo 应用</a>中我们创建了一个图书应用的初始模块，可供查看图书目录。现在我们要创建一个library_member模块，来对图书应用进行扩展以让图书会员可以借书。它继承 Book 模型，并添加一个图书是否可借的标记。该信息将在图书表单和图书目录页显示。</p>
<p>应添加图书会员主数据模型Member，类似 Partner 来存储个人数据，如姓名、地址和 email，还有一些特殊字段，如图书会员卡号。最有效的方案是代理继承，自动创建图书会员记录并包含关联 Partner 记录。该方案使得所有的Partner 字段在 Member 中可用，没有任何数据结构上的重复。</p>
<p>我们还要在借书表单中为会员提供消息和社交功能，包括计划活动组件来实现更好地协作。我们还要添加会员从图书馆中借书的功能，但暂不涉及。以下是当前所要修改内容的总结：</p>
<ul>
<li><p>图书</p>
<ul>
<li>添加一个Is Available? 字段。现在通过手动管理，以后会自动化</li>
<li>扩展 ISBN 验证逻辑来同时支持10位数的ISBN</li>
<li>扩展图书目录页来分辨不可借阅图书并允许用户过滤出可借图书</li>
</ul>
</li>
<li><p>会员</p>
<ul>
<li>添加一个新模型来存储姓名、卡号和 Email、地址一类的联系信息</li>
<li>添加社交讨论和计划活动功能</li>
</ul>
</li>
</ul>
<p>首先在library_app同级目录创建一个library_member目录来作为扩展模块，并在其中添加两个文件，一个__init__.py空文件和一个包含如下内容的__manifest__.py文件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &#x27;name&#x27;: &#x27;Library Members&#x27;,</span><br><span class="line">    &#x27;description&#x27;: &#x27;Manage people who will be able to borrow books.&#x27;,</span><br><span class="line">    &#x27;author&#x27;: &#x27;Alan Hou&#x27;,</span><br><span class="line">    &#x27;depends&#x27;: [&#x27;library_app&#x27;],</span><br><span class="line">    &#x27;application&#x27;: False,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="原模型继承"><a href="#原模型继承" class="headerlink" title="原模型继承"></a>原模型继承</h2><p>第一步我们来为Book模型添加is_available布尔型字段。这里使用经典的 in-place 模型继承。该字段值可通过图书借出和归还记录自动计算，但现在我们先使用普通字段。要继承已有模型，需要在 Python 类中添加一个_inherit 属性来标明所继承的模型。新类继承父 Odoo 模型的所有功能，仅需在其中声明要做的修改。在任何地方使用该模型修改都可用，可以认为这类继承是对已有模型的引用并在原处做了一些修改。</p>
<h3 id="为模型添加字段"><a href="#为模型添加字段" class="headerlink" title="为模型添加字段"></a>为模型添加字段</h3><p>通过 Python 类来新建模型，继承模型同样是通过 Python 以及 Odoo 自有的继承机制，即_inherit 类属性。该属性标明所继承的模型。新的类继承父 Odoo 模型的所有功能，仅需声明要做修改的部分。编码指南推荐为每个模型创建一个 Python 文件，因此我们添加library_member&#x2F;models&#x2F;library_book.py文件来继承原模型，首先创建__init__.py文件来导入该文件：</p>
<p>1、添加library_member&#x2F;<strong>init</strong>.py文件来导入 models 子文件夹</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">from . import models</span><br></pre></td></tr></table></figure>

<p>2、添加library_member&#x2F;models&#x2F;<strong>init</strong>.py文件子文件夹中的代码文件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">from . import library_book</span><br></pre></td></tr></table></figure>

<p>3、创建library_member&#x2F;models&#x2F;library_book.py文件来继承library.book模型：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">from odoo import fields, models</span><br><span class="line"></span><br><span class="line">class Book(models.Model):</span><br><span class="line">    _inherit = &#x27;library.book&#x27;</span><br><span class="line">    is_available = fields.Boolean(&#x27;Is Available?&#x27;)</span><br></pre></td></tr></table></figure>

<p>使用_inherit类属性来声明所继承模型。注意我们并没有使用到其它类属性，甚至是_name 也没使用。除非想要做出修改，否则不需要使用这些属性。</p>
<blockquote>
<p><strong>ℹ️</strong>_name是模型标识符，如果修改会发生什么呢？其实你可以修改，这时它会创建所继承模型的拷贝，成为一个新模型。这叫作原型继承，本文后面会讨论。</p>
</blockquote>
<p>可以把这个想成是对模型定义的一个引用，在原处做了一个修改。可以添加字段、修改已有字段、修改模型类属性甚至是包含业务逻辑的方法。要在数据表中添加新的模型字段需要安装该模块。如果一切顺利，通过Settings &gt; Technical &gt; Database Structure &gt; Models菜单查看library.book模型即可看到该字段。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~/odoo-dev/odoo/odoo-bin -d dev12 -i library_member</span><br></pre></td></tr></table></figure>

<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/832a3f69605c4cb781686887239cee40~tplv-k3u1fbpfcp-zoom-1.image" alt="Odoo 12图书项目is_available字段添加"></p>
<h3 id="修改已有字段"><a href="#修改已有字段" class="headerlink" title="修改已有字段"></a>修改已有字段</h3><p>通过上面部分可以看到向已有模型添加新字段非常简单。有时还要对已有字段进行修改，也非常简单。在继承模型时，可对已有字段叠加修改，也就是说仅需定义要增加或修改的字段属性。</p>
<p>我们将对原来创建的library_app模块的 Book模型做两处简单修改：</p>
<ul>
<li>为isbn字段添加一条提示，说明同时支持10位数的 ISBN（稍后会实现该功能）</li>
<li>为publisher_id字段添加数据库索引，以提升搜索效率</li>
</ul>
<p>编辑library_member&#x2F;models&#x2F;library_book.py文件，并在library.book 模型中添加如下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class Book(models.Model):</span><br><span class="line">...</span><br><span class="line">    isbn = fields.Char(help=&quot;Use a valid ISBN-13 or ISBN-10.&quot;)</span><br><span class="line">    publisher_id = fields.Many2one(index=True)</span><br></pre></td></tr></table></figure>

<p>这会对字段进行指定属性修改，未涉及的属性不会被修改。升级模块，进入图书表单，将鼠标悬停在 ISBN 字段上，就可以看到所添加的提示信息了。index&#x3D;True这一修改不太容易发现，通过Settings &gt; Technical &gt; Database Structure &gt; Models菜单下的字段定义中可进行查看。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/eb46f0e63f2643b4aa15066b521d04f1~tplv-k3u1fbpfcp-zoom-1.image" alt="Odoo 12图书项目 ISBN 提示"></p>
<h2 id="修改视图和数据"><a href="#修改视图和数据" class="headerlink" title="修改视图和数据"></a>修改视图和数据</h2><p>模块中视图和其它数据构件也可通过继承来修改。就视图而言，通常需要添加功能。视图的展示结构在 arch 字段中使用 XML定义。这一 XML 数据可通过定位到所需修改的地方来进行继承，然后声明需执行的操作，如在该处添加 XML 元素。对于剩余的数据元素，它们代表写入数据库中的记录，继承模型可通过写操作来修改它们的值。</p>
<h3 id="继承视图"><a href="#继承视图" class="headerlink" title="继承视图"></a>继承视图</h3><p>表单、列表和搜索视图通过arch XML结构定义。要继承视图，就要一种修改 XML 的方式，也即定位 XML 元素然后对该处进行修改。视图继承的 XML 记录和普通视图中相似，多一个 inherit_id属性来引用所要继承的视图。下面我们来继承图书视图并添加is_available字段。</p>
<p>首先要查找待继承的视图的XML ID，通过Settings &gt; Technical &gt; User Interface &gt; Views菜单来查看。图书表单的XML ID是library_app.view_form_book。然后还要找到要插入修改的XML元素，我们在 ISBN 字段之后添加Is Available?通常通过name 属性定位元素，此处为<field name="isbn" />。</p>
<p>我们添加views&#x2F;book_view.xml文件来继承 Partner 视图，加入如下内容：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot;?&gt;</span><br><span class="line">&lt;odoo&gt;</span><br><span class="line">    &lt;record id=&quot;view_form_book_extend&quot; model=&quot;ir.ui.view&quot;&gt;</span><br><span class="line">        &lt;field name=&quot;name&quot;&gt;Book: add Is Available? field&lt;/field&gt;</span><br><span class="line">        &lt;field name=&quot;model&quot;&gt;library.book&lt;/field&gt;</span><br><span class="line">        &lt;field name=&quot;inherit_id&quot; ref=&quot;library_app.view_form_book&quot; /&gt;</span><br><span class="line">        &lt;field name=&quot;arch&quot; type=&quot;xml&quot;&gt;</span><br><span class="line">            &lt;field name=&quot;isbn&quot; position=&quot;after&quot;&gt;</span><br><span class="line">                &lt;field name=&quot;is_available&quot; /&gt;</span><br><span class="line">            &lt;/field&gt;</span><br><span class="line">        &lt;/field&gt;</span><br><span class="line">    &lt;/record&gt;</span><br><span class="line">&lt;/odoo&gt;</span><br></pre></td></tr></table></figure>

<p>以上代码中，我们高亮显示了继承相关的元素。inherit_id记录字段通过 ref 属性指向继承视图的外部标识符，我们将在第五章 <a target="_blank" rel="noopener" href="https://alanhou.org/odoo12-import-export-data/">Odoo 12开发之导入、导出以及模块数据</a>讨论外部标识符详情。视图使用 XML 定义并存储在结构字段 arch 中。要继承一个视图，先定位要扩展的节点，然后执行要做的操作，如添加 XML 元素。</p>
<p>定位节点的最简单方法是使用唯一标识属性，通常是 name。然后添加定位属性，声明要做的修改。本例中继承节点是name&#x3D;”isbn”元素，修改是在选定元素后加一段 XML：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;field name=&quot;isbn&quot; position=&quot;after&quot;&gt;</span><br><span class="line">    &lt;!-- 此处添加修改内容 --&gt;</span><br><span class="line">&lt;/field&gt;</span><br></pre></td></tr></table></figure>

<p>除string 属性外的任意 XML 元素和属性可作为继承节点，字符串属性会被翻译成用户所使用的语言，因此不能作为节点选择器。</p>
<blockquote>
<p><strong>ℹ️</strong>在9.0以前，string 属性(显示标签文本）也可作为继承定位符。在9.0之后则不再允许。这一限制主要源自这些字符串的语言翻译机制。</p>
</blockquote>
<p>一旦 XML 节点被选为继承点，需要指明要执行的继承操作。这通过 position 属性实现：</p>
<ul>
<li>inside（默认值）：在所选节点内添加内容，这一节点应是<group>或<page>一类的容器</li>
<li>after：在选定节点之后向父节点添加内容</li>
<li>before：在选定节点之前向父节点添加内容</li>
<li>replace：替换所选节点。若使用空元素则会删除该元素。Odoo 之后还允许使用其它标记来包裹元素，通过在内容中使用$0来表示被替换的元素。</li>
<li>attributes：修改匹配元素属性值。内容中应包含带有一个或多个&lt;attribute **name&#x3D;”attr-name”** &gt;<strong>value</strong></attribute>元素。如<attribute name="invisible">True</attribute>，若不带内容，如<attribute name="invisible" />则 attribute 会从所选元素中删除。</li>
</ul>
<blockquote>
<p><strong>小贴士：</strong> 通过position&#x3D;”replace”可删除 XML 元素，但应避免这么做。这么做会破坏其它依赖所删除节点、将其作为占位符添加元素的模块。一个替代方案是，让该元素不可见。</p>
</blockquote>
<p>除了attributes定位，上述定位符可与带position&#x3D;”move”的子元素合并。效果是将子定位符目标节点移到父定位符目录位置。</p>
<blockquote>
<p><strong>ℹ️Odoo 12中的修改</strong><br>position&#x3D;”move”子定位符是 Odoo 12中新增的，之前的版本中没有</p>
</blockquote>
<p>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;field name=&quot;target_field&quot; position=&quot;after&quot;&gt;</span><br><span class="line">    &lt;field name=&quot;my_field&quot; position=&quot;move&quot;/&gt;</span><br><span class="line">&lt;/field&gt;</span><br></pre></td></tr></table></figure>

<p>其它视图类型，如列表和搜索视图，也有 arch 字段，可以表单视图同样的方式被继承。</p>
<p>在声明文件data 中加入该视图文件并更新模块即可：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/06dd78146786480f907751a672a03b51~tplv-k3u1fbpfcp-zoom-1.image" alt="Odoo 12图书项目添加 is_available"></p>
<h3 id="使用-XPath-选取继承点"><a href="#使用-XPath-选取继承点" class="headerlink" title="使用 XPath 选取继承点"></a>使用 XPath 选取继承点</h3><p>有时可能没有带唯一值的属性来用作 XML 节点选择器。在所选元素没有 name 属性时可能出现这一情况，如<group>、<notebook>或<page>视图元素。另外就是有多个带有相同 name 属性的元素，比如在看板 QWeb 视图中相同字段可能在同一 XML 模板中被多次包含。</p>
<p>在这些情况下我们就需要更高级的方式来定位待扩展 XML 元素。定位 XML 中元素的一种自然方式是 XPath 表达式。以上一篇文章中定义的 Book 表单视图为例，定位<field name="isbn">元素的 XPath 表达式是&#x2F;&#x2F;field[@name]&#x3D;’isbn’。该表达式查找 name 属性等于 isbn 的<field>元素。</p>
<p>前一部分对图书表单视图继承的 XPath 写法是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;xpath expr=&quot;//field[@name=&#x27;isbn&#x27;]&quot; position=&quot;after&quot;&gt;</span><br><span class="line">    &lt;field name=&quot;is_available&quot; /&gt;</span><br><span class="line">&lt;/xpath&gt;</span><br></pre></td></tr></table></figure>

<p>XPath 语法的更多知识请见 <a target="_blank" rel="noopener" href="https://docs.python.org/3/library/xml.etree.elementtree.html#supported-xpath-syntax">Python 官方文档</a>。</p>
<p>如果 XPath 表达式匹配到了多个元素，仅会选取第一个作为扩展目录。所以表达式应越精确越好，使用唯一属性。name 属性最易于确保找到精确元素作为扩展点，因此在创建视图 XML 元素时添加唯一标识符就非常重要。</p>
<h3 id="修改数据"><a href="#修改数据" class="headerlink" title="修改数据"></a>修改数据</h3><p>普通数据记录不同于视图，它没有 XML arch 结构，也不能使用 XPath 来进行扩展。但还是可以通过替换字段值来进行修改。</p>
<p><record id="x" model="y">数据加载元素实际是对 y 模型进行插入或更新操作。若不存在记录 x，则被创建，否则被更新&#x2F;覆盖。其它模块中的记录可通过<module>.<identifier>全局标识符访问，因此可以在我们的模块中重写其它模块中已写入的数据。</p>
<blockquote>
<p><strong>ℹ️</strong>点号是保留符号，用于分隔模块名和对象标识符，所以在标识符名中不要使用点号，而应使用下划线字符。</p>
</blockquote>
<p>举个例子，我们将 User 安全组的名称修改为 Librarian，对应修改library_app.library_group_user记录。添加library_member&#x2F;security&#x2F;library_security.xml并加入如下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;odoo&gt;</span><br><span class="line">    &lt;!-- Modify Group name --&gt;</span><br><span class="line">    &lt;record id=&quot;library_app.library_group_user&quot; model=&quot;res.groups&quot;&gt;</span><br><span class="line">        &lt;field name=&quot;name&quot;&gt;Librarian&lt;/field&gt;</span><br><span class="line">    &lt;/record&gt;</span><br><span class="line">&lt;/odoo&gt;</span><br></pre></td></tr></table></figure>

<p>这里我们使用了一个<record>元素，仅写了 name 字段。可以认为这是对所选字段的一次写操作。</p>
<blockquote>
<p><strong>小贴士：</strong> 使用<record>元素时，可以选择要执行写操作的字段，但对 shortcut 元素则并非如此，如<menuitem>和<act_window>。它们需要提供所有的属性，漏写任何一个都会将对应字段置为空值。但可使用<record>为原本通过 shortcut 元素创建的字段设置值。</p>
</blockquote>
<p>在声明文件data 中加入security&#x2F;library_security.xml并更新模块即可看到效果。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/478b1069edcc4982a766402c1f8a64e1~tplv-k3u1fbpfcp-zoom-1.image" alt="Odoo 12图书项目 Librarian"></p>
<h2 id="其它模型继承机制"><a href="#其它模型继承机制" class="headerlink" title="其它模型继承机制"></a>其它模型继承机制</h2><p>前面我们介绍了模型的基本继承，在官方文档中称为经典继承。这是最常用的继承方式，最容易想到的就是in-place继承。获取模型并对其继承。添加的新功能会自动添加到已有模型中，而不会创建新模型。</p>
<p>可以为_inherit 属性传入多个值来继承多个父模型。大多数情况下这通过 mixin 类完成，mixin类是实现可复用的通用功能。也可以像普通模型那样独立使用，像是一个功能容器，可随时加到其它模型中。</p>
<p>如在使用_inherit 属性的同时还使用了与父模型不同的_name属性，此时会复用所继承并创建一个新的模型，并带有自己的数据表和数据。官方文档称其为原型(prototype)继承。下面我们会拿一个模型，并为其创建一个拷贝。在添加新功能时，只会被加到新模型中，而不会变更原模型。</p>
<p>此外还有代理(delegation)继承，通过_inherits 属性来使用(注意最后有一个 s)。这允许我们创建一个包含和继承已有模型的新模型。新模型创建新记录时，在原模型中也会被创建并使用many-to-one 字段关联。查看新模型的人可以看到所有原模型和新模型中的字段，但在后台两个模型分别处理各自的数据。</p>
<p>下面我们一起来了解详情。</p>
<h3 id="使用原型继承拷贝功能"><a href="#使用原型继承拷贝功能" class="headerlink" title="使用原型继承拷贝功能"></a>使用原型继承拷贝功能</h3><p>前文我们继承模型时使用了_inherit 属性，创建一个类继承library.book 并添加了一些功能。类中没有使用_name属性，不指明即使用library.book。如果设置了不个不同值的_name 属性，会通过从所继承的模型拷贝功能创建新模型。</p>
<p>在实际开发中，这类继承一般通过抽象 mixin 类，很少这样直接继承普通模型，因为这样会创建冗余的数据结构。Odoo 还有一种代理继承机制可避免这类数据结构冗余，所以普通模型通常会使用这种方法来做继承。</p>
<h3 id="使用代理继承内嵌模型"><a href="#使用代理继承内嵌模型" class="headerlink" title="使用代理继承内嵌模型"></a>使用代理继承内嵌模型</h3><p>使用代理继承无需复制数据即可在数据库中复用数据结构，这通过将一个模型嵌入另一个来实现。UML 中这种称作组合(composition)关系：父类无需子类即可存在，而子类必须要有父类才能存在。</p>
<p>比如，对于内核 User模型，每条记录包含一条 Partner 记录，因此包含 Partner 中的所有字段以及User自身的一些字段。</p>
<p>在图书项目中，我们要添加一个图书会员模型。会员有会员卡并通过会员卡借阅读书。我们要记录卡号，还要存储email 和地址这类个人信息。Partner 模型已包含联系和地址信息，所以最好是进行复用，而不去创建重复的数据结构。</p>
<p>为会员模型创建library_member&#x2F;models&#x2F;library_member.py文件并加入如下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">from odoo import fields, models</span><br><span class="line"></span><br><span class="line">class Member(models.Model):</span><br><span class="line">    _name = &#x27;library.member&#x27;</span><br><span class="line">    _description = &#x27;Library Member&#x27;</span><br><span class="line">    card_number = fields.Char()</span><br><span class="line">    partner_id = fields.Many2one(</span><br><span class="line">        &#x27;res.partner&#x27;,</span><br><span class="line">        delegate=True,</span><br><span class="line">        ondelete=&#x27;cascade&#x27;,</span><br><span class="line">        required=True)</span><br></pre></td></tr></table></figure>

<p>使用代理继承，library.member 中嵌入了继承模型res.partner，因此在创建会员记录时，一个关联的 Partner 会自动被创建并通过partner_id字段引用。</p>
<blockquote>
<p><strong>ℹ️Odoo 8中的修改</strong><br>在新的 API 中引入了delegate&#x3D;True字段属性。在那之前，代理继承通过模型属性来定义，类似_inherits &#x3D; {‘res.partner’: ‘partner_id’}。现在仍支持这一写法，官网中还有相应介绍，但delegate&#x3D;True 字段属性可起到相同效果且使用更简单。</p>
</blockquote>
<p>透过代理机制，嵌套模型的所有字段就像父模型字段一样自动可用。本例中，会员卡模型可使用 Partner 中的所有字段，如 name, address和 email，以及会员自身的独有字段，如card_number。在后台中，Partner 字段存储在关联的 Partner 记录，没有重复的数据结构。</p>
<blockquote>
<p><strong>ℹ️</strong>对于模型方法则并非如此，Partner 模型中的方法在 Member 模型中不可使用。</p>
</blockquote>
<p>与原型继承相比，代理继承的好处在于无需跨表重复像地址这样的数据。任何需包含地址的新模型通过代理嵌入了 Partner 模型。如果在 Partner 中修改 address字段，在所有嵌入的模型中可以马上使用。</p>
<blockquote>
<p><strong>小贴士：</strong> 代理继承可通过如下组合来进行替代：</p>
<ul>
<li>父模型中的一个 many-to-one 字段</li>
<li>重载 create()方法自动创建并设置父级记录</li>
<li>父字段中希望暴露的特定字段的关联字段</li>
</ul>
<p>有时这比完整的代理继承更为合适。例如res.company并没有继承res.partner，但使用到了其中好几个字段。</p>
</blockquote>
<p>不要忘记在library_member&#x2F;model&#x2F;<strong>init</strong>.py文件中加入：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">from . import library_book</span><br><span class="line">from . import library_member</span><br></pre></td></tr></table></figure>

<p>要使用我们创建的 Member 模型，还要完成以下步骤：</p>
<ul>
<li>添加安全权限控制列表(ACL)</li>
<li>添加菜单项</li>
<li>添加表单和列表视图</li>
<li>更新manifest文件来声明这些新增数据文件</li>
</ul>
<p>读者可以先尝试自己添加，再来看下面的详细步骤：</p>
<p>要创建安全ACL，创建library_member&#x2F;security&#x2F;ir.model.access.csv文件并加入如下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">id,name,model_id:id,group_id:id,perm_read,perm_write,perm_create,perm_unlink</span><br><span class="line">access_member_user,Member User Access,model_library_member,library_app.library_group_user,1,1,1,0</span><br><span class="line">access_member_manager,Member Manager Access,model_library_member,library_app.library_group_manager,1,1,1,1</span><br></pre></td></tr></table></figure>

<p>要添加菜单项，创建library_member&#x2F;views&#x2F;library_menu.xml文件并加入如下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;odoo&gt;</span><br><span class="line">    &lt;act_window id=&quot;action_library_member&quot;</span><br><span class="line">        name=&quot;Library Members&quot;</span><br><span class="line">        res_model=&quot;library.member&quot;</span><br><span class="line">        view_mode=&quot;tree,form&quot; /&gt;</span><br><span class="line">    &lt;menuitem id=&quot;menu_library_member&quot;</span><br><span class="line">        action=&quot;action_library_member&quot;</span><br><span class="line">        parent=&quot;library_app.menu_library&quot; /&gt;</span><br><span class="line">&lt;/odoo&gt;</span><br></pre></td></tr></table></figure>

<p>要添加视图，创建library_member&#x2F;views&#x2F;member_view.xml文件并加入如下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; ?&gt;</span><br><span class="line">&lt;odoo&gt;</span><br><span class="line">    &lt;record id=&quot;view_form_member&quot; model=&quot;ir.ui.view&quot;&gt;</span><br><span class="line">        &lt;field name=&quot;name&quot;&gt;Library Member Form View&lt;/field&gt;</span><br><span class="line">        &lt;field name=&quot;model&quot;&gt;library.member&lt;/field&gt;</span><br><span class="line">        &lt;field name=&quot;arch&quot; type=&quot;xml&quot;&gt;</span><br><span class="line">            &lt;form&gt;</span><br><span class="line">                &lt;group&gt;</span><br><span class="line">                    &lt;field name=&quot;name&quot; /&gt;</span><br><span class="line">                    &lt;field name=&quot;email&quot; /&gt;</span><br><span class="line">                    &lt;field name=&quot;card_number&quot; /&gt;</span><br><span class="line">                &lt;/group&gt;</span><br><span class="line">            &lt;/form&gt;</span><br><span class="line">        &lt;/field&gt;</span><br><span class="line">    &lt;/record&gt;</span><br><span class="line">    &lt;record id=&quot;view_tree_member&quot; model=&quot;ir.ui.view&quot;&gt;</span><br><span class="line">        &lt;field name=&quot;name&quot;&gt;Library Member List View&lt;/field&gt;</span><br><span class="line">        &lt;field name=&quot;model&quot;&gt;library.member&lt;/field&gt;</span><br><span class="line">        &lt;field name=&quot;arch&quot; type=&quot;xml&quot;&gt;</span><br><span class="line">            &lt;tree&gt;</span><br><span class="line">                &lt;field name=&quot;name&quot; /&gt;</span><br><span class="line">                &lt;field name=&quot;card_number&quot; /&gt;</span><br><span class="line">            &lt;/tree&gt;</span><br><span class="line">        &lt;/field&gt;</span><br><span class="line">    &lt;/record&gt;</span><br><span class="line">&lt;/odoo&gt;</span><br></pre></td></tr></table></figure>

<p>最后，编辑manifest文件来声明这三个新文件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">    &#x27;data&#x27;:[</span><br><span class="line">...</span><br><span class="line">        &#x27;security/ir.model.access.csv&#x27;,</span><br><span class="line">        &#x27;views/library_menu.xml&#x27;,</span><br><span class="line">        &#x27;views/member_view.xml&#x27;,</span><br><span class="line">    ]</span><br></pre></td></tr></table></figure>

<p>如果编写正确，在进行模型更新后即可使用新的图书会员模型了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~/odoo-dev/odoo/odoo-bin -d dev12 -u library_member</span><br></pre></td></tr></table></figure>

<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/35594420b3a34db0aba1d527906db0b8~tplv-k3u1fbpfcp-zoom-1.image" alt="Odoo 12图书项目图书会员"></p>
<h3 id="使用-mixin类继承模型"><a href="#使用-mixin类继承模型" class="headerlink" title="使用 mixin类继承模型"></a>使用 mixin类继承模型</h3><p>原型继承主要用于支持 mixin 类。mixin 是基于 models.Abstract 的抽象的模型（而不是models.Model），它在数据库中没有实际的体现，而是提供功能供其它模型复用（混合 mixed in）。Odoo 插件提供多种 mixin，最常的两种由 Discuss 应用(mail 模块)提供：</p>
<ul>
<li>mail.thread提供在许多文档表单下方或右侧的消息面板功能，以及消息和通知相关逻辑。这在我们自己的模型中将经常会添加，下面就来一起学习下。</li>
<li>mail.activity.mixin模型提供待办任务计划。</li>
</ul>
<blockquote>
<p><strong>ℹ️Odoo 11中的修改</strong><br>mail 模块现在通过mail.activity.mixin抽象模型提供Activities任务管理功能。该功能在 Odoo 11中才添加，此前的版本中没有。</p>
</blockquote>
<p>我们一起来为 Member 模型添加上述两种 mixin。社交消息功能由 mail 模块的mail.thread模型提供，要将其加入自定义模型，应进行如下操作：</p>
<ol>
<li>通过 mixin 模型 mail 为插件模块添加依赖</li>
<li>让类继承mail.thread和mail.activity.mixin两个 mixin 类</li>
<li>将message_follower_ids, message_ids和activity_id这些 mixin 的数据字段添加到表单视图</li>
</ol>
<p>对于第一步扩展模型需要在__manifest__.py文件中添加对 mail 的依赖。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x27;depends&#x27;: [&#x27;library_app&#x27;, &#x27;mail&#x27;],</span><br></pre></td></tr></table></figure>

<p>第二步中对 mixin 类的继承通过_inherit属性完成，应编辑library_member&#x2F;models&#x2F;library_member.py并添加如下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class Member(models.Model):</span><br><span class="line">    _name = &#x27;library.member&#x27;</span><br><span class="line">    _description = &#x27;Library Member&#x27;</span><br><span class="line">    _inherit = [&#x27;mail.thread&#x27;, &#x27;mail.activity.mixin&#x27;]</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>通过添加额外的这行代码，我们的模型就会包含这些 mixin 的所有字段和方法。</p>
<p>第三步中向表单视图添加相关字段，编辑library_member&#x2F;views&#x2F;member_view.xml文件并在表单最后添加如下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;odoo&gt;</span><br><span class="line">...</span><br><span class="line">            &lt;form&gt;</span><br><span class="line">...</span><br><span class="line">                &lt;!-- mail mixin fields --&gt;</span><br><span class="line">                &lt;div class=&quot;oe_chatter&quot;&gt;</span><br><span class="line">                    &lt;field name=&quot;message_follower_ids&quot; widget=&quot;mail_followers&quot; /&gt;</span><br><span class="line">                    &lt;field name=&quot;activity_ids&quot; widget=&quot;mail_activity&quot; /&gt;</span><br><span class="line">                    &lt;field name=&quot;message_ids&quot; widget=&quot;mail_thread&quot; /&gt;</span><br><span class="line">                &lt;/div&gt;</span><br><span class="line">            &lt;/form&gt;</span><br></pre></td></tr></table></figure>

<p>mail 模块还为这些字段提供了一些特定的网页组件，以上代码中已使用到。在升级模块后会员表单将变成这样：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3023074372144fcebdd348313aed1bc9~tplv-k3u1fbpfcp-zoom-1.image" alt="Odoo 12图书项目使用 Mixin 类继承"></p>
<p>有时普通用户仅能访问正在 follow 的记录。在这些情况下我们应添加访问记录规则来让用户可以看到 follow 的记录。本例中用不到这一功能，但可通过[(‘message_partner_ids’, ‘in’, [user.partner_id.id])]或来进行添加。</p>
<h2 id="继承-Python-方法"><a href="#继承-Python-方法" class="headerlink" title="继承 Python 方法"></a>继承 Python 方法</h2><p>Python 方法中编写的业务逻辑也可以被继承。Odoo 借用了 Python 已有的父类行为的对象继承机制。</p>
<p>作为一个实际的例子，我们将继承图书 ISBN 验证逻辑。在图书应用中仅能验证13位的 ISBN，但老一些的图书可能只有10位数的 ISBN。我们将继承_check_isbn()方法来完成这种情况的验证。在library_member&#x2F;models&#x2F;library_book.py文件中添加如下方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">from odoo import api, fields, models</span><br><span class="line"></span><br><span class="line">class Book(models.Model):</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">    @api.multi</span><br><span class="line">    def _check_isbn(self):</span><br><span class="line">        self.ensure_one()</span><br><span class="line">        isbn = self.isbn.replace(&#x27;-&#x27;, &#x27;&#x27;)</span><br><span class="line">        digits = [int(x) for x in isbn if x.isdigit()]</span><br><span class="line">        if len(digits) == 10:</span><br><span class="line">            ponderators = [1, 2, 3, 4, 5, 6, 7, 8, 9]</span><br><span class="line">            total = sum(a * b for a, b in zip(digits[:9], ponderators))</span><br><span class="line">            check = total % 11</span><br><span class="line">            return digits[-1] == check</span><br><span class="line">        else:</span><br><span class="line">            return super()._check_isbn()</span><br></pre></td></tr></table></figure>

<p>要继承方法，我们要重新定义该方法，可以使用 super()来调用已实现的部分。在这个方法中我们验证是否为10位数 ISBN，然后插入遗失的验证逻辑。若不是10位，则进入原有的13位验证逻辑。</p>
<p>如果想要进行测试甚至是书写测试用例，可使用0-571-05686-5作为例子，该书是威廉·戈尔丁的《蝇王》。</p>
<blockquote>
<p><strong>ℹ️Odoo 11中的修改</strong><br>从 Odoo 11开始，支持的主Python版本为 Python 3（Odoo 12中为 Python 3.5）。而此前的 Odoo 版本使用 Python 2，其中 super()需传入类名和 self 两个参数，那么，上例中的代码应修改为super(Book, self)._check_isbn()。</p>
</blockquote>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/46144cb9da0c4148ae0a6f330c19f4eb~tplv-k3u1fbpfcp-zoom-1.image" alt="Odoo 12图书项目10位 ISBN 验证"></p>
<h2 id="继承-Web-控制器和模板"><a href="#继承-Web-控制器和模板" class="headerlink" title="继承 Web 控制器和模板"></a>继承 Web 控制器和模板</h2><p>Odoo 中的所有功能都带有扩展性，web 功能也不例外，所以已有控制器和模块都能被继承。</p>
<p>作为示例，我们将继承图书目录网页，加入前面添加的图书可用性信息：</p>
<ul>
<li>在控制器端添加对查询参数的支持，访问&#x2F;library&#x2F;books?available&#x3D;1过滤出可借阅图书</li>
<li>在模板端，添加一个图书不可用的表示</li>
</ul>
<h3 id="继承网页控制器"><a href="#继承网页控制器" class="headerlink" title="继承网页控制器"></a>继承网页控制器</h3><p>网页控制器不应包含实际业务逻辑，仅集中于展示逻辑。我们可能会需要添加对额外 URL 参数甚至是路由的支持，来改变网页的展示。我们将扩展&#x2F;library&#x2F;books来支持available&#x3D;1参数，以过滤出可借阅图书。</p>
<p>要继承已有控制器，需导入对应对象，然后用方法新增逻辑来进行实现。下面新增ibrary_member&#x2F;controllers&#x2F;main.py文件并加入如下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">from odoo import http</span><br><span class="line">from odoo.addons.library_app.controllers.main import Books</span><br><span class="line"></span><br><span class="line">class BookExtended(Books):</span><br><span class="line">    @http.route()</span><br><span class="line">    def list(self, **kwargs):</span><br><span class="line">        response = super().list(**kwargs)</span><br><span class="line">        if kwargs.get(&#x27;available&#x27;):</span><br><span class="line">            Book = http.request.env[&#x27;library.book&#x27;]</span><br><span class="line">            books = Book.search([(&#x27;is_available&#x27;, &#x27;=&#x27;, True)])</span><br><span class="line">            response.qcontext[&#x27;books&#x27;] = books</span><br><span class="line">        return response</span><br></pre></td></tr></table></figure>

<p>我们要继承的Books控制器在library_app&#x2F;controllers&#x2F;main.py中定义。因此需要通过odoo.addons.library_app.controllers.main导入。这和模型不同，模型可以通过 env 对象中的central registry 来引用任意模型类，而无需了解实现它的文件。控制器没有这个，我们需要知道实现需继承控制器的模块和文件。</p>
<p>然后基于Books声明了一个BooksExtended类，类名不具关联性，仅用于继承和扩展原类中定义的方法。</p>
<p>再后我们(重)定义了一个控制器方法 list()。它至少需要一个简单的@http.route()装饰器来保持路径活跃。如果不带参数，将会保留父类中定义的路由。但也可以为@http.route() 装饰器添加参数，来重新定义或替换类路由。</p>
<p>在继承的 list()方法中，一开始使用了 super()来运行已有代码。处理结果返回一个 Response 对象，Response 带有模块要渲染的属性 template，以及渲染使用的上下文qcontext。但还需要生成 HTML，仅会在控制器结束运行时生成。这也让我们可以在最终渲染完成之前可以修改 Response 属性。</p>
<p>list()方法带有**kwargs参数，捕获所有kwargs字典中的参数。这些是 URL 中的参数，如?available&#x3D;1。方法检测kwargs中available键的值，检测到后改变qcontext来获取仅为可借阅图书的图书记录集。</p>
<p>还要记得让模块知道这个新 Python 文件，需通过将 controllers 子文件夹中添加到library_member&#x2F;<strong>init</strong>.py中：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">from . import models</span><br><span class="line">from . import controllers</span><br></pre></td></tr></table></figure>

<p>在library_member&#x2F;controllers&#x2F;<strong>init</strong>.py文件中添加一行代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">from . import main</span><br></pre></td></tr></table></figure>

<p>然后更新模板并访问http:&#x2F;&#x2F;<your-server>:8069&#x2F;library&#x2F;books?available&#x3D;1 将仅显示勾选了Is Available? 的图书</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d5f75edd8f9149d8924ec932b62d52d4~tplv-k3u1fbpfcp-zoom-1.image" alt="Odoo 12图书项目可借阅图书"></p>
<h3 id="继承-QWeb-模板"><a href="#继承-QWeb-模板" class="headerlink" title="继承 QWeb 模板"></a>继承 QWeb 模板</h3><p>要修改网页的实际展示，就需要继承所使用的 QWeb 模板。我们将继承library_app.book_list_template来展示更多有关不可借阅图书的信息。添加library_member&#x2F;views&#x2F;book_list_template.xml文件并加入如下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;odoo&gt;</span><br><span class="line">    &lt;template id=&quot;book_list_extended&quot;</span><br><span class="line">        name=&quot;Extended Book List&quot;</span><br><span class="line">        inherit_id=&quot;library_app.book_list_template&quot;&gt;</span><br><span class="line">        &lt;xpath expr=&quot;//span[@t-field=&#x27;book.publisher_id&#x27;]&quot; position=&quot;after&quot;&gt;</span><br><span class="line">            &lt;t t-if=&quot;not book.is_available&quot;&gt;</span><br><span class="line">                &lt;b&gt;(Not Available)&lt;/b&gt;</span><br><span class="line">            &lt;/t&gt;</span><br><span class="line">        &lt;/xpath&gt;</span><br><span class="line">    &lt;/template&gt;</span><br><span class="line">&lt;/odoo&gt;</span><br></pre></td></tr></table></figure>

<p>网页模板像其它 Odoo 视图类型一样是 XML 文件，同样也可以使用 XPath 来定位元素并对它们进行操作。所继承模型通过在元素中的inherit_id来指明。</p>
<blockquote>
<p><strong>小贴士：</strong> 在前例中使用了灵活性很强的 XPath 标记，但这里也可以使用等价的简化标记：<span t-field="book.publisher_id" position="after"></p>
</blockquote>
<p>然后在 library_member&#x2F;<strong>manifest</strong>.py文件中加入该文件的声明：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">    &#x27;data&#x27;:[</span><br><span class="line">...</span><br><span class="line">        &#x27;views/book_list_template.xml&#x27;,</span><br><span class="line">    ]</span><br></pre></td></tr></table></figure>

<p>然后访问http:&#x2F;&#x2F;<your-server>:8069&#x2F;library&#x2F;books即可对不可借阅图书展示额外的(Not Available)信息。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/26de7b417b55416d8407f8d5a9b2f5a1~tplv-k3u1fbpfcp-zoom-1.image" alt="Odoo 12图书项目不可借阅图书"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>扩展性是 Odoo 框架的一个重要功能。我们可以创建插件来为需要实现功能的多个层的已有插件修改或添加功能。</p>
<p>模型层中，我们使用_inherit模型属性来引用已有模型，然后在原处执行修改。模型内的字段对象还支持叠加定义，这样可对已有字段重新声明，仅修改属性。</p>
<p>其它的模型继承机制允许我们利用数据结构和业务逻辑。代理继承通过多对一关联字段上的delegate&#x3D;True属性（或老式的 inherits 模型属性），来让所有关联模块的所有字段可用，并复用它们的数据结构。原型继承使用_inherit属性，来复制其它模型的功能（数据结构定义和方法），并启用抽象 mixin 类，提供一系列像文档讨论消息和 follower 的可复用功能。</p>
<p>视图层中，视图结构通过 XML 定义，（使用 XPath 或 Odoo 简化语法）定位 XML 元素来进行继承及添加 XML 片断。其它由模块创建的记录已可由继承模块修改，仅需引用 对应的完整 XML ID 并在设想的字段上执行写操作。</p>
<p>业务逻辑层中，可使用模型继承相同的机制来进行继承，以及重新声明要继承的方法。在方法内，Python 的super()函数可用于调用所继承方法的代码，添加代码可在其之前或之后运行。</p>
<p>对于前端网页，控制器中的展示逻辑继承方式和模型方法相似，网页模板也是包含 XML 结构的视图，因此可以像其它视图类型一样的被继承。</p>
<p>下一篇文章中，我们将更深入学习模型，探索模型提供给我们的所有功能。</p>
<p>☞☞☞第五章 <a target="_blank" rel="noopener" href="https://alanhou.org/odoo12-import-export-data/">Odoo 12开发之导入、导出以及模块数据</a></p>
<h2 id="学霸专区"><a href="#学霸专区" class="headerlink" title="学霸专区"></a>学霸专区</h2><ol>
<li>如何继承已有模型来添加 mixin，如mail.thread？</li>
<li>要在会员表单视图中添加Phone字段需要做哪些修改？</li>
<li>如果创建一个与继承属性的属性名不同的模型类会发生什么(例如_name&#x3D;’y’ and _inherit&#x3D;’x’)？</li>
<li>XPath是否可用于修改其它模块的数据记录？</li>
<li>继承一个模型时，是否可扩展其方法但不使用 super()调用所继承的原始代码？</li>
<li>如何在不引用任何特定字段名的情况下继承图书目录页并在末行添加 ISBN 字段？</li>
</ol>
<h2 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h2><p>以下是对官方文档的其它引用，可对模块的扩展和继承机制的知识进行补充：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.odoo.com/documentation/12.0/reference/orm.html#inheritance-and-extension">模型继承</a></li>
<li><a target="_blank" rel="noopener" href="https://www.odoo.com/documentation/12.0/reference/views.html#inheritance">视图继承</a></li>
<li><a target="_blank" rel="noopener" href="https://www.odoo.com/documentation/12.0/reference/http.html#controllers">网页控制器</a></li>
</ul>
<p>本文首发地址：<a target="_blank" rel="noopener" href="https://alanhou.org/developer-mode-odoo12/">Alan Hou 的个人博客</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://alanhou.github.io/2019/01/06/odoo-essentials-12-chapter3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Alan Hou">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Alan Hou的个人博客">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Alan Hou的个人博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2019/01/06/odoo-essentials-12-chapter3/" class="post-title-link" itemprop="url">第三章 Odoo 12 开发之创建第一个 Odoo 应用</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2019-01-06 00:00:00" itemprop="dateCreated datePublished" datetime="2019-01-06T00:00:00+08:00">2019-01-06</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2023-02-03 13:35:22" itemprop="dateModified" datetime="2023-02-03T13:35:22+08:00">2023-02-03</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>本文为<a target="_blank" rel="noopener" href="https://alanhou.org/odoo-12-development/">最好用的免费ERP系统Odoo 12开发手册</a>系列文章第三篇。</p>
<p>Odoo 开发通常都需要创建自己的插件模块。本文中我们将通过创建第一个应用来一步步学习如何在 Odoo 中开启和安装这个插件。我们将从基础的开发流学起，即创建和安装新插件，然后在开发迭代中更新代码来进行升级。</p>
<p>Odoo 采用类 MVC(Model-View-Controller)的结构，我们将深入到各层来实施一个图书应用。本文主要内容有：</p>
<ul>
<li>创建一个新的模块，用来实施相关功能</li>
<li>添加应用的特性功能：顶级菜单项和安全组</li>
<li>添加一个一开始会失败但在项目完成时成功运行的自动化测试</li>
<li>实施模型层，定义应用的数据结构和相关访问权限</li>
<li>实施后台视图层，编写内部用户界面</li>
<li>实施业务逻辑层，支持数据验证和自动化</li>
<li>实施 web 层，展示访客和内部用户的用户界面</li>
</ul>
<h2 id="系统准备"><a href="#系统准备" class="headerlink" title="系统准备"></a>系统准备</h2><p>本文要求安装了 Odoo 服务并可通过命令行启动服务来进行模块安装和运行测试之类的操作。如果还没有相关环境，请参照本系列文章第二篇<a target="_blank" rel="noopener" href="https://alanhou.org/odoo12-development-environment/">Odoo 12开发之开发环境准备</a>。</p>
<p>本文中我们将从零开始创建第一个 Odoo 应用，无需额外的代码。本文代码可通过 <a target="_blank" rel="noopener" href="https://github.com/alanhou/odoo12-development">GitHub 仓库</a>进行查看。</p>
<h2 id="概览图书项目"><a href="#概览图书项目" class="headerlink" title="概览图书项目"></a>概览图书项目</h2><p>为更好地在本文中探讨，我们将使用一个现实中可以使用的学习项目。一起来创建一个管理图书库的 Odoo 应用。该项目将在后续文章中持续使用，每篇文章都会进行一次迭代，为应用添加新的功能。本文中将创建图书应用的第一个版本，第一个功能是实现图书目录。</p>
<p>图书将包含如下数据：</p>
<ul>
<li>标题</li>
<li>作者</li>
<li>出版社</li>
<li>发行日期</li>
<li>封面图</li>
<li> ISBN：包含检查 ISBN是否有效的功能</li>
<li>有效性标记；标识图书是否已对公众发布</li>
</ul>
<p>图书目录可由图书管理员编辑，对图书操作者则仅有可读权限。该目录可通过公共网页访问，仅显示已发布图书。就是这样一个简单的项目，但提供有用的功能，足以让我们了解 Odoo 应用的主要构件。</p>
<h2 id="创建新的插件模块"><a href="#创建新的插件模块" class="headerlink" title="创建新的插件模块"></a>创建新的插件模块</h2><p>一个插件模块是包含实现一些 Odoo 功能的文件夹，可以添加新功能或修改已有的功能。插件目录必须含有一个声明或描述文件__manifest__.py，以及其它模块文件。</p>
<p>一部分模块插件在 Odoo 中以app的形式出现，通常都会带有顶级菜单项。它们为 CRM 或 HR 这样的功能区添加核心元素，因此在 Odoo 应用菜单中会高亮显示。另外还有一些非应用模块插件一般为这些应用添加功能。如果你的模块为 Odoo 添加新的或重要的功能，一般应该是app。而如果模块仅修改应用的功能，那么就是一个普通的插件模块。</p>
<p>要创建新模块，需要：</p>
<ol>
<li>确保操作的目录是 Odoo 的 addons 路径</li>
<li>创建模块目录，并包含声明文件</li>
<li>可选择为模块添加一个图标</li>
<li>如打算对外发布，为模块选择一个证书</li>
</ol>
<p>然后我们就可以安装模块了，确定模块在 Odoo 服务中可见并正确安装它。</p>
<h3 id="准备-addons-路径"><a href="#准备-addons-路径" class="headerlink" title="准备 addons 路径"></a>准备 addons 路径</h3><p>一个插件模块是一个含有 Odoo 声明文件的目录，它创建一个新应用或为已有应用添加功能。addons模块的路径是一系列目录，Odoo 服务可以在这里查找插件。默认addons包含odoo&#x2F;addons 中存放的 Odoo 自带的官方应用，以及在odoo&#x2F;odoo&#x2F;addons目录中提供核心功能的 base 模块。</p>
<p>我们应将自己创建的或应用市场及其它地方下载的模块放到指定的目录中。要使得 Odoo 服务能够找到这些应用，需要这些目录添加到 Odoo 的 addons 路径中。</p>
<p>根据我们在<a target="_blank" rel="noopener" href="https://alanhou.org/odoo12-development-environment/">Odoo 12开发之开发环境准备</a>所创建的项目，Odoo 的代码存放在<del>&#x2F;odoo-dev&#x2F;odoo&#x2F;目录下。最佳实践告诉我们应在自有目录下添加代码，而不应与 Odoo 源代码混在一起。所以要添加自定义模块，我们将在 Odoo 同级创建目录</del>&#x2F;odoo-dev&#x2F;custom-addons并添加到 addons 路径中。要添加该目录至 addons 路径，执行如下命令</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd ~/odoo-dev</span><br><span class="line">./odoo/odoo-bin -d dev12 --addons-path=&quot;custom-addons,odoo/addons&quot; --save</span><br></pre></td></tr></table></figure>

<p>注：如有报错参照<a target="_blank" rel="noopener" href="https://alanhou.org/odoo-faq/">Odoo常见问题汇总</a>开发类错误处理001</p>
<p>–save 参数将选项保存至配置文件中，这样我们就无需在每次启动服务时输入参数，只需运行.&#x2F;odoo-bin 即可使用上次使用的参数。可以通过-c 参数指定文件来使用或保存配置项。仔细查看输出的日志，可以看到INFO ? odoo: addons paths:[…] 一行中包含custom-addons目录。</p>
<p>如需使用其它目录也请添加至 addons 路径，比如有~&#x2F;odoo-dev&#x2F;extra 目录中包含需用到的目录，则需通过如下方式设置–addons-path参数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--addons-path=&quot;custom-addons,extra,odoo/addons&quot;</span><br></pre></td></tr></table></figure>

<p>现在我们需要让 Odoo 实例能识别新模块。</p>
<blockquote>
<p><strong>小贴士：</strong> 以上使用的是相对路径，但在配置文件中需使用绝对路径，–save 参数会自行进行转化。</p>
</blockquote>
<h3 id="创建模块目录和声明文件"><a href="#创建模块目录和声明文件" class="headerlink" title="创建模块目录和声明文件"></a>创建模块目录和声明文件</h3><p>现在就准备好了~&#x2F;odoo-dev&#x2F;custom-addons目录，已正确添加至 addons 路径，Odoo 也就可以找到这里的模块。Odoo 自带一个scaffold命令可自动创建新模块目录，其中会包含基础结构。此处并不会使用该命令，而是手动创建。通过以下命令可以了解scaffold用法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~/odoo-dev/odoo/odoo-bin scaffold --help</span><br></pre></td></tr></table></figure>

<p>Odoo 模块目录需包含一个__manifest__.py描述性文件，同时还需要是可导入的包，所以还应包含__init__.py文件。</p>
<blockquote>
<p><strong>ℹ️</strong>在老版本中，该描述性文件为__openerp__.py或__odoo__.py，这些名称已过时但仍可使用。</p>
</blockquote>
<p>模块目录名是其技术名称，我们使用library_app，技术名称应是有效 Python 标识符，即以字母开头且仅能包含字母、数字和下划线。执行如下步骤来初始化新模块：</p>
<p>1、通过命令行，我们可以添加一个空的__init__.py 文件来初始化模块：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p ~/odoo-dev/custom-addons/library_app</span><br><span class="line">touch ~/odoo-dev/custom-addons/library_app/__init__.py</span><br></pre></td></tr></table></figure>

<p>2、下面添加声明文件，其中应包含一个 Python 字典，有几十个可用属性。其中仅 name属性为必填，但推荐同时添加 description 和 author 属性。在__init__.py 同级创建__manifest__.py 文件，添加以下内容：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &#x27;name&#x27;: &#x27;Library Management&#x27;,</span><br><span class="line">    &#x27;description&#x27;: &#x27;Manage library book catalogue and lending.&#x27;,</span><br><span class="line">    &#x27;author&#x27;: &#x27;Alan Hou&#x27;,</span><br><span class="line">    &#x27;depends&#x27;: [&#x27;base&#x27;],</span><br><span class="line">    &#x27;application&#x27;: True,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>depends 属性可以是一个包含所用到的模块列表。Odoo 会在模块安装时自动安装这些模块，这不是强制属性，但建议使用。如果没有特别的依赖，可以添加内核 base 模块。应注意将所有依赖都在此处列明，否则，模块会因缺少依赖而报错或出现加载错误（如果碰巧依赖模块在随后被加载了）。</p>
<p>我们的应用无需依赖其它模块，所以本处使用了 base。为保持简洁，这里仅使用了几个基本描述符键：</p>
<ul>
<li>name：插件模块标题字符串</li>
<li>description：功能描述长文件，通常为RST格式</li>
<li>author：作者姓名，本处为一个字符串，可以是逗号分隔的一系列姓名</li>
<li>depends：一个依赖插件模块列表，在模块安装时会先安装这些插件</li>
<li>application：一个布尔型标记，代表模块是否在应用列表中以 app 展现</li>
</ul>
<p>description可由模块顶层目录中的README.rst或README.md代替，如果两者都不存在，将使用声明文件中的description。</p>
<p>在真实场景中，建议也同时使用其它属性名，因它们与 Odoo 的应用商店有关：</p>
<ul>
<li>summary：显示为模块副标题的字符串</li>
<li>version:：默认为1.0，应遵守<a target="_blank" rel="noopener" href="http://semver.org/">版本号规则</a>。建议在模块版本号前加上 Odoo 版本，如12.0.1.0</li>
<li>license:：默认为LGPL-3</li>
<li>website：了解模块更多信息的 URL，可以帮助人们查看更多文档或提供文件 bug 和建议的跟踪</li>
<li>category:：带有模块功能性分类字符串，缺省为Uncategorized。已有分类可通过安全组表单（位于Settings &gt; Users &amp; Companies &gt; Groups）的 Application字段下拉列表查看（需开启调试模式）</li>
</ul>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e20a522c396c4716824bbb0591b59c21~tplv-k3u1fbpfcp-zoom-1.image" alt="模块已有分类信息"></p>
<p>还有以下描述符键：</p>
<ul>
<li>installable：默认为 True，但可以通过设置为 False 来禁用模块</li>
<li>auto_install：若设置为 True，在其依赖已安装时会自动安装，用于胶水模块，用于同一实例上两个模块安装后功能的连接。</li>
</ul>
<h3 id="添加图标"><a href="#添加图标" class="headerlink" title="添加图标"></a>添加图标</h3><p>模块可选择添加图标，这对于作为 app 的模块尤其重要，因为在应用菜单中一般都应有图标。要添加图标，需要在模块中添加static&#x2F;description&#x2F;icon.png文件。</p>
<p>为简化操作，我们可以复用 accounting 应用的图标，把odoo&#x2F;addons&#x2F;account&#x2F;static&#x2F;description&#x2F;icon.png文件拷贝至customaddons&#x2F;library_app&#x2F;static&#x2F;description目录。可通过如下命令完成：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd ~/odoo-dev</span><br><span class="line">mkdir -p ./custom-addons/library_app/static/description</span><br><span class="line">cp ~/odoo-dev/odoo/addons/note/static/description/icon.png ./custom-addons/library_app/static/description</span><br></pre></td></tr></table></figure>

<p>补充：开启开者发者模式（修改 URL 中web#为web?debug#），点击 Apps &gt; Update Apps List即可搜到我们创建的应用（下图我使用了自定义的图标）</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/891d6cece36b4799aa886ebcc5410f80~tplv-k3u1fbpfcp-zoom-1.image" alt="Odoo 12添加图书 icon"></p>
<h3 id="选择证书-开源协议"><a href="#选择证书-开源协议" class="headerlink" title="选择证书(开源协议)"></a>选择证书(开源协议)</h3><p>为开发的模块选择证书（开源协议）非常重要，应谨慎考虑其代表着什么。Odoo 模块最常用的协议是LGPL(GNU Lesser General Public License)第3版(LGPL v3.0)和AGPL(Affero General Public License)。</p>
<p>LGPL 授权更广，它允许在无需分享相应源码的情况下对代码作出商业修改。AGPL则是一个更严格的开源证书，它要求派生代码及服务托管者分享源码。</p>
<p>了解更多有关 GNU 证书请访问<a target="_blank" rel="noopener" href="https://www.gnu.org/licenses/">GNU官网</a>。</p>
<h3 id="安装新模块"><a href="#安装新模块" class="headerlink" title="安装新模块"></a>安装新模块</h3><p>现在我们已经有了一个简化的模块，还没有任何功能，但我们可以通过安装它来检查各项是否正常。</p>
<p>要进行这一操作，模块所有的插件目录应对 Odoo 服务可见。可以通过启动 Odoo 服务来进行确认，可以在输出第一行看到显示为odoo: addons paths: xxx 字样，其中会显示在用的插件路径。更多有关插件路径的知识，参见本系列文章第二篇 <a target="_blank" rel="noopener" href="https://alanhou.org/odoo12-development-environment/">Odoo 12开发之开发环境准备</a>。</p>
<p>要安装新的模块，我们应在启动服务时指定-d 和-i 参数，-d 指定应使用的数据库，-i 可接收一个逗号分隔的多个待安装模块名。假定开发数据库为dev12，则使用如下命令进行安装：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~/odoo-dev/odoo/odoo-bin -d dev12 -i library_app</span><br></pre></td></tr></table></figure>

<p>仔细看日志输出可确定模块是否能被找到并安装，正确安装对应日志： odoo.modules.registry: module library_app: creating or updating database tables。</p>
<h3 id="更新模块"><a href="#更新模块" class="headerlink" title="更新模块"></a>更新模块</h3><p>开发模块是一个不断迭代的过程，我们会需要应用更新所修改代码并在 Odoo 中可见。可以在后台界面Apps中搜索对应模块并点击 Upgrade 按钮。但如果修改的是 Python 代码，点击升级不会生效，需要先重启服务方可生效。这是因为 Odoo 仅会加载一次 Python 代码，此后的修改就要求进行重启才会生效。</p>
<p>有时，模块中既修改了数据文件又修改了 Python 代码，那么就需要同时进行如上两种操作。这是 Odoo 开发者的常见困惑。幸好还有更好的方式，最保险的方式是重启 Odoo 实例并应用升级至开发数据库。通过Ctrl + C停止服务实例，然后通过如下命令启动服务并升级library_app模块：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~/odoo-dev/odoo/odoo-bin -d dev12 -u library_app</span><br></pre></td></tr></table></figure>

<p>-u(或全称–update)要求使用-d 参数并接收一个逗号分隔的待升级模块集。例如可以使用-u library_app,mail。模块升级后，所有依赖该模块的模块也会被升级。这是保持用于扩展功能的继承机制完整性的基础。</p>
<blockquote>
<p><strong>Odoo 11中的修改：</strong><br>直到 Odoo 10.0，要安装新的插件模块，需要在后台客户端菜单中手动更新以对 Odoo 可见。从 11.0开始，模块列表在模块安装或更新时会自动更新。</p>
</blockquote>
<p>在本系列文章中，如需应用对模块代码的修改：</p>
<ul>
<li>添加模型字段时需进行升级。修改 Python 代码（含 manifest 文件）时需要重启服务。</li>
<li>修改XML或CSV文件时，需进行升级。在不确定时，同时重启服务并升级模块。</li>
</ul>
<p>在不确定时，最保险的方式是通过-u参数来重启 Odoo 实例，按下键盘上、下方向键可在使用过的命令间切换。进行这一操作时，我们经常会使用到 Ctrl+C，向上方向键和Enter 键。</p>
<p>或者要避免这种重复的停止&#x2F;启动操作，可使用dev&#x3D;all选项。这样在保存XML 和 Python文件修改时会自动进行重载，参见本系列文章第二篇 <a target="_blank" rel="noopener" href="https://alanhou.org/odoo12-development-environment/">Odoo 12开发之开发环境准备</a>了解更多详情。</p>
<h2 id="创建新应用"><a href="#创建新应用" class="headerlink" title="创建新应用"></a>创建新应用</h2><p>一些 Odoo 模块创建新应用，而另一些则对已有应用添加功能或作出修改。虽然两者的技术组件基本相同，但应用会被预期包含一些特征性元素。我们创建的是一个图书应用，所以应包含这些元素，它们是：</p>
<ul>
<li>图标：用于在应用列表中展示</li>
<li>顶级菜单项：其下放置所有的应用菜单项</li>
<li>应用安全组：通过权限访问仅对指定用户开放</li>
</ul>
<p>添加图标(icon)，仅需在模块目录下static&#x2F;description&#x2F;子文件夹中放置icon.png文件，前面已经介绍过了。下面我们来添加应用顶级菜单。</p>
<h3 id="添加应用顶级菜单项"><a href="#添加应用顶级菜单项" class="headerlink" title="添加应用顶级菜单项"></a>添加应用顶级菜单项</h3><p>我们创建的是一个新应用，因此应包含主菜单项，在社区版本中，显示在左侧下拉菜单中，而在企业版中，则作为附加图标显示在应用切换器主界面中。</p>
<p>菜单项是使用 XML 文件中添加的视图组件，通过创建views&#x2F;library_menu.xml来定义菜单项：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot;?&gt;</span><br><span class="line">&lt;odoo&gt;</span><br><span class="line">    &lt;!-- Library App Menu --&gt;</span><br><span class="line">    &lt;menuitem id=&quot;menu_library&quot; name=&quot;Library&quot; /&gt;</span><br><span class="line">&lt;/odoo&gt;</span><br></pre></td></tr></table></figure>

<p>用户界面中的菜单项和操作均存储于数据表中，上面的代码是一个 Odoo 数据文件，描述了要载入 Odoo 数据库的记录。其中的元素是向ir.ui.menu模型写入记录的指示。 id 属性也称作XML ID，用于唯一标识每个数据元素，以供其它元素引用。例如在添加图书子菜单时，就需要引用顶级菜单的XML ID，即menu_library。XML ID是一个重要话题，将在本系列文章第五篇<a target="_blank" rel="noopener" href="https://alanhou.org/odoo12-import-export-data/">Odoo 12开发之导入、导出以及模块数据</a>中探讨。</p>
<p>此处添加的菜单项非常简单，仅用到了 name 属性。其它常用的属性这里没有使用，没有设置父菜单，因为这是一个顶级菜单。也没有设置 action，因菜单项本身并不做任何事，仅仅用于放置后面要创建的子菜单项。模块还不知道 XML 数据文件的存在，我们需要在__manifest__.py中使用 data 属性来添加安装或更新时需要加载的模块列表以进行声明。在manifest 文件的字典中加入：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x27;data&#x27;: [</span><br><span class="line">    &#x27;views/library_menu.xml&#x27;,</span><br><span class="line">],</span><br></pre></td></tr></table></figure>

<p>要向Odoo数据库中加载这些菜单设置，需要升级模块。此时还不会有什么显式的效果，因菜单项还不包含可操作子菜单，所以不会显示。在添加好子菜单及合适的访问权限时即可显示。</p>
<blockquote>
<p><strong>小贴士：</strong> 菜单树中的项目仅在含有可见子菜单项时才会显示。底层包含窗口操作视图的菜单项仅当用户拥有该模型访问权限时才可见。</p>
</blockquote>
<h3 id="添加权限组"><a href="#添加权限组" class="headerlink" title="添加权限组"></a>添加权限组</h3><p>普通用户在使用功能前需获得相应的权限。Odoo 中使用安全组来实现，权限授予组，组中分配用户。Odoo 应用通常有两个组：针对普通用户的用户组，包含额外应用配置权限的管理员组。</p>
<p>下面我们就来添加这两个安全组。权限安全相关的文件通常放在模块下&#x2F;security子目录中，这里我们创建security&#x2F;library_security.xml 文件来进行权限定义。安全组使用分类来更好地组织关联应用。所以第一步我们在ir.module.category模型中创建针对图书应用的分类：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; ?&gt;</span><br><span class="line">&lt;odoo&gt;</span><br><span class="line">    &lt;record id=&quot;module_library_category&quot; model=&quot;ir.module.category&quot;&gt;</span><br><span class="line">        &lt;field name=&quot;name&quot;&gt;Library&lt;/field&gt;</span><br><span class="line">    &lt;/record&gt;</span><br><span class="line">&lt;/odoo&gt;</span><br></pre></td></tr></table></figure>

<p>下一步，我们要添加两个安全组，首先添加用户组。在以上结束标签前添加如下 XML 代码块：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- Library User Group --&gt;</span><br><span class="line">&lt;record id=&quot;library_group_user&quot; model=&quot;res.groups&quot;&gt;</span><br><span class="line">    &lt;field name=&quot;name&quot;&gt;User&lt;/field&gt;</span><br><span class="line">    &lt;field name=&quot;category_id&quot; ref=&quot;module_library_category&quot; /&gt;</span><br><span class="line">    &lt;field name=&quot;implied_ids&quot; eval=&quot;[(4, ref(&#x27;base.group_user&#x27;))]&quot; /&gt;</span><br><span class="line">&lt;/record&gt;</span><br></pre></td></tr></table></figure>

<p>记录在res.groups模型中创建，添加了三个字段：</p>
<ul>
<li><strong>name：</strong> 组名</li>
<li><strong>category_id：</strong> 关联应用，这是一个关联字段，因此使用了 ref 属性来通过 XML ID 连接已创建的分类</li>
<li><strong>implied_ids：</strong> 这是一个one-to-many关联字段，包含一系列组来对组内用户生效。这里使用了一个特殊语法，在本系列文章第五篇<a target="_blank" rel="noopener" href="https://alanhou.org/odoo12-import-export-data/">Odoo 12开发之导入、导出以及模块数据</a>中会进行介绍。我们使用了编号4来连接基本内部用户组base.group_user。</li>
</ul>
<p>然后我们创建管理员组，授予用户组的所有权限以及为应用管理员保留的其它权限：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- Library Manager Group --&gt;</span><br><span class="line">&lt;record id=&quot;library_group_manager&quot; model=&quot;res.groups&quot;&gt;</span><br><span class="line">    &lt;field name=&quot;name&quot;&gt;Manager&lt;/field&gt;</span><br><span class="line">    &lt;field name=&quot;category_id&quot; ref=&quot;module_library_category&quot; /&gt;</span><br><span class="line">    &lt;field name=&quot;implied_ids&quot; eval=&quot;[(4, ref(&#x27;library_group_user&#x27;))]&quot; /&gt;</span><br><span class="line">    &lt;field name=&quot;users&quot; eval=&quot;[</span><br><span class="line">                (4, ref(&#x27;base.user_root&#x27;)),</span><br><span class="line">                (4, ref(&#x27;base.user_admin&#x27;))</span><br><span class="line">            ]&quot; /&gt;</span><br><span class="line">&lt;/record&gt;</span><br></pre></td></tr></table></figure>

<p>像用户组一样，这里也有name, category_id和implied_ids ，implied_ids关联了图书用户组，以继承其权限。还添加了一个 users 字段，让管理员和内部 root 用户自动成为应用管理员。</p>
<blockquote>
<p><strong>ℹ️</strong>在 Odoo老版本中，admin 管理员用户同时也是 root 用户。Odoo 12中有一个系统 root用户，在用户列表中不显示，仅在框架需要进行提权(sudo)时在内部使用。admin可以登入系统并应拥有所有功能的访问权限，但不再像系统 root 用户那样可以绕过访问限制。</p>
</blockquote>
<p>同样需要在声明文件中添加该 XML 文件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x27;data&#x27;: [</span><br><span class="line">    &#x27;security/library_security.xml&#x27;,</span><br><span class="line">    &#x27;views/library_menu.xml&#x27;,</span><br><span class="line">],</span><br></pre></td></tr></table></figure>

<p>注意library_security.xml 加在library_menu.xml文件之前，数据文件的加载顺序非常重要，因为我们只能引用已经定义过的标识符。菜单项经常引用到安全组，所以建议将安全组定义文件放到菜单和视图文件之前。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cd1c8a9a071a4fa78bcdb5c5a408379f~tplv-k3u1fbpfcp-zoom-1.image" alt="Odoo 12图书应用组"></p>
<h2 id="添加自动化测试"><a href="#添加自动化测试" class="headerlink" title="添加自动化测试"></a>添加自动化测试</h2><p>编程的最佳实践包含代码的自动化测试，对于像 Python 这样的动态语言尤为重要，因为它没有编译这一步，只有在解释器实际运行代码时才会报语法错误。好的编辑器可以让我们提前发现问题，但无法像自动化测试这样帮助我们确定代码如预期般运行。</p>
<blockquote>
<p><strong>Odoo 12中的修改</strong><br>在老版本中，Odoo 使用YAML文件来进行测试，但 Odoo 12中移除了对YAML文件的支持，所以不能再使用该格式文件。</p>
</blockquote>
<p>测试驱动开发（TDD -Test-driven Development） 方法让我们先写测试，检查错误，然后开发代码直至通过测试。受此方法启示，在添加实际功能前我们先添加模块测试：</p>
<p>1、测试代码文件名应以test_开头，并通过tests&#x2F;<strong>init</strong>.py引用。但测试目录（也即 Python 子模块）不应在模块的外层__init__.py中引入，因为仅在测试执行时才会自动查找和加载它。</p>
<p>2、测试应放在tests&#x2F;子目录中，在tests&#x2F;<strong>init</strong>.py中添加如下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">from . import test_book</span><br></pre></td></tr></table></figure>

<p>3、在tests&#x2F;test_book.py文件中添加实际的测试代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">from odoo.tests.common import TransactionCase</span><br><span class="line"></span><br><span class="line">class TestBook(TransactionCase):</span><br><span class="line">    def setUp(self, *args, **kwargs):</span><br><span class="line">        result = super().setUp(*args, **kwargs)</span><br><span class="line">        self.Book = self.env[&#x27;library.book&#x27;]</span><br><span class="line">        self.book_ode = self.Book.create(&#123;</span><br><span class="line">            &#x27;name&#x27;: &#x27;Odoo Development Essentials&#x27;,</span><br><span class="line">            &#x27;isbn&#x27;: &#x27;879-1-78439-279-6&#x27;&#125;)</span><br><span class="line">        return result</span><br><span class="line">    def test_create(self):</span><br><span class="line">        &quot;Test Books are active by default&quot;</span><br><span class="line">        self.assertEqual(self.book_ode.active, True)</span><br></pre></td></tr></table></figure>

<p>以上代码添加一个简单测试用例，创建一本新书并检测active 字段的值是否正确。</p>
<p>4、使用–test-enable参数在安装或升级模块时进行测试</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~/odoo-dev/odoo/odoo-bin -d dev12 -u library_app --test-enable</span><br></pre></td></tr></table></figure>

<p>5、Odoo 服务会在升级的模块中查找tests&#x2F;子目录并运行。现在测试会抛出错误，在输出日志中可看到测试相关的ERROR信息。在为模块添加完图书模型后应该就不再报错。</p>
<h3 id="测试业务逻辑"><a href="#测试业务逻辑" class="headerlink" title="测试业务逻辑"></a>测试业务逻辑</h3><p>现在我们应为业务逻辑添加测试了，理想情况下每行代码都应有一个测试用例。在tests&#x2F;test_book.py文件test_create() 方法再加几行代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">def test_check_isbn(self):</span><br><span class="line">    &quot;Check valid ISBN&quot;</span><br><span class="line">    self.assertTrue(self.book_ode._check_isbn)</span><br></pre></td></tr></table></figure>

<p>推荐为每个需检查的操作添加一个测试用例，本条测试与上一条相似，先创建一本新书。因为各个测试用例是相互独立的，用例创建或修改的数据会在测试结束时回滚。然后在创建的记录上调用测试方法来检查所使用 ISBN是否被正确验证。</p>
<p>当然，现在运行测试还是会失败，因为所测试的功能还未被实现。</p>
<h3 id="测试安全权限"><a href="#测试安全权限" class="headerlink" title="测试安全权限"></a>测试安全权限</h3><p>也可以对安全权限进行检测，确定是否对用户进行了正确的授权。Odoo 中默认测试由不受权限控制的__system__内部用户执行。所以我们应改变执行测试的用户，来检测是否授予了正确的安全权限。这通过在self.env中修改执行环境来实现，只需把 user 属性修改为希望运行测试的用户即可。修改tests&#x2F;test_book.py中的setUp方法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">def setUp(self, *args, **kwargs):</span><br><span class="line">    result = super().setUp(*args, **kwargs)</span><br><span class="line">    user_admin = self.env.ref(&#x27;base.user_admin&#x27;)</span><br><span class="line">    self.env = self.env(user=user_admin)</span><br><span class="line">    self.Book = self.env[&#x27;library.book&#x27;]</span><br><span class="line">    self.book_ode = self.Book.create(&#123;</span><br><span class="line">        &#x27;name&#x27;: &#x27;Odoo Development Essentials&#x27;,</span><br><span class="line">        &#x27;isbn&#x27;: &#x27;879-1-78439-279-6&#x27;&#125;)</span><br><span class="line">    return result</span><br></pre></td></tr></table></figure>

<p>第一条命令调用了父类中的setUp代码，下面一条修改了用于测试的环境self.env为使用 admin 用户的新环境。测试代码的修改到此告一段落。</p>
<h2 id="模型层"><a href="#模型层" class="headerlink" title="模型层"></a>模型层</h2><p>既然 Odoo 已经能识别我们的新模块了，下面就添加一个简单的模型。模型描述业务对象，如商机、销售订单或合作伙伴（用户、供应商等）。模型中有一系列属性，也可定义一些特定业务逻辑。</p>
<p>模型通过 Odoo 模板类派生的 Python 类来实现。它直接与数据库对象对应，Odoo 在安装或升级模块时会自动进行处理。框架中负责这部分的是对象关系映射（ORM -Object Relational Mapping）。</p>
<p>我们的模块是一个图书管理应用，第一个功能就是管理图书目录，目前这是我们唯一需要实现的模型。</p>
<h3 id="创建数据模型"><a href="#创建数据模型" class="headerlink" title="创建数据模型"></a>创建数据模型</h3><p>Odoo 开发指南中提到模型的 Python 文件应放在models子目录中，每个模型有一个对应文件。因此我们在library_app模块主目录下创建models&#x2F;library_book.py文件。</p>
<blockquote>
<p><strong>ℹ️</strong>Odoo 官方编码指南请见 <a target="_blank" rel="noopener" href="http://www.odoo.com/documentation/12.0/reference/guidelines.html">Odoo 官网</a>。另一相关的编码标准文档为 <a target="_blank" rel="noopener" href="https://github.com/OCA/odoo-community.org/blob/master/website/Contribution/CONTRIBUTING.rst">OCA 编码指南</a>。</p>
</blockquote>
<p>在使用之前，应告知 Python 所需引用的模型目录，仅需在模块主__init__.py文件添加：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">from . import models</span><br></pre></td></tr></table></figure>

<p>要引用所创建的 Python 代码文件，我们还应添加models&#x2F;<strong>init</strong>.py文件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">from . import library_book</span><br></pre></td></tr></table></figure>

<p>现在我们可以在models&#x2F;library_book.py中加入如下内容：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">from odoo import fields, models</span><br><span class="line"></span><br><span class="line">class Book(models.Model):</span><br><span class="line">    _name = &#x27;library.book&#x27;</span><br><span class="line">    _description = &#x27;Book&#x27;</span><br><span class="line">    name = fields.Char(&#x27;Title&#x27;, required=True)</span><br><span class="line">    isbn = fields.Char(&#x27;ISBN&#x27;)</span><br><span class="line">    active = fields.Boolean(&#x27;Active?&#x27;, default=True)</span><br><span class="line">    date_published = fields.Date()</span><br><span class="line">    image = fields.Binary(&#x27;Cover&#x27;)</span><br><span class="line">    publisher_id = fields.Many2one(&#x27;res.partner&#x27;, string=&#x27;Publisher&#x27;)</span><br><span class="line">    author_ids = fields.Many2many(&#x27;res.partner&#x27;, string=&#x27;Authors&#x27;)</span><br></pre></td></tr></table></figure>

<p>第一行是 Python 代码导入语句，让 Odoo 内核的models和fields对象在这里可用。紧接着声明了新的模型，它是models.Model派生出的一个类。然后_name 属性定义了 Odoo 全局对该模型引用的标识符。注意Python 类名 Book 与框架无关，_name 的值才是模型的标识符。</p>
<blockquote>
<p><strong>小贴士：</strong> 仅有模型名使用点号(.) 来分割关键字，其它如模块、XML 标识符、数据表名等都使用下划线(_)。</p>
</blockquote>
<p>注意下面的行都有缩进，对 Python 不熟悉的朋友要知道这很重要：相同缩进代表同一代码块，所以下面的行应采用相同缩进。</p>
<p>_description属性不是必须的，但为模型记录提供了一个用户友好的名称，可用作更好的用户消息。该行之后定义了模型的不同字段 ，值得一提的是name和active为特殊字段名。默认在其它模型中引用模型时，会使用 name 字段作为记录的标题。</p>
<p>active 字段用于激活记录，默认仅 active 记录会显示。对于日期模型这非常有用，隐藏掉那些用户在日常操作中不再使用的记录（因历史原因仍需保留在数据库中）。在本项目中，用于标识图书是否可用。</p>
<p>再来看看其它字段，date_published是一个图书出版日的日期字段，image 是一个存储图书封面的二进制字段。还有一些关联字段：publisher_id是一个出版公司多对一关联，author_ids是作者多对多关联。都是图书与 partner 模型的关联，partner 模型内置于 Odoo 框架中，用户、公司和地址都存储在这里。我们使用它存储出版商和作者。</p>
<p>字段就是这些，要使代码修改生效，需更新模块来触发数据库中相应对象的创建。菜单中还无法访问这一模型，因为我们还没有添加。不过可以通过 Technical 菜单来检查新建模型。访问 Settings &gt; Technical &gt; Database Structure &gt; Models（需开启开发者模式），在列表中搜索library.book，然后点击查看模型定义：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/53878422c0054aa69ebb088ab646b9c5~tplv-k3u1fbpfcp-zoom-1.image" alt="Odoo 12图书模型定义"></p>
<p>如查看一切顺利，说明模型和字段都被正常创建，如果你看不到这些，尝试重启服务升级模型。我们还可以看到一些未声明的字段，这些是 Odoo 自动为新模型添加的保留字段，这些字段有：</p>
<ul>
<li>id是模型中每条记录的唯一数字标识符</li>
<li>create_date和create_uid分别为记录创建时间和创建者</li>
<li>display_name为所使用的记录提供文本显示，如其它记录引用它，它就会被计算并默认使用 name 字段中的文本</li>
<li>write_date和write_uid分别表示最后修改时间和修改者</li>
<li>__last_update是一个助手字段 ，它不存储在数据库，用于做并发检测</li>
</ul>
<h2 id="设置访问权限"><a href="#设置访问权限" class="headerlink" title="设置访问权限"></a>设置访问权限</h2><p>在加载服务时，你可能会注意到输出日志中有一条警告信息：</p>
<p>The model library.book has no access rules, consider adding one.</p>
<p>提示消息已经很明确了，我们的新模型没有访问规则，所以任何人都可使用。我们已为应用添加了安全组，现在就为模块授权。</p>
<blockquote>
<p><strong>ℹ️</strong>在 Odoo 12以前，admin 可自动访问所有数据模型，它是一个不受权限控制的超级用户。在 Odoo 12中则不再如此，需要在新模型中设置 ACL才对 admin 可见。</p>
</blockquote>
<h3 id="添加访问权限控制"><a href="#添加访问权限控制" class="headerlink" title="添加访问权限控制"></a>添加访问权限控制</h3><p>要了解需要哪些信息来为模型添加权限，可访问后台Settings &gt; Technical &gt; Security &gt; Access Rights：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/891bda81421c4066ad1235504483dd90~tplv-k3u1fbpfcp-zoom-1.image" alt="Odoo 12访问权限"></p>
<p>这里可以看到一些模型的 ACL(Access Control List)，表示允许每个安全组对记录的操作。这一信息需要通过模块中的数据文件提供，然后载入ir.model.access模型。我们将为 employee 组添加该模型的所有权限，内部用户是几乎所有人隶属的基本权限组。</p>
<blockquote>
<p><strong>ℹ️Odoo 12中的修改</strong><br>User 表单现在有一个用户类型，仅在开启开发者模式时显示。它允许互斥的几个选项：内部用户，portal门户用户（外部用户如客户）和public公共用户（网站匿名访客）。这一修改用于避免把内部用户放到 portal 或 public 组中一类的错误配置，那样会导致权限的丧失。</p>
</blockquote>
<p>权限通过security&#x2F;ir.model.access.csv文件来实现，添加该文件并加入如下内容：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">id,name,model_id:id,group_id:id,perm_read,perm_write,perm_create,perm_unlink</span><br><span class="line">access_book_user,BookUser,model_library_book,library_group_user,1,0,0,0</span><br><span class="line">access_book_manager,BookManager,model_library_book,library_group_manager,1,1,1,1</span><br></pre></td></tr></table></figure>

<p>注：应注意该文件第一行后不要留有空格，否则会导致报错</p>
<p>文件名必须与要载入的模型对应，第一行为列名，CSV 文件中有如下列：</p>
<ul>
<li>id是记录的外部标识符（也称为XML ID），需在模块中唯一</li>
<li>name是描述性标题，仅在保证唯一时提供有用信息</li>
<li>model_id是赋权模型的外部标识符，模型有ORM自动生成的XML ID，对于library.book，标识符为model_library_book</li>
<li>group_id指明授权的安全组，我们给前文创建的安全组授权：library_group_user和library_group_manager</li>
<li>perm_…字段标记read读, write写, create创建, 或unlink删除权限，我们授予普通用户读权限、管理员所有权限</li>
</ul>
<p>还应记得在__manifest__.py的 data 属性中添加对新文件的引用，修改后如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x27;data&#x27;: [</span><br><span class="line">    &#x27;security/library_security.xml&#x27;,</span><br><span class="line">    &#x27;security/ir.model.access.csv&#x27;,</span><br><span class="line">    &#x27;views/library_menu.xml&#x27;,</span><br><span class="line">],</span><br></pre></td></tr></table></figure>

<p>老规矩升级模块让修改生效，此时警告信息就不见了。我们通过 admin登录来检测权限是否正确，admin 属于图书管理员组。</p>
<h3 id="行级权限规则"><a href="#行级权限规则" class="headerlink" title="行级权限规则"></a>行级权限规则</h3><p>我们知道默认 active 标记为 False 的记录不可见，但用户在需要时可使用过滤器来访问这些记录。假设我们不希望普通图书用户访问无效图书，可通过记录规则来实现，即定义过滤器来限制某权限组所能访问的记录。这位于Settings &gt; Technical &gt; Security &gt; Record Rules。</p>
<p>记录规则在ir.rule中定义，和往常一样我们选择一个唯一名称。还应获取操作的模型及使用权限限制的域过滤器。域过滤器使用 Odoo 中常用的元组列表，在第八章 <a target="_blank" rel="noopener" href="https://alanhou.org/odoo12-business-logic/">Odoo 12开发之业务逻辑 - 业务流程的支持</a>将讲解域表达式语法。</p>
<p>通常，规则应用于指定安全组，我们这里应用的是雇员组。如果没有指定的安全组，则应用于全局(global 字段自动设为 True)。全局规则不同，它们做的限制非全局规则无法重载。</p>
<p>要添加记录规则，需编辑security&#x2F;library_security.xml文件添加如下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;data noupdate=&quot;1&quot;&gt;</span><br><span class="line">    &lt;record id=&quot;book_user_rule&quot; model=&quot;ir.rule&quot;&gt;</span><br><span class="line">        &lt;field name=&quot;name&quot;&gt;Library Book User Access&lt;/field&gt;</span><br><span class="line">        &lt;field name=&quot;model_id&quot; ref=&quot;model_library_book&quot; /&gt;</span><br><span class="line">        &lt;field name=&quot;domain_force&quot;&gt;</span><br><span class="line">            [(&#x27;active&#x27;,&#x27;=&#x27;,True)]</span><br><span class="line">        &lt;/field&gt;</span><br><span class="line">        &lt;field name=&quot;groups&quot; eval=&quot;[(4,ref(&#x27;library_group_user&#x27;))]&quot; /&gt;</span><br><span class="line">    &lt;/record&gt;</span><br><span class="line">&lt;/data&gt;</span><br></pre></td></tr></table></figure>

<p>记录规则位于<data noupdate="1">元素中，表示这些记录在模型安装时会被创建，但在模型更新时不会被重写。这么做是允许对规则在后面做自定义但避免在执行模型升级时自定义内容丢失。</p>
<blockquote>
<p><strong>小贴士：</strong> 开发过程noupdate&#x3D;”1”会带来麻烦，因为要修复规则时模块更新不会在数据库中重写数据。所以在开发时可以修改为noupdate&#x3D;”0”来让数据达到预期结果。</p>
</blockquote>
<p>在 groups 字段中，会发现有一个特殊表达式，这是一个带有特殊语法的one-to-many关联字段。元组(4, x)表示x应添加到记录中，此处 x 为一个标记为base.group_user的内部用户组引用。针对多个字段的这种特殊语法在第六章 <a target="_blank" rel="noopener" href="https://alanhou.org/odoo12-structuring-data/">Odoo 12开发之模型 - 结构化应用数据</a>中探讨。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9d920852bf054a729ac620149c37de9f~tplv-k3u1fbpfcp-zoom-1.image" alt="Odoo 12记录规则"></p>
<h2 id="视图层"><a href="#视图层" class="headerlink" title="视图层"></a>视图层</h2><p>视图层为用户界面的描述，视图用 XML 定义，由网页客户端框架生成数据感知的 HTML 视图。可用菜单项开启渲染视图的操作。比如，Users 菜单项处理一个同样名为 Users 的操作，然后渲染一系列视图。有多种可用视图类型，如 list(因历史原因也称为 tree)列表视图和 form表单视图，以及包含过滤项的右上角搜索框由 search 搜索视图定义。</p>
<p>Odoo 开发指南写到定义用户界面的 XML 文件应放在views&#x2F;子目录中。接下我们来创建图书应用的用户界面。下面我们会逐步改进并更新模块来使更改生效。可以使用–dev&#x3D;all参数来在开发时频繁的升级。使用该参数，视图定义会在 XML 文件中直接读取，无需升级模块即可在 Odoo 中即刻生效。</p>
<blockquote>
<p><strong>小贴士：</strong> 如果因 XML 错误升级失败，不必惊慌！仔细阅读输出日志的错误信息，就可以找到问题所在。如果觉得麻烦，注释掉最近编辑的 XML 版块或删除__manifest__.py中 该XML 文件，重新更新，服务应该就可正确启动了。</p>
</blockquote>
<h3 id="添加菜单项"><a href="#添加菜单项" class="headerlink" title="添加菜单项"></a>添加菜单项</h3><p>现在有了存储数据的模型，需要添加到用户界面中。首先要做的就是添加相应菜单项。编辑views&#x2F;library_menu.xml文件，在 XML 元素中定义菜单项以及执行的操作：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- Action to open the Book list --&gt;</span><br><span class="line">&lt;act_window id=&quot;action_library_book&quot;</span><br><span class="line">    name=&quot;Library Books&quot;</span><br><span class="line">    res_model=&quot;library.book&quot;</span><br><span class="line">    view_mode=&quot;tree,form&quot;</span><br><span class="line">/&gt;</span><br><span class="line">&lt;!-- Menu item to open the Book list --&gt;</span><br><span class="line">&lt;menuitem id=&quot;menu_library_book&quot;</span><br><span class="line">    name=&quot;Books&quot;</span><br><span class="line">    parent=&quot;menu_library&quot;</span><br><span class="line">    action=&quot;action_library_book&quot;</span><br><span class="line">/&gt;</span><br></pre></td></tr></table></figure>

<p>用户界面，包括菜单项和操作，存储在数据表中。在安装或升级插件模块时，XML文件会将这些定义载入数据库中的数据文件。以上代码是一个 Odoo 数据文件，表示两条添加到 Odoo 的记录：</p>
<ul>
<li><act_window>元素定义客户端窗口操作，它按顺序通过启用列表和表单视图打开library.book 模型</li>
<li><menuitem>定义一个调用前面定义的action_library_book操作的顶级菜单项</li>
</ul>
<p>现在再次升级模块来让修改生效。然后刷新浏览器页面，就可以看到Library顶级菜单，并包含一个子菜单项。点击该菜单会显示一个基本列表视图，记录可通过一个自动生成的表单视图进行编辑。点击 Create 按钮即可查看：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d121aad0b5234d4fba1b21ebbafe332a~tplv-k3u1fbpfcp-zoom-1.image" alt="Odoo 12图书项目表单视图"></p>
<p>虽然我们还没有定义用户界面视图，自动生成的列表视图和表单视图也可以使用，允许我们马上编辑数据。</p>
<h3 id="创建表单视图"><a href="#创建表单视图" class="headerlink" title="创建表单视图"></a>创建表单视图</h3><p>所有的视图都存储在数据库ir.ui.view模型中。为模型添加视图，我们在 XML文件中声明<record>元素来描述视图，在模块安装时 XML 文件会被载入数据库。</p>
<p>添加views&#x2F;book_view.xml文件来定义表单视图：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot;?&gt;</span><br><span class="line">&lt;odoo&gt;</span><br><span class="line">    &lt;record id=&quot;view_form_book&quot; model=&quot;ir.ui.view&quot;&gt;</span><br><span class="line">        &lt;field name=&quot;name&quot;&gt;Book Form&lt;/field&gt;</span><br><span class="line">        &lt;field name=&quot;model&quot;&gt;library.book&lt;/field&gt;</span><br><span class="line">        &lt;field name=&quot;arch&quot; type=&quot;xml&quot;&gt;</span><br><span class="line">            &lt;form string=&quot;Book&quot;&gt;</span><br><span class="line">                &lt;group&gt;</span><br><span class="line">                    &lt;field name=&quot;name&quot; /&gt;</span><br><span class="line">                    &lt;field name=&quot;author_ids&quot; widget=&quot;many2many_tags&quot; /&gt;</span><br><span class="line">                    &lt;field name=&quot;publisher_id&quot; /&gt;</span><br><span class="line">                    &lt;field name=&quot;date_published&quot; /&gt;</span><br><span class="line">                    &lt;field name=&quot;isbn&quot; /&gt;</span><br><span class="line">                    &lt;field name=&quot;active&quot; /&gt;</span><br><span class="line">                    &lt;field name=&quot;image&quot; widget=&quot;image&quot; /&gt;</span><br><span class="line">                &lt;/group&gt;</span><br><span class="line">            &lt;/form&gt;</span><br><span class="line">        &lt;/field&gt;</span><br><span class="line">    &lt;/record&gt;</span><br><span class="line">&lt;/odoo&gt;</span><br></pre></td></tr></table></figure>

<p>这个ir.ui.view记录有三个字段值：name, model和 arch。另一个重要元素是记录 id，它定义了一个可在其它记录中引用的XML ID标识符。这是library.book 模型的视图，名为Book Form。这个名称仅用于提供信息，无需唯一，但应易于分辨所引用的记录。其实可以完全省略 name，这种情况下会自动按模型名和视图类型来生成。</p>
<p>最重要的字段是arch，它包含了视图的定义，在 XML 代码中我们做了高亮显示（博客主题问题无法显示）。<form>标签定义了视图类型并包含视图结构。</p>
<p>此处<form>中包含了要在表单中显示的字段。这些字段会自动使用默认的组件，如 date 字段使用日期选择组件。有时我们要使用不同的组件，如以上代码中的author_ids使用了显示标签列表的组件，image字段使用处理图片的相应组件。有关视图元素的详细说明请见第十章 <a target="_blank" rel="noopener" href="https://alanhou.org/odoo12-backend-views/">Odoo 12开发之后台视图 - 设计用户界面</a>。</p>
<p>不要忘记在声明文件的 data 中加入新建文件，否则我们的模块将无法识别到并加载该文件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x27;data&#x27;: [</span><br><span class="line">    &#x27;security/library_security.xml&#x27;,</span><br><span class="line">    &#x27;security/ir.model.access.csv&#x27;,</span><br><span class="line">    &#x27;views/library_menu.xml&#x27;,</span><br><span class="line">    &#x27;views/book_view.xml&#x27;,</span><br><span class="line">],</span><br></pre></td></tr></table></figure>

<p>要使修改载入 Odoo 数据库就需要更新模块。需要重新加载页面来查看修改效果，可以再次点击菜单项或刷新网页（大多数浏览器中快捷键为 F5）。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8d58e130fe774646975a564382dfe071~tplv-k3u1fbpfcp-zoom-1.image" alt="Odoo 12图书项目修改后表单视图"></p>
<h3 id="业务文件表单视图"><a href="#业务文件表单视图" class="headerlink" title="业务文件表单视图"></a>业务文件表单视图</h3><p>上面的部分创建了一个基础表单视图，还可以做一些改进。对于文件模型，Odoo 有一个模拟纸张的展示样式，表单包含两个元素：<header>来包含操作按钮和<sheet>来包含数据字段。可以修改上一部分的基础<form>定义为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;form string=&quot;Book&quot;&gt;</span><br><span class="line">    &lt;header&gt;</span><br><span class="line">        &lt;!-- 此处添加按钮 --&gt;</span><br><span class="line">    &lt;/header&gt;</span><br><span class="line">    &lt;sheet&gt;</span><br><span class="line">        &lt;group&gt;</span><br><span class="line">            &lt;field name=&quot;name&quot; /&gt;</span><br><span class="line">            ...</span><br><span class="line">        &lt;/group&gt;</span><br><span class="line">    &lt;/sheet&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure>

<h3 id="添加操作按钮"><a href="#添加操作按钮" class="headerlink" title="添加操作按钮"></a>添加操作按钮</h3><p>表单可带有执行操作的按钮。这些按钮可用于运行窗口操作，如打开另一个表单或执行模型中定义的 Python 方法。按钮可以放在表单的任意位置，但对于文件样式表单，推荐的位置是<header>中。</p>
<p>我们的应用会添加图书 ISBN，和一个用于检测 ISBN 有效性的按钮。代码将放在 Book 模型中，我们将该方法命名为button_check_isbn()。虽然还未创建该方法，我们现在可以在表单中先添加相应按钮：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;header&gt;</span><br><span class="line">    &lt;button name=&quot;button_check_isbn&quot; type=&quot;object&quot;</span><br><span class="line">        string=&quot;Check ISBN&quot; /&gt;</span><br><span class="line">&lt;/header&gt;</span><br></pre></td></tr></table></figure>

<p>一个按钮的基本属性有：</p>
<ul>
<li>string：定义按钮显示文本</li>
<li>type：执行的操作类型</li>
<li>name：操作的标识符</li>
<li>class：应用 CSS 样式的可选属性，与 HTML 相同</li>
</ul>
<h3 id="使用组来组织表单"><a href="#使用组来组织表单" class="headerlink" title="使用组来组织表单"></a>使用组来组织表单</h3><p><group>标签可用于组织表单内容。在<group>元素内加<group>会在外层组中创建一个两列布局。推荐在group 元素中添加 name 属性，更易于其它模块对其进行继承。我们使用该标签来组织内容，修改<sheet>内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;sheet&gt;</span><br><span class="line">    &lt;group name=&quot;group_top&quot;&gt;</span><br><span class="line">        &lt;group name=&quot;group_left&quot;&gt;</span><br><span class="line">            &lt;field name=&quot;name&quot; /&gt;</span><br><span class="line">            &lt;field name=&quot;author_ids&quot; widget=&quot;many2many_tags&quot; /&gt;</span><br><span class="line">            &lt;field name=&quot;publisher_id&quot; /&gt;</span><br><span class="line">            &lt;field name=&quot;date_published&quot; /&gt;</span><br><span class="line">        &lt;/group&gt;</span><br><span class="line">        &lt;group name=&quot;group_right&quot;&gt;</span><br><span class="line">            &lt;field name=&quot;isbn&quot; /&gt;</span><br><span class="line">            &lt;field name=&quot;active&quot; /&gt;</span><br><span class="line">            &lt;field name=&quot;image&quot; widget=&quot;image&quot; /&gt;</span><br><span class="line">        &lt;/group&gt;</span><br><span class="line">    &lt;/group&gt;</span><br><span class="line">&lt;/sheet&gt;</span><br></pre></td></tr></table></figure>

<h3 id="完整表单视图"><a href="#完整表单视图" class="headerlink" title="完整表单视图"></a>完整表单视图</h3><p>此时library.book的表单视图代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;form string=&quot;Book&quot;&gt;</span><br><span class="line">    &lt;header&gt;</span><br><span class="line">        &lt;button name=&quot;button_check_isbn&quot; type=&quot;object&quot;</span><br><span class="line">            string=&quot;Check ISBN&quot; /&gt;</span><br><span class="line">    &lt;/header&gt;</span><br><span class="line">    &lt;sheet&gt;</span><br><span class="line">        &lt;group name=&quot;group_top&quot;&gt;</span><br><span class="line">            &lt;group name=&quot;group_left&quot;&gt;</span><br><span class="line">                &lt;field name=&quot;name&quot; /&gt;</span><br><span class="line">                &lt;field name=&quot;author_ids&quot; widget=&quot;many2many_tags&quot; /&gt;</span><br><span class="line">                &lt;field name=&quot;publisher_id&quot; /&gt;</span><br><span class="line">                &lt;field name=&quot;date_published&quot; /&gt;</span><br><span class="line">            &lt;/group&gt;</span><br><span class="line">            &lt;group name=&quot;group_right&quot;&gt;</span><br><span class="line">                &lt;field name=&quot;isbn&quot; /&gt;</span><br><span class="line">                &lt;field name=&quot;active&quot; /&gt;</span><br><span class="line">                &lt;field name=&quot;image&quot; widget=&quot;image&quot; /&gt;</span><br><span class="line">            &lt;/group&gt;</span><br><span class="line">        &lt;/group&gt;</span><br><span class="line">    &lt;/sheet&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure>

<p>按钮还无法使用，需要先添加业务逻辑。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/231899c03e2e439fb1e98a4ce61a9078~tplv-k3u1fbpfcp-zoom-1.image" alt="Odoo 12图书项目分组加按钮表单视图"></p>
<h3 id="添加列表视图和搜索视图"><a href="#添加列表视图和搜索视图" class="headerlink" title="添加列表视图和搜索视图"></a>添加列表视图和搜索视图</h3><p>以列表模式显示模型需要使用视图。树状视图可以按层级显示，但大多数情况下仅需显示为普通列表。</p>
<p>可以在book_view.xml文件中添加<tree>视图：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;record id=&quot;view_tree_book&quot; model=&quot;ir.ui.view&quot;&gt;</span><br><span class="line">    &lt;field name=&quot;name&quot;&gt;Book List&lt;/field&gt;</span><br><span class="line">    &lt;field name=&quot;model&quot;&gt;library.book&lt;/field&gt;</span><br><span class="line">    &lt;field name=&quot;arch&quot; type=&quot;xml&quot;&gt;</span><br><span class="line">        &lt;tree&gt;</span><br><span class="line">            &lt;field name=&quot;name&quot; /&gt;</span><br><span class="line">            &lt;field name=&quot;author_ids&quot; widget=&quot;many2many_tags&quot; /&gt;</span><br><span class="line">            &lt;field name=&quot;publisher_id&quot; /&gt;</span><br><span class="line">            &lt;field name=&quot;date_published&quot; /&gt;</span><br><span class="line">        &lt;/tree&gt;</span><br><span class="line">    &lt;/field&gt;</span><br><span class="line">&lt;/record&gt;</span><br></pre></td></tr></table></figure>

<p>以上定义了一个含有四列的列表：name, author_ids, publisher_id和 date_published。在该列表的右上角，Odoo 显示了一个搜索框。搜索的字段和可用过滤器也由视图定义。同样还在book_view.xml文件中添加：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;record id=&quot;view_search_book&quot; model=&quot;ir.ui.view&quot;&gt;</span><br><span class="line">    &lt;field name=&quot;name&quot;&gt;Book Filters&lt;/field&gt;</span><br><span class="line">    &lt;field name=&quot;model&quot;&gt;library.book&lt;/field&gt;</span><br><span class="line">    &lt;field name=&quot;arch&quot; type=&quot;xml&quot;&gt;</span><br><span class="line">        &lt;search&gt;</span><br><span class="line">            &lt;field name=&quot;publisher_id&quot; /&gt;</span><br><span class="line">            &lt;filter name=&quot;filter_active&quot;</span><br><span class="line">                string=&quot;Active&quot;</span><br><span class="line">                domain=&quot;[(&#x27;active&#x27;,&#x27;=&#x27;,True)]&quot; /&gt;</span><br><span class="line">           &lt;filter name=&quot;filter_inactive&quot;</span><br><span class="line">                string=&quot;Inactive&quot;</span><br><span class="line">                domain=&quot;[(&#x27;active&#x27;,&#x27;=&#x27;,False)]&quot; /&gt;</span><br><span class="line">        &lt;/search&gt;</span><br><span class="line">    &lt;/field&gt;</span><br><span class="line">&lt;/record&gt;</span><br></pre></td></tr></table></figure>

<p><field>元素定义在搜索框中输入搜索的字段，这里添加了publisher_id自动提示出版商字段。<filter>元素添加预定义过滤条件，用户通过点击来切换，它使用了特殊的语法，在第十章 <a target="_blank" rel="noopener" href="https://alanhou.org/odoo12-backend-views/">Odoo 12开发之后台视图 - 设计用户界面</a>中将会进一步介绍。</p>
<blockquote>
<p><strong>ℹ️Odoo 12中的修改</strong><br><filter>现在要求包含name&#x3D;”…”属性，唯一标识每个过滤器，如果不写，验证会失败，模块将无法安装或升级。</p>
</blockquote>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5c10cdf86f3b442abebe3ee603987e8e~tplv-k3u1fbpfcp-zoom-1.image" alt="Odoo 12图书应用列表视图"></p>
<h2 id="业务逻辑层"><a href="#业务逻辑层" class="headerlink" title="业务逻辑层"></a>业务逻辑层</h2><p>业务逻辑层编写应用的业务规则，如验证和自动计算。现在我们来为按钮添加逻辑，通过在模型 Python 类中编写方法来实现。</p>
<h3 id="添加业务逻辑"><a href="#添加业务逻辑" class="headerlink" title="添加业务逻辑"></a>添加业务逻辑</h3><p>上文中我们在 Book表单中添加了一个按钮，用于检查 ISBN 是否有效。现代 ISBN 包含13位数字，最后一位是由前12位计算所得的检查位。我们无需深入到算法的细节，这里是一个实现验证的 Python 方法。应当在class Book(…)中进行添加：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@api.multi</span><br><span class="line">def _check_isbn(self):</span><br><span class="line">    self.ensure_one() </span><br><span class="line">    isbn = self.isbn.replace(&#x27;-&#x27;, &#x27;&#x27;) # 为保持兼容性 Alan 自行添加</span><br><span class="line">    digits = [int(x) for x in isbn if x.isdigit()]</span><br><span class="line">    if len(digits) == 13:</span><br><span class="line">        ponderations = [1, 3] * 6</span><br><span class="line">        terms = [a * b for a,b in zip(digits[:12], ponderations)]</span><br><span class="line">        remain = sum(terms) % 10</span><br><span class="line">        check = 10 - remain if remain !=0 else 0</span><br><span class="line">        return digits[-1] == check</span><br></pre></td></tr></table></figure>

<p>图书模型的button_check_isbn()方法应使用该函数来验证 ISBN 字段中的数字，如果验证失败，应向用户显示警告信息。</p>
<p>首先要导入 Odoo API库，添加对应的 import 及 Odoo Warning异常。这需要编辑library_book.py文件修改前两行为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">from odoo import api, fields, models</span><br><span class="line">from odoo.exceptions import Warning</span><br></pre></td></tr></table></figure>

<p>然后还是在models&#x2F;library_book.py文件Book 类中加入：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@api.multi</span><br><span class="line">def button_check_isbn(self):</span><br><span class="line">    for book in self:</span><br><span class="line">        if not book.isbn:</span><br><span class="line">            raise Warning(&#x27;Please provide an ISBN for %s&#x27; % book.name)</span><br><span class="line">        if book.isbn and not book._check_isbn():</span><br><span class="line">            raise Warning(&#x27;%s is an invalid ISBN&#x27; % book.isbn)</span><br><span class="line">        return True</span><br></pre></td></tr></table></figure>

<p>对于记录的逻辑，我们使用@api.multi装饰器。此处 self 表示一个记录集，然后我们遍历每一条记录。其实@api.multi装饰器可以不写，因为这是模型方法的默认值。这里保留以示清晰。代码遍历所有已选图书，对于每本书，如果 ISBN 有值，则检查有效性，若无值，则向用户抛出一条警告消息。</p>
<p>模型方法无需返回值，但此处需至少返回 True 值。因为不是所有XML-RPC客户端实现都支持None&#x2F;Null空值，这种情况若返回空值则会导致抛出错误。此时可更新模块并再次运行测试，添加–test-enable参数来确定测试是否通过。也可以在线测试，进入 Book 表单使用正确和错误的 ISBN点击按钮进行测试。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e8b05164b5ac434abac25ac495ce3bd9~tplv-k3u1fbpfcp-zoom-1.image" alt="Odoo 12自动化测试"></p>
<h2 id="网页和控制器"><a href="#网页和控制器" class="headerlink" title="网页和控制器"></a>网页和控制器</h2><p>Odoo 还提供了一个 web 开发框架，可用于开发与后台应用深度集成的功能。第一步我们来创建一个显示有效图书列表的简单网页。在请求http:&#x2F;&#x2F;<my-server>&#x2F;library&#x2F;books页面时会进行响应，所以&#x2F;library&#x2F;books是用于实施的 URL。这里我们简短地了解下 Odoo 网页开发，这一话题在第十三章 <a target="_blank" rel="noopener" href="https://alanhou.org/odoo12-frontend/">Odoo 12开发之创建网站前端功能</a>中会深入探讨。</p>
<p>Web控制器是负责渲染网页的组件。控制器是http.Controller中定义的方法，与URL链接(endpoint)绑定。 访问 URL 时执行控制器代码，生成向用户展示的 HTML。我们使用 QWeb 模板引擎方便HTML的渲染。</p>
<p>按惯例控制器代码放在&#x2F;controllers子目录中，首先编辑library_app&#x2F;<strong>init</strong>.py导入控制器模块目录：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">from . import models</span><br><span class="line">from . import controllers</span><br></pre></td></tr></table></figure>

<p>然后添加library_app&#x2F;controllers&#x2F;<strong>init</strong>.py文件来让目录可被 Python 导入，并在该文件中添加：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">from . import main</span><br></pre></td></tr></table></figure>

<p>接下来就要创建真实的控制器文件library_app&#x2F;controllers&#x2F;main.py，并添加如下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">from odoo import http</span><br><span class="line"></span><br><span class="line">class Books(http.Controller):</span><br><span class="line"></span><br><span class="line">    @http.route(&#x27;/library/books&#x27;, auth=&#x27;user&#x27;)</span><br><span class="line">    def list(self, **kwargs):</span><br><span class="line">        Book = http.request.env[&#x27;library.book&#x27;]</span><br><span class="line">        books = Book.search([])</span><br><span class="line">        return http.request.render(</span><br><span class="line">            &#x27;library_app.book_list_template&#x27;, &#123;&#x27;books&#x27;:books&#125;)</span><br></pre></td></tr></table></figure>

<p>这里导入的odoo.http模块，是提供网页相关功能的核心组件。http.Controller是需要继承的类控制器，这里在主控制器类中使用。我们选择的类名和方法并不关联，@http.route装饰器才是重要的部分，它声明了与类方法关联的 URL 地址，此处为&#x2F;books。默认访问 URL 地址要求客户登录，推荐明确指出访问的授权模式，所以这里添加了auth&#x3D;’user’参数。要允许公开访问，可为@http.route 添加auth&#x3D;’public’ 参数。</p>
<blockquote>
<p><strong>小贴士：</strong> 如果使用auth&#x3D;’public’，控制器代码中在进行图书搜索前应使用sudo() 进行提权。这部分在第十三章 <a target="_blank" rel="noopener" href="https://alanhou.org/odoo12-frontend/">Odoo 12开发之创建网站前端功能</a>会进一步讨论。</p>
</blockquote>
<p>在这个控制器方法中，我们使用http.request.env获取环境，使用它可从目录中获取有效图书记录集。最后一步是使用http.request.render() 来处理 library_app.index_template Qweb 模板并生成输出 HTML。可通过字典向模板传值，这里传递了图书记录集。</p>
<p>这时如果重启 Odoo 服务来重载 Python 代码，并访问&#x2F;library&#x2F;books会得到一个错误日志：ValueError: External ID not found in the system: library_app.book_list_template。这是因为我们还没有定义模板。下面就一起来定义模板。</p>
<p>QWeb模板是一个视图类型，应放在&#x2F;views子目录下，我们来创建views&#x2F;book_list_template.xml文件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;odoo&gt;</span><br><span class="line">    &lt;template id=&quot;book_list_template&quot; name=&quot;Book List&quot;&gt;</span><br><span class="line">        &lt;div id=&quot;wrap&quot; class=&quot;container&quot;&gt;</span><br><span class="line">            &lt;h1&gt;Books&lt;/h1&gt;</span><br><span class="line">            &lt;t t-foreach=&quot;books&quot; t-as=&quot;book&quot;&gt;</span><br><span class="line">                &lt;div class=&quot;row&quot;&gt;</span><br><span class="line">                    &lt;span t-field=&quot;book.name&quot; /&gt;,</span><br><span class="line">                    &lt;span t-field=&quot;book.date_published&quot; /&gt;,</span><br><span class="line">                    &lt;span t-field=&quot;book.publisher_id&quot; /&gt;</span><br><span class="line">                &lt;/div&gt;</span><br><span class="line">            &lt;/t&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    &lt;/template&gt;</span><br><span class="line">&lt;/odoo&gt;</span><br></pre></td></tr></table></figure>

<p><template>元素用于声明 QWeb 模板，它事实上是一个存储模块的 base 模型 - ir.ui.view记录的快捷方式。模板中包含要使用的 HTML，并使用 Qweb 的特定属性：t-foreach用于遍历变量 books的每一项，通过控制器的http.request.render()调用来获取；t-field用于渲染记录字段的内容。这里仅简单地使用 QWeb，更多详情见第十三章 <a target="_blank" rel="noopener" href="https://alanhou.org/odoo12-frontend/">Odoo 12开发之创建网站前端功能</a>。</p>
<p>在模块的 manifest 中需要声明该 XML 文件来供加载和使用。进行模块升级即可通过http:&#x2F;&#x2F;<my-server>:8069&#x2F;library&#x2F;books来访问有效图书的简单列表。</p>
<p><a target="_blank" rel="noopener" href="http://alanhou.org/homepage/wp-content/uploads/2019/01/book-list.jpg"><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/73e3abf18e604b82b0a0aeff1e6e83f4~tplv-k3u1fbpfcp-zoom-1.image" alt="Odoo 12图书项目图书列表"></a></p>
<p>注：以上数据为从 Packt 的 Top 20中添加了当前前3</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文中我们从0开始创建了一个新模块，了解了模块中常用的元素：模型、三个基础视图类型（表单视图、列表视图和搜索视图）、模型方法中的业务逻辑和访问权限。我们还学习了访问权限控制，包括记录规则以及如何使用网页控制器和 Qweb 模板来创建网页。</p>
<p>在学习过程中，我们熟悉了模块开发过程，包含模块升级和应用服务重启来使得修改在 Odoo 中生效。不要忘记在添加模块字段时需要进行更新操作。修改含声明在内的 Python 文件需要重启服务。修改XML或CSV文件需进行更新，一旦不确定，同时进行重启服务和升级模块操作。</p>
<p>我们已经学习创建 Odoo 应用的基本元素和步骤，但大多数情况下，我们的模块都是对已有应用添加功能来进行扩展，我们将在下一篇文章中一起学习。</p>
<p>☞☞☞第四章 <a target="_blank" rel="noopener" href="https://alanhou.org/odoo12-extending-modules/">Odoo 12 开发之模块继承</a></p>
<h2 id="学霸专区"><a href="#学霸专区" class="headerlink" title="学霸专区"></a>学霸专区</h2><ol>
<li>library-app是正确的模块名吗？</li>
<li>模块是否应为其中所有的模型定义访问控制列表(ACL)？</li>
<li>是否可以让某些用户仅访问一个模型记录的子集？</li>
<li>关联字段和其它字段类型有什么区别？</li>
<li>Odoo 应用中使用的主要视图组件有哪些？</li>
<li>后台视图如何定义？</li>
<li>Odoo 应用中的业务逻辑应在哪里实现？</li>
<li>Odoo 使用的网页模板引擎是什么？</li>
</ol>
<h2 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h2><p>本文中涉及到的所有课题在系列文章后续都会深入介绍。官方文档中的相关资源可以作为补充阅读：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.odoo.com/documentation/12.0/howtos/backend.html">创建模块课程</a></li>
<li><a target="_blank" rel="noopener" href="https://www.odoo.com/documentation/12.0/reference/guidelines.html">Odoo 指南</a>中的一系列编码规则和模块开发指南</li>
<li><a target="_blank" rel="noopener" href="https://github.com/OCA/odoo-community.org/blob/master/website/Contribution/CONTRIBUTING.rst">Odoo 社区联盟(OCA)指南</a>是指导 Odoo 开发最佳实践很好的资源</li>
</ul>
<p>学习 Python 对 Odoo 开发来说也非常重要，在Packt 书录中有一些很好的 Python 图书，如<a target="_blank" rel="noopener" href="https://www.packtpub.com/application-development/learn-python-programming-second-edition">Learn Python Programming – Second Edition</a>。</p>
<p>注：本博客新增<a target="_blank" rel="noopener" href="https://alanhou.org/mastering-python-scripting-system-administrators/">精通Python自动化脚本-运维人员宝典</a>可用于深入Python 脚本的学习。</p>
<p>本文首发地址：<a target="_blank" rel="noopener" href="https://alanhou.org/developer-mode-odoo12/">Alan Hou 的个人博客</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://alanhou.github.io/2019/01/04/odoo-essentials-12-chapter2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Alan Hou">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Alan Hou的个人博客">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Alan Hou的个人博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2019/01/04/odoo-essentials-12-chapter2/" class="post-title-link" itemprop="url">第二章 Odoo 12开发之开发环境准备</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2019-01-04 00:00:00" itemprop="dateCreated datePublished" datetime="2019-01-04T00:00:00+08:00">2019-01-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2023-02-03 13:32:03" itemprop="dateModified" datetime="2023-02-03T13:32:03+08:00">2023-02-03</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>本文为<a target="_blank" rel="noopener" href="https://alanhou.org/developer-mode-odoo12">最好用的免费ERP系统Odoo 12开发手册</a>系列文章第一篇。</p>
<p>本文为<a target="_blank" rel="noopener" href="https://alanhou.org/odoo-12-development/">最好用的免费ERP系统Odoo 12开发手册</a>系列文章第二篇。</p>
<p>在更深入了解 Odoo 开发之前，我们应配置好开发环境并学习相关的基础管理任务。本文中，我们将学习创建 Odoo 应用所需用到的工具和环境配置。这里采用 Ubuntu 系统来作为开发服务器实例的主机，可以是云服务器、本地服务器或者PC 上的虚拟机。</p>
<p>本文主要内容有：</p>
<ul>
<li>配置主机，可以是 Ubuntu系统或 PC 机上的 Linux 子系统</li>
<li>使用源码安装 Odoo，包括数据库和系统依赖的安装</li>
<li>管理 Odoo 数据库（创建、删除和拷贝）</li>
<li>配置 Odoo 服务器选项</li>
<li>查找并安装社区插件</li>
<li>使用虚拟环境管理 Odoo 不同版本和项目</li>
<li>开启服务端开发者模式简化开发任务</li>
</ul>
<h2 id="开发准备"><a href="#开发准备" class="headerlink" title="开发准备"></a>开发准备</h2><p>本文将介绍如何在开发电脑上使用源码安装 Odoo，建议使用系统是Ubuntu 18.04 ，也可以选择 Windows 10，文中会介绍到如何在 Windows 下安装 Linux 子系统。相关代码可参见 <a target="_blank" rel="noopener" href="https://github.com/alanhou/odoo12-development">GitHub 仓库</a>。</p>
<h2 id="设置-Odoo-服务宿主机"><a href="#设置-Odoo-服务宿主机" class="headerlink" title="设置 Odoo 服务宿主机"></a>设置 Odoo 服务宿主机</h2><p>推荐使用Debian&#x2F;Ubuntu来运行 Odoo 服务。虽然 Odoo 是一个跨平台的系统，可以运行在不同的操作系统上，但事实上 Odoo 的研发(R&amp;D)团队把 Debian 系作为参照部署平台。并且 Odoo 自己的 SaaS 平台也运行在 Debian 之上。这也是社区中最主流的选择，说明使用Debian 或 Ubuntu 会更容易寻求到帮助和建议。你也许仅有 Windows 相关背景，但对Debian 系有一定了解也非常重要。</p>
<p>当然你依然可以选择自己喜欢的系统，如 Windows, Mac 或其它Linux发行版本（如 CentOS）。</p>
<blockquote>
<p>ℹ️本文中介绍的是在一个全新的系统中进行开发，如果你在已有系统中开发，请做好备份以在出错时进行恢复</p>
</blockquote>
<h3 id="使用-Windows-子系统安装-Linux"><a href="#使用-Windows-子系统安装-Linux" class="headerlink" title="使用 Windows 子系统安装 Linux"></a>使用 Windows 子系统安装 Linux</h3><p>在 Windows 系统中，最简单的方案是使用 Windows 10自带的Linux子系统(WSL - Windows Subsystem for Linux)。通过子系统，我们可以在 Windows 内运行 Ubuntu 系统，足以应对 Odoo 开发所需的一切。更多 WSL 相关知识请参考<a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows/wsl/about">官网</a>。</p>
<p>WSL 是Windows 10最近发布中的一个可选功能，使用前需要先启用。启用后即可在商店中安装 Ubuntu，详见<a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows/wsl/install-win10">官方帮助文档</a>。</p>
<p>在写本文时，需要如下步骤来完成安装：</p>
<p>第一步是要确保 WSL 功能已开启，以管理员身份打开 PowerShell 并运行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Enable-WindowsOptionalFeature -Online -FeatureName Microsoft-Windows-Subsystem-Linux</span><br></pre></td></tr></table></figure>

<p>以上命令需要在单行执行，然后根据提示重启电脑。然后我们就可以安装Ubuntu Windows应用，最简单地方式是在自带微软商店中搜索 Ubuntu，在写本文时最新的长期支持版本（LTS）是18.04，按照提示进行安装即可。运行 Ubuntu 应用会打开一个bash 命令行，这里可以输入在 Ubuntu 系统中相同的命令。需要记住在安装时配置的用户名和密码，因为在进行提权操作时会要求输入该信息(如运行 sudo 时)。</p>
<h3 id="安装-Linux-服务器"><a href="#安装-Linux-服务器" class="headerlink" title="安装 Linux 服务器"></a>安装 Linux 服务器</h3><p>我们还可以选择在电脑上安装 Linux，或在局域网乃至云端安装 Linux 系统。我们需要一台基于 Debian 的服务器用于 Odoo 服务端开发，如果此前你没有接触过 Linux, 请注意 Ubuntu 是一个基于 Debian 的 Linux 发行版本，所以两者极为相似。Odoo 保证可在当前稳定的 Debian 或 Ubuntu 版本上运行，在写本文时，分别为 Debian 9（Stretch）和Ubuntu 18.04 LTS（Bionic Beaver）。</p>
<p>更推荐选择 Ubuntu，因安装上较 Debian 容易。可从 <a target="_blank" rel="noopener" href="https://www.ubuntu.com/">Ubuntu 官网</a>上下载 ISO 镜像，建议使用最新的 LTS 版本。如果你刚刚接触 Linux，使用预配置的镜像会更容易些。TurnKey Linux提供了含 ISO 的多种格式预安装镜像。ISO 格式可以在任意虚拟化软件上使用，即便是裸机。较优的选择是 <a target="_blank" rel="noopener" href="https://www.turnkeylinux.org/lapp">LAPP 镜像</a>，已安装了 Odoo 所需的Python 和 PostgreSQL。</p>
<p>为能够进行远程操作，通常需安装OpenSSH服务。在 Ubuntu 的设置助手中有这一服务，但也可以通过如下命令来进行安装：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install openssh-server</span><br></pre></td></tr></table></figure>

<p>然后需要使用 SSH（Secure Shell）客户端来连接 Odoo 的宿主机，Windows 中常用的有 <a target="_blank" rel="noopener" href="https://www.putty.org/">PuTTY</a>、<a target="_blank" rel="noopener" href="https://xshell.en.softonic.com/">XShell</a> 和 <a target="_blank" rel="noopener" href="https://www.vandyke.com/products/securecrt/">SecureCRT</a>。</p>
<p>可以通过如下命令来查看服务器的 IP 地址：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ip addr show</span><br></pre></td></tr></table></figure>

<p>使用 SSH 客户端可以远程操作 Linux 主机，还可以获得比在虚拟机终端操作更好的体验，我们可以更容易的复制粘贴、修改窗口大小、字体等。</p>
<p><strong>补充：</strong> 关于虚拟机 Hyper-V,  VMware, VirtualBox和 Vagrant 都是很好的方案，网上有很多资料，限于篇幅本文不再介绍。</p>
<h2 id="源码安装-Odoo"><a href="#源码安装-Odoo" class="headerlink" title="源码安装 Odoo"></a>源码安装 Odoo</h2><p>在本系列文件第一篇<a target="_blank" rel="noopener" href="https://alanhou.org/developer-mode-odoo12/">使用开发者模式快速入门 Odoo 12</a>中，我们介绍了快速运行 Odoo 的各种方式，本文中我们将更深入一步，直接通过源码来安装、运行 Odoo。</p>
<p>Odoo使用Python 编程语言，数据存储使用 PostgreSQL数据库，这是对 Odoo 主机的两大要求。要使用源码运行 Odoo，首先要安装其所依赖的 Python 库。然后从 GitHub 上下载源代码，虽然可以下载 zip 和 tar 文件，但使用 Git版本管理工具获取代码会更优。</p>
<blockquote>
<p>ℹ️具体依赖的安装根据操作系统和安装的 Odoo 版本可能会不同。如果在上述步骤中存在问题，请参考<a target="_blank" rel="noopener" href="https://www.odoo.com/documentation/12.0/setup/install.html">官方文档</a>，可切换版本查看其它版本的操作步骤。</p>
</blockquote>
<h3 id="安装-PostgreSQL-数据库"><a href="#安装-PostgreSQL-数据库" class="headerlink" title="安装 PostgreSQL 数据库"></a>安装 PostgreSQL 数据库</h3><p>Odoo 要使用到 PostgreSQL服务，典型的开发设置是使用安装 Odoo 的同一台机器安装PostgreSQL。下面我们就来安装数据库服务：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo apt update</span><br><span class="line">sudo apt install postgresql -y # 安装PostgreSQL</span><br><span class="line">sudo su -c &quot;createuser -s $USER&quot; postgres # 创建数据库超级用户</span><br></pre></td></tr></table></figure>

<p>最后这条命令为当前系统用户创建了一个PostgreSQL用户，用于 Odoo 实例创建或删除数据库时使用。</p>
<p>如果在 WSL内运行 Ubuntu，注意系统服务不会自动启动。也就是说运行任何需要数据库连接的命令（如createuser或启动 Odoo 服务）时都要手动开启PostgreSQL服务，手动启动PostgreSQL服务执行：sudo service postgresql start。</p>
<h3 id="安装-Odoo-系统依赖"><a href="#安装-Odoo-系统依赖" class="headerlink" title="安装 Odoo 系统依赖"></a>安装 Odoo 系统依赖</h3><p>要运行 Odoo，我们还需要一些系统包和软件。获取版本控制的源码应安装 Git，安装运行 Odoo要求 Python 3.5或之后的版本、Python 3的 pip 以及一些 Python 包的系统依赖：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sudo apt update</span><br><span class="line">sudo apt upgrade</span><br><span class="line">sudo apt install git -y # 安装Git</span><br><span class="line">sudo apt install python3-dev python3-pip -y # Python 3 for dev</span><br><span class="line">sudo apt install build-essential libxslt-dev libzip-dev libldap2-dev libsasl2-dev libssl-dev -y</span><br></pre></td></tr></table></figure>

<p>Odoo 9, 10, and 11版要用到less CSS 预处理器，所以对这些版本需要执行如下安装：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install npm # 安装Node.js和包管理器</span><br><span class="line">sudo ln -s /usr/bin/nodejs /usr/bin/node # 通过node运行Node.js</span><br><span class="line">sudo npm install -g less less-plugin-clean-css # 安装less</span><br></pre></td></tr></table></figure>

<p>Odoo 12中无需执行如上命令，但通常我们也会用到前述版本，如果有此情况则仍需安装。</p>
<blockquote>
<p><strong>ℹ️Odoo 12中的修改</strong><br>CSS 预处理器由 less 改成了 Sass，Sass 编译器无需进行额外安装，在 Odoo 12的 Python 依赖中已经安装了libsass-python。做出这一更改的原因有：Bootstrap 4由 less 调整为 Sass，已有 Python绑定和避免对 Node.js（或 Ruby）的依赖。</p>
</blockquote>
<h3 id="源码安装-Odoo-1"><a href="#源码安装-Odoo-1" class="headerlink" title="源码安装 Odoo"></a>源码安装 Odoo</h3><p>为便于管理，我们将在家目录下创建一个&#x2F;odoo-dev目录作为工作目录。在本系列文章中我们均假设 Odoo 安装在&#x2F;odoo-dev目录下。</p>
<p>Odoo 使用的是 Python 3（3.5或之后的版本），那么在命令行中我们将不再使用python和pip，而是用python3和 pip3。</p>
<blockquote>
<p><strong>ℹ️Odoo 11的修改</strong><br>从版本11开始，Odoo 运行在 Python 3.5及以后的版本上，Odoo 11依然支持 Python 2.7，但 Odoo 12仅能运行在Python 3.5+的环境中。Odoo 10及之前的版本仅可运行在Python 2.7上。</p>
</blockquote>
<p>要从源码安装 Odoo，我们首先要从 GitHub 上克隆一套 Odoo 源代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir ~/odoo-dev # 创建工作目录</span><br><span class="line">cd ~/odoo-dev # 进入工作目录</span><br><span class="line">git clone https://github.com/odoo/odoo.git -b 12.0 --depth=1 # 获取 Odoo 源码</span><br></pre></td></tr></table></figure>

<p>~是用户家目录的简写，比如&#x2F;home&#x2F;alan。</p>
<p>如果使用 WSL Windows 子系统，家目录存放在一个Windows 系统文件夹中一个不易于发现的地方。避免这一情况的一个方法是把工作文件放在常用的文件夹下，然后在子系统中使用软链接（类似 Windows中的快捷方式）。比如mkdir &#x2F;mnt&#x2F;c&#x2F;Users&#x2F;Public&#x2F;odoo-dev创建C:\Users\Public\odoo-dev工作目录，然后ln -s &#x2F;mnt&#x2F;c&#x2F;Users&#x2F;Public&#x2F;odoo-dev <del>&#x2F;odoo-dev创建</del>&#x2F;odoo-dev Linux目录，实际上是 Windows 目录的链接。现在就可以使用~&#x2F;odoo-dev运行所有的命令，比如前述的 git clone，文件将存放在C:\Users\Public\odoo-dev下。</p>
<p>Git命令中的-b 12.0明确表明要下载 Odoo 12.0分支，在写本文时，这显得有些多余，因为这正是当前默认的分支。–depth&#x3D;1表示仅下载当前修订版本，而不是所有历史修改记录，这会使下载更快、内容更少。</p>
<blockquote>
<p><strong>小贴士：</strong> 如需在后续下载历史提交内容，可以运行git fetch –unshallow</p>
</blockquote>
<p>在运行 Odoo 之前，应安装requirements.txt中所声明的 Python 依赖：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip3 install -r ~/odoo-dev/odoo/requirements.txt</span><br></pre></td></tr></table></figure>

<p><strong>补充：</strong> 安装时如因requirements.txt指定了Babel&#x3D;&#x3D;2.3.4而报错，请修改Babel&#x3D;&#x3D;2.3.4为Babel或 Babel&gt;&#x3D;2.3.4后再重新执行以上命令；另内存过小也可能导致不易察觉报错，测试时1G 内存报错，调整为2G 后正常安装</p>
<p>这其中的很多依赖都可以通过 Debian 包安装，如python3-lxml，所以使用 apt 包管理器是一个有效的替代方案。这样的优势是在必要时可以自动安装系统依赖，使用的依赖列表可以在.&#x2F;odoo&#x2F;debian&#x2F;control中找到。</p>
<p>还有一些requirements.txt中未包含的 Python 包，亦可安装来避免警告或用于开启额外的功能：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip3 install num2words phonenumbers psycopg2-binary watchdog xlwt</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>小贴士：</strong> pip3工具可以通过好几种方式安装：系统包的方式和原生 Python 的方式。如果pip3报了 import error，在系统中重新安装或能解决问题。对应的命令为sudo python3 -m pip uninstall pip &amp;&amp; sudo apt install python3-pip –reinstall</p>
</blockquote>
<p>现在，通过如下命令可启动 Odoo 实例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~/odoo-dev/odoo/odoo-bin</span><br></pre></td></tr></table></figure>

<p>如需停止服务并回到命令行，按下 Ctrl + C。</p>
<blockquote>
<p><strong>小贴士：Odoo 10中的修改</strong><br>现在启动 Odoo的脚本是.&#x2F;odoo-bin，而之前的 Odoo 版本中为.&#x2F;odoo.py</p>
</blockquote>
<p>默认Odoo 实例监听8069端口，所以在浏览器中访问http:&#x2F;&#x2F;<server-address>:8069 就可以访问到 Odoo 实例。对于开发者来说，我们会需要使用到多个数据库，所以在命令行中创建会更为方便，后面会介绍如何实现。现在在命令行终端中按下Ctrl + C 停止 Odoo 服务并回到命令行。</p>
<h3 id="初始化新的-Odoo-数据库"><a href="#初始化新的-Odoo-数据库" class="headerlink" title="初始化新的 Odoo 数据库"></a>初始化新的 Odoo 数据库</h3><p>要按照 Odoo 的数据模式创建和初始化 Odoo 数据库，我们应使用-d 参数运行 Odoo 服务：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~/odoo-dev/odoo/odoo-bin -d testdb</span><br></pre></td></tr></table></figure>

<p>初始化 testdb 数据库可能要花上一分钟，一般会以Modules loaded的 INFO 日志信息结束。它有可能不是最后一条日志信息，但在倒数三到四行中可以找到。此时，服务器就可以监听用户请求了。</p>
<blockquote>
<p><strong>ℹ️Odoo 9中的修改</strong><br>从 Odoo 9开始，如果数据库不存在会被自动创建。但在 Odoo 8中并非如此，需使用PostgreSQL命令行中的createdb命令手动创建</p>
</blockquote>
<p>默认情况下，数据库初始化时会带有演示数据，作为开发数据库这通常很有用。相当于在前端创建数据库时勾选了Load demonstration data。如在初始化时无需带有演示数据，在命令行中添加–without-demo&#x3D;all。</p>
<blockquote>
<p><strong>小贴士：</strong> 在写本文时Ubuntu WSL中有一个针对 PostgreSQL 的问题，该环境下无法新建空数据库。一个解决方案是手动通过createdb 12-library命令创建空数据库。这样会重复提示WARNING: could not flush dirty data: Function not implemented。虽然存在警告信息，但数据库正常创建了。按下Ctrl + C停止警告，使用命令行即可启动 Odoo 并初始化数据库。</p>
</blockquote>
<p>当前用户需要是 PostgreSQL 的超级用户才能创建新数据库，前文中在安装过程中已经进行相关操作。</p>
<blockquote>
<p><strong>小贴士：</strong> 对于开发环境，使用数据库超级用户来运行 Odoo 实例毫无问题。但在生产环境中，Odoo最佳安全实践推荐不要使用数据库超级用户权限的用户来运行生产实例。</p>
</blockquote>
<p>Odoo 实例已经运行起来了，现在我们可以通过http:&#x2F;&#x2F;<server-name>:8069在浏览器中进行访问。这时会出现登录界面，如果不知道主机名可以通过 hostname 命令查看或通过 ifconfig 查看 IP 地址。默认管理员的用户名和密码均为 admin。登录后即可看到 Apps菜单，及可安装的应用。</p>
<p>在命令终端中按下Ctrl + C可以停止 Odoo 服务实例并回到命令行。按下上方向键可以回到上一条命令，这样可以通过同样的命令再次快速启动 Odoo。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d5d1ab86cd6d430094d2344479650876~tplv-k3u1fbpfcp-zoom-1.image" alt="Odoo 12后台界面"></p>
<h2 id="管理-Odoo-数据库"><a href="#管理-Odoo-数据库" class="headerlink" title="管理 Odoo 数据库"></a>管理 Odoo 数据库</h2><p>前面我们学习了如何通过命令行创建和初始化 Odoo 数据库。管理数据库还有更多的命令值得我们学习。虽然 Odoo 服务可以自动地进行数据库管理，我们还是可以使用如下命令来手动创建 PostgreSQL 数据库：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">createdb MyDB</span><br></pre></td></tr></table></figure>

<p>更有趣的是，Odoo 可以通过–template 参数拷贝已有数据库来创建新的数据库。要进行这一操作，被拷贝的数据库不能被连接，所以要确保 Odoo 实例已停止并且没有其它应用连接该数据库。命令如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">createdb --template=MyDB MyDB2</span><br></pre></td></tr></table></figure>

<p>事实上，每当创建数据库时都会使用一个模板，如果没有指定模板，会使用一个名为 template1的预设模板。</p>
<p>要在系统中列出已有数据库，需要使用 PostgreSQL 的 psql 工具及-l 参数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">psql -l</span><br></pre></td></tr></table></figure>

<p>执行上述命令会列出我们截至目前所创建的数据库。如果执行了前述操作，可以看到列表中有MyDB和MyDB2。列表中还会显示 每个数据库所使用的编码，默认为UTF-8，这也是 Odoo 所需要的数据库编码。</p>
<p>如需删除数据库，执行dropdb命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dropdb MyDB2</span><br></pre></td></tr></table></figure>

<p>现在我们已学习了数据库的基本知识。要了解更多 PostgreSQL请参见<a target="_blank" rel="noopener" href="https://www.postgresql.org/docs/">官方文档</a>或<a target="_blank" rel="noopener" href="https://alanhou.org/postgresql/">PostgreSQL使用汇总</a>。</p>
<blockquote>
<p><strong>警告：</strong> dropdb操作是不可撤销的，在对重要数据库执行该命令时请务必备份数据库</p>
</blockquote>
<h2 id="其它服务器配置项"><a href="#其它服务器配置项" class="headerlink" title="其它服务器配置项"></a>其它服务器配置项</h2><p>Odoo 服务还支持一些其它参数，可通过–help 来查看更多参数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~/odoo-dev/odoo/odoo-bin --help</span><br></pre></td></tr></table></figure>

<p>我们在下面的部分将会学习一些重要参数，首先我们先学习下如何把当前使用参数保存到配置文件中。</p>
<h3 id="Odoo-服务配置文件"><a href="#Odoo-服务配置文件" class="headerlink" title="Odoo 服务配置文件"></a>Odoo 服务配置文件</h3><p>大多数的参数都可以保存到配置文件中。默认 Odoo 使用.odoorc文件。Linux 系统中缺省的路径是在家目录（$HOME）中，而在 Windows 中则和运行 Odoo 的可执行文件放在同一个目录中。</p>
<blockquote>
<p>ℹ️在老版本的 Odoo&#x2F;OpenERP 中，默认的配置文件为.openerp-serverrc，为保持向后兼容，存在该文件且没有.odoorc文件的情况下会使用该文件。</p>
</blockquote>
<p>一个全新安装中不会自动创建.odoorc配置文件，我们应使用–save参数来保存，如果配置文件不存在则会创建默认配置文件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~/odoo-dev/odoo/odoo-bin --save --stop-after-init</span><br></pre></td></tr></table></figure>

<p>此处我们还使用–stop-after-init参数以在执行结束后停止服务。这一参数常在运行测试或要求运行模块升级来检测是否正确安装时使用。</p>
<blockquote>
<p>小贴士：命令行参数可以缩短到保持不混淆的程度，如–stop-after-init可缩写为–stop。</p>
</blockquote>
<p>现在可以通过如下命令来查看缺省配置文件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">more ~/.odoorc # 显示配置文件</span><br></pre></td></tr></table></figure>

<p>以上命令会显示所有配置项及配认值，编辑文件后在下一次启动 Odoo 实例后生效，输入 q 回到命令行。</p>
<p>我们还可以使用–conf(或-c)参数来指定配置文件。配置文件无需包含所有配置项，仅包含需修改默认值的配置项即可。</p>
<h3 id="修改监听端口"><a href="#修改监听端口" class="headerlink" title="修改监听端口"></a>修改监听端口</h3><p>–http-port&#x3D;（或-p）参数可以修改实例的监听端口（默认端口8069），不同的端口可以让我们在同一台机器上运行多个实例。</p>
<blockquote>
<p><strong>Odoo 11的修改：</strong> 在 Odoo 11中引入–http-port参数以替代此前版本使用的–xmlrpc-port</p>
</blockquote>
<p>下面就可以做个尝试，打开两个终端，第一个中输入</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~/odoo-dev/odoo/odoo-bin --http-port=8070</span><br></pre></td></tr></table></figure>

<p>第二个中输入</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~/odoo-dev/odoo/odoo-bin --http-port=8071</span><br></pre></td></tr></table></figure>

<p>此时就在同一台机器上使用不同端口运行了两个 Odoo 实例，这两个实例可以使用同一个数据库或不同数据库。这取决于我们使用的配置参数，并且两个端口上也可以运行相同或不同版本的 Odoo。</p>
<blockquote>
<p><strong>小贴士：</strong> 不同 Odoo 版本必须使用不同的数据库。尝试在不同版本上使用相同数据库将无法正常运行，因为各大版本采用了不兼容的数据库模式。</p>
</blockquote>
<h3 id="数据库选项"><a href="#数据库选项" class="headerlink" title="数据库选项"></a>数据库选项</h3><p>进行 Odoo 开发时，经常会使用多个数据库，有时还会用到不同版本。在同一端口上停止、启动不同服务实例，或在不同数据库间切换，会导致网页客户端会话异常。因为浏览器会存储会话的 Cookie。</p>
<p>在浏览器中使用私有模式访问实例可以避免这一问题。另一优良实践是在服务实例上开启数据库过滤器，这样可以确保实例仅允许对指定数据库的请求，而忽略其它请求。</p>
<blockquote>
<p><strong>Odoo 11中的修改：</strong><br>从Odoo 11开始，–database（或-d）参数可接收逗号分隔的多个数据库名，设置–database参数时也会自动设置–db-filter参数，这样仅有这个数据库才能为服务实例使用。对于 Odoo 11之前的版本，我们需要使用–db-filter来限制可访问的数据库。</p>
</blockquote>
<p>–db-filter可限制 Odoo 实例所能使用的数据库。它接收一个正则表达式来过滤可用数据库名，要精确匹配一个名称，表达式需要以^开头并以$结束。例如，仅允许testdb数据库，我们可以使用如下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~/odoo-dev/odoo/odoo-bin --db-filter=^testdb$</span><br></pre></td></tr></table></figure>

<p>使用–database和–db-filter参数来匹配同一数据库是一个良好的实践。事实上从 Odoo 11开始默认会为–database设置对应的–db-filter。</p>
<h3 id="管理服务器日志消息"><a href="#管理服务器日志消息" class="headerlink" title="管理服务器日志消息"></a>管理服务器日志消息</h3><p>–log-level 参数可用于设置日志级别，这有助于了解服务的状况。例如要开始调试日志级别，使用–log-level&#x3D;debug参数。还有如下选项：</p>
<ul>
<li>debug_sql：查看服务中产生的 SQL 查询</li>
<li>debug_rpc：服务器接收到的请求详情</li>
<li>debug_rpc_answer：服务器发送的响应详情</li>
</ul>
<p>其实–log-level是设置Odoo 日志级别的简化方式，此外通过更完整的–log-handler参数可以有选择地打开&#x2F;关闭日志记录器。默认情况下日志会作为标准输出（打印到屏幕），但是可以通过logfile&#x3D;参数来指定日志存储文件。</p>
<h2 id="安装第三方插件"><a href="#安装第三方插件" class="headerlink" title="安装第三方插件"></a>安装第三方插件</h2><p>在 Odoo 实例中产生新的模块并安装，对于初学者总会容易搞不清。下面一起来熟悉这一点。</p>
<h3 id="查找社区模块"><a href="#查找社区模块" class="headerlink" title="查找社区模块"></a>查找社区模块</h3><p>网络上有很多 Odoo 模块，<a target="_blank" rel="noopener" href="https://apps.odoo.com/">Odoo应用商店</a>可以下载一系列模块安装到系统中。另一个重要的资源是Odoo 社区联盟(OCA - Odoo Community Association)维护的模块，可在 <a target="_blank" rel="noopener" href="https://github.com/OCA/">GitHub</a> 上查找。OCA 是一个协调社区贡献的非营利组织，它同时提升软件质量，推广最佳开发实践和开源价值观。可通过<a target="_blank" rel="noopener" href="https://odoo-community.org/%E6%9D%A5%E8%BF%9B%E4%B8%80%E6%AD%A5%E4%BA%86%E8%A7%A3">https://odoo-community.org/来进一步了解</a> OCA。</p>
<p>为 Odoo 添加模块，仅需将其拷贝到官方插件的 addons 文件夹中即可，按前述安装即为~&#x2F;odoo-dev&#x2F;odoo&#x2F;addons&#x2F;。但这不是一个好的实践，我们安装的 Odoo 是由 Git 版本控制的代码仓库，将会与上游 GitHub 仓库保持同步，在其中加入外部插件会不利于管理。</p>
<p>避免这一点，我们可以选取一个或多个存放模块的目录，让 Odoo 服务也会从该目录中查找模块来使用。我们不仅可以把自定义模块放在一个不同的目录下不与官方的混在一起，还可以通过不同目录组织这些模块。</p>
<p>我们可以通过下载系统课程的代码来准备供 Odoo 安装的插件模块，获取 GitHub 上的源码，执行如下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd ~/odoo-dev</span><br><span class="line">git clone https://github.com/alanhou/odoo12-development.git library</span><br></pre></td></tr></table></figure>

<p>此时与&#x2F;odoo同级的&#x2F;library文件夹中将包含一些模块，现在就需告知 Odoo 这个新的模块目录。</p>
<h3 id="配置插件-add-ons-路径"><a href="#配置插件-add-ons-路径" class="headerlink" title="配置插件(add-ons)路径"></a>配置插件(add-ons)路径</h3><p>Odoo 服务有一个addons_path参数可设置查找插件的路径，默认指向Odoo 服务所运行处的&#x2F;addons文件夹。我们可以指定多个插件目录，这样就可以把自定义模块放到另一个目录下，无需与官方插件混到一起。</p>
<p>通过如下命令可包含新的模块路径来运行服务：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd ~/odoo-dev/odoo</span><br><span class="line">./odoo-bin -d 12-library --addons-path=&quot;../library,./addons&quot;</span><br></pre></td></tr></table></figure>

<p>仔细看服务日志，会发现有一行报告插件路径，信息类似INFO ? odoo: addons paths: […]，确认下里面是否有library&#x2F;目录。</p>
<h2 id="使用-Python-虚拟环境安装-Odoo"><a href="#使用-Python-虚拟环境安装-Odoo" class="headerlink" title="使用 Python 虚拟环境安装 Odoo"></a>使用 Python 虚拟环境安装 Odoo</h2><p>维护多个 Odoo 版本的代码在 Odoo 开发中很常见，需要整理一下来保持项目在同一台开发机器上并行。改变版本有时会需要上下文的切换。比如，现在 Odoo 的启动执行文件是odoo-bin，而在老版本中是odoo.py。迁移到 Python 3后又更易混淆了，我们要知道是选择python&#x2F;pip还是python3&#x2F;pip3，这取决于使用的 Odoo 版本。</p>
<p>Python 有一个在同机器上管理独立环境的工具virtualenv。每个环境有自己的Python 可执行文件和库文件，仅需在使用时激活环境，然后python和 pip 无需指定就可以在相应的安装了 Python库的环境下运行。要在Debian&#x2F;Ubuntu上使用virtualenv，执行如下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install virtualenv -y</span><br></pre></td></tr></table></figure>

<p>如果我们使用的工作目录是<del>&#x2F;odoo-dev，并把 Odoo 12源代码克隆到</del>&#x2F;odoo-dev&#x2F;odoo目录中，我们可以这样进行虚拟环境的创建：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">virtualenv -p python3 ~/odoo-dev/odoo12env</span><br><span class="line">source ~/odoo-dev/odoo12env/bin/activate</span><br></pre></td></tr></table></figure>

<p>一旦激活了虚拟环境，我们可以在其中安装 Odoo，可以通过 pip 来进行操作：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install -e ~/odoo-dev/odoo</span><br></pre></td></tr></table></figure>

<p>以上代码会将~&#x2F;odoo-dev&#x2F;odoo中的 Odoo源代码安装到虚拟环境中。-e 参数非常重要，这是一个可编辑安装。它不会复制一份代码到虚拟环境中，仅仅只是保留了一个到原地址 Odoo 代码的引用。因为使用到了源代码，源代码的修改在当前环境中也同样生效。</p>
<p>Odoo 的 Python 依赖会被自动安装，所以无需使用requirements.txt来进行手动安装。我们也可以通过 pip 来安装其它所需的 Python 库：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install phonenumbers num2words psycopg2-binary watchdog xlwt</span><br></pre></td></tr></table></figure>

<p>注意我们无需记住使用的是 Python 2还是 Python 3，这里的pip 命令会指向正确的版本。然后就可以运行 Odoo 了，pip 安装创建了一个bin&#x2F;odoo命令，可在任何位置运行，无需涉及源代码所在目录。</p>
<blockquote>
<p><strong>小贴士：</strong> 如果决定使用虚拟环境，任何要使用odoo-bin运行的命令，都可以替换为 odoo</p>
</blockquote>
<p>以下命令会启动并关闭所安装版本 Odoo，打印一些日志信息用于确定 Odoo 版本和使用的插件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">odoo --stop-after-init</span><br></pre></td></tr></table></figure>

<p>推荐的操作是将配置文件放在虚拟环境文件夹中。以下会为我们的项目初始化一个12-library 数据库，并创建一个对应的12-library.conf 文件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">odoo -c ~/odoo-dev/odoo12-env/12-library.conf -d 12-library --addons-path=~/odoo-dev/library,~/odoo-dev/odoo/addons --save --stop</span><br></pre></td></tr></table></figure>

<p>自此开始，我们可通过如下命令启动图书项目 Odoo 服务：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">odoo -c ~/odoo-dev/odoo12-env/12-library.conf</span><br></pre></td></tr></table></figure>

<p>最后在完成后，通过如下命令来退出环境：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">deactivate</span><br></pre></td></tr></table></figure>

<p>假设我们要在同一台机器上使用 Odoo 10项目，它使用的是 Python 2.7，通过如下命令创建环境、安装 Odoo：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cd ~/odoo-dev</span><br><span class="line">git clone https://github.com/odoo/odoo.git -b 10.0 --depth=1 odoo10</span><br><span class="line">virtualenv odoo10env</span><br><span class="line">source odoo10env/bin/activate</span><br><span class="line">pip install -e ./odoo10</span><br><span class="line">odoo --version</span><br><span class="line">deactivate # To finish working with this env.</span><br></pre></td></tr></table></figure>

<p>要使得在 Odoo 版本间切换更容易，我们可以在~&#x2F;odoo-dev&#x2F;odoo10目录下再为10.0分支克隆一份源代码。然后创建虚拟环境，激活环境，使用 pip创建一个 Odoo 10可编辑安装。virtualenv没有使用-p 参数指定 Python 版本，默认为 Python 2，也就是 Odoo 10所需的版本。</p>
<p>如果系统中没有 Python 2，Ubuntu 18.04默认就不带 Python 2，则需要执行如下命令来进行安装：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install python-dev</span><br></pre></td></tr></table></figure>

<h3 id="使用-PyPI-下载和安装插件模块"><a href="#使用-PyPI-下载和安装插件模块" class="headerlink" title="使用 PyPI 下载和安装插件模块"></a>使用 PyPI 下载和安装插件模块</h3><p>社区贡献的插件可以打包成 Python 库，发布到 Python 包索引(PyPI -Python Package Index)，然后像其它库一样使用 pip 安装。为了能使用这一方法，Odoo 自动添加了site-packages&#x2F;文件夹至插件配置路径，用于安装库文件。打包可以通过<a target="_blank" rel="noopener" href="https://pypi.org/project/setuptools-odoo/">setuptools-odoo</a>工具。</p>
<p>OCA 项目使用该工具打包并发布插件至 PyPI。因不同 Odoo 版本中存在相同模块，模块名之前会加一个 Odoo 版本前缀。例如odoo12-addon-partner-fax 是Odoo 12的<a target="_blank" rel="noopener" href="https://pypi.org/project/odoo12-addon-partnerfax/">partner_fax</a> PyPI 包，它为 partner 添加了一个传真字段。</p>
<p>如需从 PyPI 下载该模块及依赖，并随后安装至odoo12env环境，使用如下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">source ~/odoo-dev/odoo12env/bin/activate</span><br><span class="line">pip install odoo12-addon-partner-fax</span><br><span class="line">odoo -c ~/odoo-dev/odoo12-env/12-library.conf -i partner_fax --stop</span><br></pre></td></tr></table></figure>

<h2 id="服务器端开发者模式"><a href="#服务器端开发者模式" class="headerlink" title="服务器端开发者模式"></a>服务器端开发者模式</h2><p>为便于开发者，Odoo 有一个–dev&#x3D;all参数可激活一些开发者友好的功能。</p>
<blockquote>
<p>**Odoo 10中的修改：<br>**–dev&#x3D;…参数是在 Odoo 10中引入的，它取代了此前版本中更简单、功能也更少的–debug参数</p>
</blockquote>
<p>这启用了一些有用的功能可加快开发流程，最重要的如下：</p>
<ul>
<li>在保存 Python 文件时自动重载 Python 代码，避免手动重启服务</li>
<li>从 XML 中直接读取 view 定义，避免手动升级模块</li>
</ul>
<p>–dev&#x3D;all将在抛出异常时启动 Python调试器(pdb)，在服务报错后做后验(postmortem)分析非常有益。注意这一设置对日志输出不产生任何影响。有关 Python 调试器命令详情可参见<a target="_blank" rel="noopener" href="https://docs.python.org/3/library/pdb.html#debugger-commands">Python 官方文档</a>。</p>
<p>虽然 all 值适用于大多数情况，–dev还可接一串逗号分隔的选项。缺省情况下会使用Python 调试器 pdb。有些人会倾向安装、使用其它调试器，来改善功能和易用性。Odoo 是允许我们指定调试器的，常用的有ipdb和pudb。在本系列第八篇<a target="_blank" rel="noopener" href="https://alanhou.org/odoo12-business-logic/">Odoo 12开发之业务逻辑 - 业务流程的支持</a>中，我们将介绍如何在 Odoo 开发中使用调试器。</p>
<p>要自动侦测代码文件的变化 ，服务开发者模式需安装一个额外的依赖python3-watchdog。我们需要在Ubuntu&#x2F;Debian系统中安装它之后才可使用，命令如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install python3-watchdog</span><br></pre></td></tr></table></figure>

<p>对于 Odoo 11之前的版本，使用的是 Python 2，则需安装python-watchdog。同样可使用 pip 安装，命令为pip install watchdog。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在本文中，如们学习了如何在 Ubuntu 系统中安装 Odoo 并从 GitHub 上获取 Odoo源码，以及如何创建Odoo 数据库和运行 Odoo 实例。</p>
<p>现在我们的 Odoo 环境可正常用于开发，并且也可以对数据库和实例进行管理。有了这些，我们可以进行一步的学习了。在下一篇文章中，我们将从零开始创建第一个 Odoo 模块，并理解相关的主要元素。</p>
<p> </p>
<p>☞☞☞ 接下来请学习<a target="_blank" rel="noopener" href="https://alanhou.org/odoo12-first-application/">Odoo 12 开发之创建第一个 Odoo 应用</a></p>
<p>本文首发地址：<a target="_blank" rel="noopener" href="https://alanhou.org/developer-mode-odoo12/">Alan Hou 的个人博客</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" title="Next page" aria-label="Next page" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Alan Hou</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  




  





</body>
</html>
