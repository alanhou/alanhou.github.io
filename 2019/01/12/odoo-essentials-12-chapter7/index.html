<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <link rel="manifest" href="/images/manifest.json">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.2.1/css/all.min.css" integrity="sha256-Z1K5uhUaJXA7Ll0XrZ/0JhX4lAtZFpT6jkKrEDT0drU=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"alanhou.github.io","root":"/","images":"/images","scheme":"Gemini","darkmode":true,"version":"8.14.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="本文为最好用的免费ERP系统Odoo 12开发手册系列文章第七篇。 在上一篇文章中，我们概览了模型创建以及如何从模型中载入和导出数据。现在我们已有数据模型和相关数据，是时候学习如何编程与其进行交互 了。模型的 ORM（Object-Relational Mapping）提供了一些交互数据的方法，称为 API（Application Programming Interface）。这包括基本的增删改查">
<meta property="og:type" content="blog">
<meta property="og:title" content="第七章 Odoo 12开发之记录集 – 使用模型数据">
<meta property="og:url" content="https://alanhou.github.io/2019/01/12/odoo-essentials-12-chapter7/index.html">
<meta property="og:site_name" content="Alan Hou的个人博客">
<meta property="og:description" content="本文为最好用的免费ERP系统Odoo 12开发手册系列文章第七篇。 在上一篇文章中，我们概览了模型创建以及如何从模型中载入和导出数据。现在我们已有数据模型和相关数据，是时候学习如何编程与其进行交互 了。模型的 ORM（Object-Relational Mapping）提供了一些交互数据的方法，称为 API（Application Programming Interface）。这包括基本的增删改查">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2dd1317b68f24dcfa42684093cede038~tplv-k3u1fbpfcp-zoom-1.image">
<meta property="og:image" content="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3f31f8ad52864d9db84f22caa8105ad2~tplv-k3u1fbpfcp-zoom-1.image">
<meta property="article:published_time" content="2019-01-11T16:00:00.000Z">
<meta property="article:modified_time" content="2023-02-03T06:19:20.003Z">
<meta property="article:author" content="Alan Hou">
<meta property="article:tag" content="Odoo12">
<meta property="article:tag" content="Odoo">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2dd1317b68f24dcfa42684093cede038~tplv-k3u1fbpfcp-zoom-1.image">


<link rel="canonical" href="https://alanhou.github.io/2019/01/12/odoo-essentials-12-chapter7/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"en","comments":true,"permalink":"https://alanhou.github.io/2019/01/12/odoo-essentials-12-chapter7/","path":"2019/01/12/odoo-essentials-12-chapter7/","title":"第七章 Odoo 12开发之记录集 – 使用模型数据"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>第七章 Odoo 12开发之记录集 – 使用模型数据 | Alan Hou的个人博客</title>
  
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-53450398-1"></script>
  <script class="next-config" data-name="google_analytics" type="application/json">{"tracking_id":"UA-53450398-1","only_pageview":false}</script>
  <script src="/js/third-party/analytics/google-analytics.js"></script>

  <script src="/js/third-party/analytics/baidu-analytics.js"></script>
  <script async src="https://hm.baidu.com/hm.js?c6d32d47881743b193f462b65f69d37f"></script>







  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">Alan Hou的个人博客</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">用行动赢得尊重</p>
      <img class="custom-logo-image" src="/images/logo.png" alt="Alan Hou的个人博客">
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="Search" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a></li><li class="menu-item menu-item-odoo"><a href="/tags/Odoo/" rel="section"><i class="fa-solid fa-o fa-fw"></i>Odoo</a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BC%80%E5%8F%91%E5%87%86%E5%A4%87"><span class="nav-number">1.</span> <span class="nav-text">开发准备</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-shell-%E5%91%BD%E4%BB%A4%E8%A1%8C"><span class="nav-number">2.</span> <span class="nav-text">使用 shell 命令行</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%89%A7%E8%A1%8C%E7%8E%AF%E5%A2%83"><span class="nav-number">3.</span> <span class="nav-text">执行环境</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%8E%AF%E5%A2%83%E5%B1%9E%E6%80%A7"><span class="nav-number">3.1.</span> <span class="nav-text">环境属性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%8E%AF%E5%A2%83%E4%B8%8A%E4%B8%8B%E6%96%87"><span class="nav-number">3.2.</span> <span class="nav-text">环境上下文</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BF%AE%E6%94%B9%E8%AE%B0%E5%BD%95%E9%9B%86%E6%89%A7%E8%A1%8C%E7%8E%AF%E5%A2%83"><span class="nav-number">3.3.</span> <span class="nav-text">修改记录集执行环境</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95%E9%9B%86%E5%92%8C%E4%BD%9C%E7%94%A8%E5%9F%9F-domain-%E6%9F%A5%E8%AF%A2%E6%95%B0%E6%8D%AE"><span class="nav-number">4.</span> <span class="nav-text">使用记录集和作用域(domain)查询数据</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E8%AE%B0%E5%BD%95%E9%9B%86"><span class="nav-number">4.1.</span> <span class="nav-text">创建记录集</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%9F%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-number">4.2.</span> <span class="nav-text">域表达式</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9C%A8%E8%AE%B0%E5%BD%95%E9%9B%86%E4%B8%AD%E8%AE%BF%E9%97%AE%E6%95%B0%E6%8D%AE"><span class="nav-number">5.</span> <span class="nav-text">在记录集中访问数据</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%BF%E9%97%AE%E8%AE%B0%E5%BD%95%E4%B8%AD%E6%95%B0%E6%8D%AE"><span class="nav-number">5.1.</span> <span class="nav-text">访问记录中数据</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%BF%E9%97%AE%E5%85%B3%E8%81%94%E5%AD%97%E6%AE%B5"><span class="nav-number">5.2.</span> <span class="nav-text">访问关联字段</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%BF%E9%97%AE%E6%97%B6%E9%97%B4%E5%92%8C%E6%97%A5%E6%9C%9F%E5%80%BC"><span class="nav-number">5.3.</span> <span class="nav-text">访问时间和日期值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BD%AC%E6%8D%A2%E6%96%87%E6%9C%AC%E5%BD%A2%E5%BC%8F%E7%9A%84%E6%97%A5%E6%9C%9F%E5%92%8C%E6%97%B6%E9%97%B4"><span class="nav-number">5.4.</span> <span class="nav-text">转换文本形式的日期和时间</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9C%A8%E8%AE%B0%E5%BD%95%E4%B8%AD%E5%86%99%E5%85%A5"><span class="nav-number">6.</span> <span class="nav-text">在记录中写入</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E5%AF%B9%E8%B1%A1%E5%BD%A2%E5%BC%8F%E5%88%86%E9%85%8D%E5%80%BC%E5%86%99%E5%85%A5"><span class="nav-number">6.1.</span> <span class="nav-text">使用对象形式分配值写入</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%9A%E8%BF%87-write-%E6%96%B9%E6%B3%95%E5%86%99%E5%85%A5"><span class="nav-number">6.2.</span> <span class="nav-text">通过 write()方法写入</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%99%E5%85%A5%E6%97%A5%E6%9C%9F%E5%92%8C%E6%97%B6%E9%97%B4%E5%80%BC"><span class="nav-number">6.3.</span> <span class="nav-text">写入日期和时间值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E5%92%8C%E5%88%A0%E9%99%A4%E8%AE%B0%E5%BD%95"><span class="nav-number">6.4.</span> <span class="nav-text">创建和删除记录</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%87%8D%E6%9E%84%E8%AE%B0%E5%BD%95%E9%9B%86"><span class="nav-number">7.</span> <span class="nav-text">重构记录集</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E5%BA%95%E5%B1%82-SQL-%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1"><span class="nav-number">8.</span> <span class="nav-text">使用底层 SQL 和数据库事务</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-number">9.</span> <span class="nav-text">总结</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Alan Hou</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">18</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="https://alanhou.github.io/2019/01/12/odoo-essentials-12-chapter7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Alan Hou">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Alan Hou的个人博客">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="第七章 Odoo 12开发之记录集 – 使用模型数据 | Alan Hou的个人博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          第七章 Odoo 12开发之记录集 – 使用模型数据
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2019-01-12 00:00:00" itemprop="dateCreated datePublished" datetime="2019-01-12T00:00:00+08:00">2019-01-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2023-02-03 14:19:20" itemprop="dateModified" datetime="2023-02-03T14:19:20+08:00">2023-02-03</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <p>本文为<a target="_blank" rel="noopener" href="https://alanhou.org/odoo-12-development/">最好用的免费ERP系统Odoo 12开发手册</a>系列文章第七篇。</p>
<p>在上一篇文章中，我们概览了模型创建以及如何从模型中载入和导出数据。现在我们已有数据模型和相关数据，是时候学习如何编程与其进行交互 了。模型的 ORM（Object-Relational Mapping）提供了一些交互数据的方法，称为 API（Application Programming Interface）。这包括基本的增删改查(CRUD)操作，也包括一些其它操作，如数据导入导出，以及改善用户界面和体验的工具方法。它还包含一些我们在前面文章中所看到的装饰器。这些都让我们可以通过添加新的方法来调用 ORM 进行相关操作。</p>
<p>本文主要内容有：</p>
<ul>
<li>使用 shell 命令交互式地学习 ORM API</li>
<li>理解执行环境和上下文</li>
<li>使用记录集和作用域(domain)查询数据</li>
<li>在记录集中访问数据</li>
<li>在记录中写入</li>
<li>编写记录集</li>
<li>使用底层 SQL 和数据库事务</li>
</ul>
<h2 id="开发准备"><a href="#开发准备" class="headerlink" title="开发准备"></a>开发准备</h2><p>本文代码使用交互式 shell 命令行执行，无需使用前面章节的代码。</p>
<h2 id="使用-shell-命令行"><a href="#使用-shell-命令行" class="headerlink" title="使用 shell 命令行"></a>使用 shell 命令行</h2><p>Python带有命令行界面，是研究其语法一个很好的方式。Odoo 也有类似的功能，可以交互式的测试命令的执行效果，这就是 shell 命令行。在命令行中执行以下命令并指定数据库即可使用：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~/odoo-dev/odoo/odoo-bin shell -d dev12</span><br></pre></td></tr></table></figure>

<p>此时在终端上可以看到正常的服务启动信息，等到出现&gt;&gt;&gt;Python提示符时即为完成，可以输入命令了。</p>
<blockquote>
<p>ℹ️<strong>Odoo 9中的修改</strong><br>shell 功能在9.0中才添加。Odoo 8.0可使用社区模块来添加这一功能。只需下载并放入 addons 路径即可使用，下载请见<a target="_blank" rel="noopener" href="https://www.odoo.com/apps/modules/8.0/shell/">应用市场</a>。</p>
</blockquote>
<p>此处 self 表示管理员用户的记录，可通过如下命令进行确认：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; self</span><br><span class="line">res.users(1,)</span><br><span class="line">&gt;&gt;&gt; self._name</span><br><span class="line">&#x27;res.users&#x27;</span><br><span class="line">&gt;&gt;&gt; self.login</span><br><span class="line">&#x27;__system__&#x27;</span><br></pre></td></tr></table></figure>

<p>在以上 shell 会话中，我们检查了自己的环境：</p>
<ul>
<li>self命令表示res.users记录集，仅包含一条 id 为1的记录</li>
<li>查看self._name获得记录集模型名，你可能猜到了，是’res.users’</li>
<li>记录的 name 值为OdooBot</li>
<li>记录的 login 字段值为__system__</li>
</ul>
<blockquote>
<p>ℹ️<strong>Odoo 12中的修改</strong><br>id 号为1的超级用户由原来的 admin 变成无法直接登录的内部系统用户。现在 admin 的 id 号为 2并且不是超级用户，但默认各应用会将其加入所有安全组。主要原因是避免用户使用超级用户账号来执行日常操作。这样的风险是该用户会跳过权限规则并导致数据的不一致，比如跨公司(cross-company)关联。现在超级用户仅用于检测问题或具体的跨公司操作。</p>
</blockquote>
<p>和 Python 一样，可通过 Ctrl + D退出该命令行。此时会结束服务并返回到系统shell 命令行。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2dd1317b68f24dcfa42684093cede038~tplv-k3u1fbpfcp-zoom-1.image" alt="Odoo 12 shell 命令行"></p>
<h2 id="执行环境"><a href="#执行环境" class="headerlink" title="执行环境"></a>执行环境</h2><p>Odoo shell 中包含一个 self 引用，类似于在res.users模型的方法中看到的那样。如我们所见，self 是一个记录集。记录集自带环境信息，包括浏览信息的用户以及其它上下文信息，如语言和时区。下面我们会学习执行环境中可用的属性、环境上下文的用处以及如何修改该上下文。</p>
<h3 id="环境属性"><a href="#环境属性" class="headerlink" title="环境属性"></a>环境属性</h3><p>我们可通过如下代码查看当前环境：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; self.env</span><br><span class="line">&lt;odoo.api.Environment object at 0x7f78a26026a0&gt;</span><br></pre></td></tr></table></figure>

<p>self.env 中的执行环境中有以下属性：</p>
<ul>
<li>env.cr是正在使用的数据库游标(cursor)</li>
<li>env.user是当前用户的记录</li>
<li>env.uid是会话用户 id，与env.user.id相同</li>
<li>env.context是会话上下文的不可变字典</li>
</ul>
<p>环境还提供对带有所有已安装模型注册表的访问，如self.env[‘res.partner’]返回一条对 partner 模型的引用。然后我们还可以对其使用search()或browse()方法来获取记录集：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; self.env[&#x27;res.partner&#x27;].search([(&#x27;name&#x27;, &#x27;like&#x27;, &#x27;Ad&#x27;)])</span><br><span class="line">res.partner(10, 35, 3)</span><br></pre></td></tr></table></figure>

<p>上例中返回的res.partner模型记录集包含三条记录，id 分别为10, 35和3。记录集并没有按 id 排序，因为使用了相应模型的默认排序。就 partner 模型而言，默认的_order为display_name。</p>
<h3 id="环境上下文"><a href="#环境上下文" class="headerlink" title="环境上下文"></a>环境上下文</h3><p>环境上下文是一个带有会话数据的字典，可用于客户端用户界面以及服务端 ORM 和业务逻辑中。在客户端中，它可以把信息从一个视图带到另一个视图中，比如前一个视图中活跃的记录 id，通过点击链接或按钮，可将默认值带入到下一个视图中。在服务端中，一些记录集的值会依赖于上下文提供的本地化设置。具体的例子有lang键影响可翻译字段的值。上下文还可为服务端代码提供信号。比如active_test键在设为 False 时，会改变ORM中search()方法的行为，它会忽略记录中的active标记，inactive(假删除)的记录也会被返回。</p>
<p>客户端的初始上下文长这样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#x27;lang&#x27;: &#x27;en_US&#x27;, &#x27;tz&#x27;: &#x27;Europe/Brussels&#x27;, &#x27;uid&#x27;: 2&#125;</span><br></pre></td></tr></table></figure>

<p>补充：服务端查看上下文命令为self.context_get()或self.env.context</p>
<p>其中 lang 键为用户语言，tz 为时区信息，uid 为当前用户 id。记录中的内容随当前依赖的上下文可能会不同：</p>
<ul>
<li>translated字段根据活跃的 lang 语言不同值也会不同</li>
<li>datetimep字段根据活跃的的 tz 时区不同时间会不同</li>
</ul>
<p>在上一个视图中点击链接或按钮打开表单时，一个active_id键会被加入上下文，它带有原表单我们所在位置记录的 id。以列表视图为例，active_ids上下文键中包含上一个列表中所选择的记录 id 列表。</p>
<p>在客户端中，上下文可用于使用default_或default_search_前缀在目录视图上设置默认值或启动默认过滤器。举例如下：</p>
<ul>
<li>设置当前用户为user_id字段默认值，使用{‘default_user_id’: uid}</li>
<li>在目标视图上默认启动filter_my_books过滤器，使用{‘default_search_filter_my_tasks’: 1}</li>
</ul>
<h3 id="修改记录集执行环境"><a href="#修改记录集执行环境" class="headerlink" title="修改记录集执行环境"></a>修改记录集执行环境</h3><p>记录集执行环境是不可变的，因此不能被修改，但我们可以创建一个变更环境并使用它来执行操作。我们通过如下方法来实现：</p>
<ul>
<li>env.sudo(user)中传入一条用户记录并返回该用户的环境。如未传入用户，则使用__system__超级用户root，这时可绕过安全规则执行指定操作。</li>
<li>env.with_context(<dictionary>) 替换原上下文为新的上下文</li>
<li>env.with_context(key&#x3D;value,…)修改当前上下文，为一些键设置值</li>
</ul>
<p>此外还有一个env.ref()函数，传入一个外部标识符字符串并返回它的记录，请参见：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; self.env.ref(&#x27;base.user_root&#x27;)</span><br><span class="line">res.users(1,)</span><br></pre></td></tr></table></figure>

<h2 id="使用记录集和作用域-domain-查询数据"><a href="#使用记录集和作用域-domain-查询数据" class="headerlink" title="使用记录集和作用域(domain)查询数据"></a>使用记录集和作用域(domain)查询数据</h2><p>在方法或 shell 会话中，self表示当前模型，并且我们仅能访问该模型的记录。要访问其它模型就需要使用self.env。例如self.env[‘res.partner’]返回一条对 Partner 模型的引用(也是一个空记录集)。我们可以使用search()或browse()来获取记录集，其中search()方法使用域表达式来定义记录选择范围。</p>
<h3 id="创建记录集"><a href="#创建记录集" class="headerlink" title="创建记录集"></a>创建记录集</h3><p>search()方法接收一个域表达式并返回符合条件记录的记录集。空域[] 将返回所有记录。</p>
<blockquote>
<p>ℹ️如果模型有特殊字段 active，默认只有active&#x3D;True的记录才在选择范围内</p>
</blockquote>
<p>还可以使用以下关键字参数：</p>
<ul>
<li>order是一个数据库查询语句中ORDER BY使用的字符串，通常是一个逗号分隔的字段名列表。每个字段都可接DESC关键字，用于表示倒序排列。</li>
<li>limit设置获取记录的最大条数</li>
<li>offset忽略前 n 前记录，可配合limit使用来一次查询指定范围记录</li>
</ul>
<p>有时我们只要知道满足某一条件的记录条数，这时可使用search_count()来返回记录条数而非记录集。这节约了先获取记录列表再记数的开销，在还没有获取记录集且仅想知道记录条数时这样会更高效。</p>
<p>browse()方法接收一个 ID 列表或单个ID并返回这些记录的记录集。在我们知道 ID 并想要获取记录时这就非常方便了。</p>
<p>一些使用示例如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; self.env[&#x27;res.partner&#x27;].search([(&#x27;name&#x27;, &#x27;like&#x27;, &#x27;Pac&#x27;)])</span><br><span class="line">res.partner(42, 62)</span><br><span class="line">&gt;&gt;&gt; self.env[&#x27;res.partner&#x27;].browse([42, 62])</span><br><span class="line">res.partner(42, 62)</span><br></pre></td></tr></table></figure>

<h3 id="域表达式"><a href="#域表达式" class="headerlink" title="域表达式"></a>域表达式</h3><p>域(domain)用于过滤数据记录。它使用一个特殊语法来供 Odoo ORM解析，生成数据库查询中的 WHERE 表达式。域表达式是一组条件组成的列表，每个条件都是一个 <strong>(‘字段名’, ‘运算符’, ‘值’)</strong> 组成的元组，例如，[(‘is_done’,’&#x3D;’,False)]是仅带有一个条件的有效域表达式。以下是对各个元素的说明：</p>
<ul>
<li><p>字段名：是一个待过滤字段，可使用点号标记来表示关联模型中的字段</p>
</li>
<li><p>值：在 Python 表达式中运行。可使用字面值，如数字、布尔值、字符串和列表，也可使用运行上下文中的字段和标识符。针对域其实有两种运行上下文：</p>
<ul>
<li>在窗口操作或字段属性等客户端中使用时，可使用原生字段值来渲染当前可用视图，但不能对其使用点标记符</li>
<li>在服务端使用时，如安全记录规则或服务端 Python 代码中，可以对字段使用点标记符，因为当前记录是一个对象</li>
</ul>
</li>
<li><p>运算符：可以是以下中的一个</p>
<ul>
<li>常用比较运算符有&lt;, &gt;, &lt;&#x3D; , &gt;&#x3D;, &#x3D;和!&#x3D;。</li>
<li>‘&#x3D;like’和’&#x3D;ilike’匹配某一模式，这里下划线_匹配单个字符，百分号%匹配任意一组字符。</li>
<li>‘like’匹配’%value%’模式，’ilike’与其相似但忽略大小写。还可以使用’not like’和’not ilike’运算符。</li>
<li>‘child of’在配置支持层级关联的模型中查找层级关系中的子级值。</li>
<li>‘in’ 和’not in’用于查看给定列表的包含，所以其值为一个列表。用于to-many关联字段时，in运算符和contains运算符一样。</li>
<li>‘not in’是in的反向运算，用于查看不在列表中的值。</li>
</ul>
</li>
</ul>
<p>域表达式是一个列表并且包含多个条件元组。默认这些条件使用AND逻辑运算符连接，也就是说它仅返回满足所有条件的记录。也可以使用显式逻辑运算符 - ‘&amp;’符号表示 AND 运算符（默认值），管道运算符’|’表示OR运算符。这两个运算符会作用于接下来的两项，递归执行。后面我们会一起来详细了解。</p>
<blockquote>
<p>ℹ️域表达式使用了更为正式的定义方式：前缀标记法，也称波兰表达式(Polish notation)：运算符放在运算项之前。AND和OR是二元运算符，而NOT是一元运算符。</p>
</blockquote>
<p>感叹号’!’表示NOT运算符，可用于下一项的运算，因此要放执行的否定项之前。例如[‘!’, (‘is_done’,’&#x3D;’,True)]将过滤出所有未完成(not-don e)的记录。</p>
<p>下一项本身也可以是一个作用其后续项的运算符，形成一个嵌套条件。下例可以有助于我们进行理解。在服务端记录规则中，可以找到类似下面这样的域表达式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[&#x27;|&#x27;,</span><br><span class="line">    (&#x27;message_follower_ids&#x27;, &#x27;in&#x27;, [user.partner_id.id]),</span><br><span class="line">    &#x27;|&#x27;,</span><br><span class="line">        (&#x27;user_id&#x27;, &#x27;=&#x27;, user.id),</span><br><span class="line">        (&#x27;user_id&#x27;, &#x27;=&#x27;, False)</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>这个域过滤出当前用户在follower列表中并且是负责人用户，或者没有负责人用户的用户集。第一个’|’或运算符作用于 follower 条件以及下一个条件的结果。下一个条件是后面两个条件的并集：用户ID是当前会话用户或未进行设置。下图是上例域表达式的抽象语法树表示：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3f31f8ad52864d9db84f22caa8105ad2~tplv-k3u1fbpfcp-zoom-1.image" alt="Odoo 12域表达式抽象语法树"></p>
<h2 id="在记录集中访问数据"><a href="#在记录集中访问数据" class="headerlink" title="在记录集中访问数据"></a>在记录集中访问数据</h2><p>一旦获取了数据集，就可以查看其中包含的数据了。下面的几个部分中我们就来看看如何访问记录集中的数据。我们可以获取单条记录的字段值，称为单例(singleton)。关联字段带有特殊属性，我们可通过点号标记来查看关联记录。最后我们一起思考处理日期和时间记录并进行格式转换。</p>
<h3 id="访问记录中数据"><a href="#访问记录中数据" class="headerlink" title="访问记录中数据"></a>访问记录中数据</h3><p>记录集的一个特例是仅有一条记录，称为单例。单例仍是记录集，在需要记录集的地方均可使用。与多元素记录集不同，单例可使用点号标记访问它的字段，如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; print(self.name)</span><br><span class="line">OdooBot</span><br></pre></td></tr></table></figure>

<p>下个例子中我们看看同一个 self 单例和记录集相同的行为，我们可对其进行遍历。它只有一条记录，所以只会打印出一个名称：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; for rec in self:</span><br><span class="line">...     print(rec.name)</span><br><span class="line">...</span><br><span class="line">OdooBot</span><br></pre></td></tr></table></figure>

<p>尝试访问有多条记录的记录集字段值会产生错误，所以在不确定操作的是否为单例数据集时就会产生问题。对于设计仅操作单例的方法，可在开头处使用self.ensure_one()，如果 self 不是单例时将抛出错误。</p>
<blockquote>
<p>ℹ️空记录也是单例。这样很方便，因为访问字段会返回 None 而非抛出错误。对于关联字段同样如此，使用点号标记访问关联记录也不会抛出错误。</p>
</blockquote>
<h3 id="访问关联字段"><a href="#访问关联字段" class="headerlink" title="访问关联字段"></a>访问关联字段</h3><p>如前面所见，模型可包含关联字段：many-to-one, one-to-many和many-to-many。这些字段类型的值为记录集。</p>
<p>对于many-to-one，其值可以是单例或空记录集。两种情况下都可以直接访问字段值。如下例中的命令是正确并安全的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; self.company_id</span><br><span class="line">res.company(1,)</span><br><span class="line">&gt;&gt;&gt; self.company_id.name</span><br><span class="line">&#x27;YourCompany&#x27;</span><br><span class="line">&gt;&gt;&gt; self.company_id.currency_id</span><br><span class="line">res.currency(1,)</span><br><span class="line">&gt;&gt;&gt; self.company_id.currency_id.name</span><br><span class="line">&#x27;EUR&#x27;</span><br></pre></td></tr></table></figure>

<p>为避免麻烦，空记录可像单例一样操作，访问其字段值不会返回错误而是返回 False。所以我们可以使用点号标记来遍历字段，而无需担心因其值为空而报错，如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; self.company_id.parent_id</span><br><span class="line">res.company()</span><br><span class="line">&gt;&gt;&gt; self.company_id.parent_id.name</span><br><span class="line">False</span><br></pre></td></tr></table></figure>

<h3 id="访问时间和日期值"><a href="#访问时间和日期值" class="headerlink" title="访问时间和日期值"></a>访问时间和日期值</h3><p>在记录集中，日期和日期时间值以原生 Python 对象展示，例如，在查询上次 admin 用户登录日期时：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; self.browse(2).login_date</span><br><span class="line">datetime.datetime(2019, 1, 8, 9, 2, 54, 45546)</span><br></pre></td></tr></table></figure>

<p>因为日期和日期时间是 Python 对象，它们可使用这些对象的所有功能。</p>
<blockquote>
<p>ℹ️<strong>Odoo 12中的修改</strong><br>date和datetime字段值以 Python 对象表示，而此前 Odoo 版本中它们以文本字符串表示。这些字段类型值仍可像此前 Odoo 版本中那样使用文本表示。</p>
</blockquote>
<p>日期和时间在数据库中以原生的世界标准时间(UTC) 格式存储，不受时区影响。 在记录集中看到的datetime值也是 UTC格式，在客户端中向用户展示时，datetime值会根据当前会话的时间设置来转换成用户的时区。这一设置存储在上下文的tz键中，如{‘tz’: ‘Europe&#x2F;Brussels’}。这一转换由客户端负责，而不是由服务端完成。</p>
<p>例如在布鲁塞尔(UTC+1)的用户输入12:00 AM数据库中会存储为10:00 AM UTC，而在纽约(UTC-4) 的用户查看时则为06:00 AM。</p>
<p>补充：请不要怀疑作者的数学是不是体育老师教的😂，布鲁塞尔为东一区，纽约为西五区，但冬令时和夏令时让这个问题变复杂了。将12:00修改为11:00应该就正确了。</p>
<blockquote>
<p>ℹ️Odoo 服务日志消息时间戳使用UTC时间而非本地服务器时间</p>
</blockquote>
<p>相反的转换，由会话时区转换为UTC，也需由客户端在将用户输入的datetime传回服务器时完成。日期对象可进行比较和相减来获取两个日期的时间差，时间差是一个timedelta对象。timedelta可通过date运算对date和datetime对象进行加减。这些对象由 Python 标准库datetime模块提供，以下是使用它进行的基本运算示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; from datetime import date</span><br><span class="line">&gt;&gt;&gt; date.today()</span><br><span class="line">datetime.date(2019, 1, 12)</span><br><span class="line">&gt;&gt;&gt; from datetime import timedelta</span><br><span class="line">&gt;&gt;&gt; timedelta(days=7)</span><br><span class="line">datetime.timedelta(7)</span><br><span class="line">&gt;&gt;&gt; date.today() + timedelta(days=7)</span><br><span class="line">datetime.date(2019, 1, 19)</span><br></pre></td></tr></table></figure>

<p>对于date, datetime和timedelta数据类型的完整参考请见<a target="_blank" rel="noopener" href="https://docs.python.org/3.6/library/datetime.html">Python 官方文档</a>。Odoo 还在odoo.tools.date_utils模块中提供了一些额外的便利函数，这些函数有：</p>
<ul>
<li>start_of(value, granularity)是某个特定刻度时间区间的开始时间，这些刻度有year, quarter, month, week, day或hour</li>
<li>end_of(value, granularity)是某个特定刻度时间区间的结束时间</li>
<li>add(value, <strong>kwargs)为指定值加上一个时间间隔。</strong>kwargs参数由一个relativedelta对象来定义时间间隔。这些参数可以是years, months, weeks, days, hours, minutes等等</li>
<li>subtract(value, **kwargs)为指定值减去一个时间间隔</li>
</ul>
<p>relativedelta对象来自dateutil库，可使用months或years执行date运算（Python的timedelta标准库仅支持days）。更多内容请见<a target="_blank" rel="noopener" href="https://dateutil.readthedocs.io/">相关文档</a>。以下为上述函数的一些使用示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; from odoo.tools import date_utils</span><br><span class="line">&gt;&gt;&gt; from datetime import datetime</span><br><span class="line">&gt;&gt;&gt; date_utils.start_of(datetime.now(), &#x27;week&#x27;)</span><br><span class="line">datetime.datetime(2019, 1, 7, 0, 0)</span><br><span class="line">&gt;&gt;&gt; date_utils.end_of(datetime.now(), &#x27;week&#x27;)</span><br><span class="line">datetime.datetime(2019, 1, 13, 23, 59, 59, 999999)</span><br><span class="line">&gt;&gt;&gt; from datetime import date</span><br><span class="line">&gt;&gt;&gt; date_utils.add(date.today(), months=2)</span><br><span class="line">datetime.date(2019, 3, 12)</span><br><span class="line">&gt;&gt;&gt; date_utils.subtract(date.today(), months=2)</span><br><span class="line">datetime.date(2018, 11, 12)</span><br></pre></td></tr></table></figure>

<p>这些工具方法在odoo.fields.Date和the odoo.fields.Datetime对象中也可使用，如：</p>
<ul>
<li>fields.Date.today()返回服务器所需格式的当前日期，它使用UTC作为一个引用。这足以计算默认值，这种情况下只需使用函数名无需添加括号。</li>
<li> fields.Datetime.now() 返回服务器所需格式的当前datetime，它使用UTC作为一个引用。这足以计算默认值，</li>
<li>fields.Date.context_today(record, timestamp&#x3D;None)在会话上下文中返回带有当前日期的字符串。时间从记录上下文中获取。可选项timestamp参数是一个datetime对象，如果传入将不使用当前时间，而使用传入值。</li>
<li>fields.Datetime.context_timestamp(record, timestamp)将原生的datetime值(无时区)转换为具体时区的datetime。时区从记录上下文中提取，因此使了前述函数名。</li>
</ul>
<h3 id="转换文本形式的日期和时间"><a href="#转换文本形式的日期和时间" class="headerlink" title="转换文本形式的日期和时间"></a>转换文本形式的日期和时间</h3><p>在Odoo 12以前，在进行运算前我们需要对文本形式的date和datetime进行转换。有些工作可帮助我们完成文本和原生数据类型的相互转换。这在此前的 Odoo 版本中都非常有用并且在 Odoo 12中也仍然相关：我们要将给到的日期格式化为文本。为便于格式之间的转换，fields.Date和fields.Datetime都提供了如下函数：</p>
<ul>
<li>to_date将字符串转换为date对象</li>
<li>to_datetime(value)将字符串转换为datetime对象</li>
<li>to_string(value)将date或datetime对象转换为 Odoo 11及之前版本Odoo服务所需的字符串格式</li>
</ul>
<p>函数所需的文本格式由 Odoo 通过如下方式默认预置：</p>
<ul>
<li>odoo.tools.DEFAULT_SERVER_DATE_FORMAT</li>
<li>odoo.tools.DEFAULT_SERVER_DATETIME_FORMAT</li>
</ul>
<p>它们分别与%Y-%m-%d和%Y-%m-%d %H:%M:%S相对应。from_string用法示例如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; from odoo import fields</span><br><span class="line">&gt;&gt;&gt; fields.Datetime.to_datetime(&#x27;2019-01-12 13:48:50&#x27;)</span><br><span class="line">datetime.datetime(2019, 1, 12, 13, 48, 50)</span><br></pre></td></tr></table></figure>

<p>对于其它的日期和时间格式，可使用datetime对象中的strptime方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; from datetime import datetime</span><br><span class="line">&gt;&gt;&gt; datetime.strptime(&#x27;1/1/2019&#x27;, &#x27;%d/%m/%Y&#x27;)</span><br><span class="line">datetime.datetime(2019, 1, 1, 0, 0)</span><br></pre></td></tr></table></figure>

<h2 id="在记录中写入"><a href="#在记录中写入" class="headerlink" title="在记录中写入"></a>在记录中写入</h2><p>有两种写入记录的方式：使用对象形式直接分配和使用write() 方法。第一种很简单但一次只能操作一条记录，效率较低。因为每次分配都执行一次写操作，会产生冗余的重复计算。第二种要求写入关联字段时使用特殊语法，但每条命令可写入多个字段和记录，记录计算更为高效。</p>
<h3 id="使用对象形式分配值写入"><a href="#使用对象形式分配值写入" class="headerlink" title="使用对象形式分配值写入"></a>使用对象形式分配值写入</h3><p>记录集实施活跃记录模式。也就是说我们可以为其分配值，并且会将这些修改在数据库中持久化存储。这是一种操作数据的易于理解和便捷的方式，但一次只能操作一个字段和一条记录。如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; root = self.env[&#x27;res.users&#x27;].browse(1)</span><br><span class="line">&gt;&gt;&gt; print(root.name)</span><br><span class="line">OdooBot</span><br><span class="line">&gt;&gt;&gt; root.name = &#x27;Superuser&#x27;</span><br><span class="line">&gt;&gt;&gt; print(root.name)</span><br><span class="line">Superuser</span><br></pre></td></tr></table></figure>

<p>虽然使用的是活跃记录模式，也可以通过分配记录值来设置关联字段。对于many-to-one字段，分配的值必须是单条记录（单例）。对于to-many字段，也可以通过一条记录集分配，来替换关联记录列表为新列表（如果有的话），这里允许任何大小的记录集。</p>
<h3 id="通过-write-方法写入"><a href="#通过-write-方法写入" class="headerlink" title="通过 write()方法写入"></a>通过 write()方法写入</h3><p>我们还可以使用write()方法来同时更新多条记录中的多个字段，仅需一条数据库命令。所以在重视效果时就应优先考虑这一方式。write() 接收一个字典来进行字段和值的映射。这会更新记录集中的所有记录并且没有返回值，如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; Partner = self.env[&#x27;res.partner&#x27;]</span><br><span class="line">&gt;&gt;&gt; recs = Partner.search( [(&#x27;name&#x27;, &#x27;ilike&#x27;, &#x27;Azure&#x27;)] )</span><br><span class="line">&gt;&gt;&gt; recs.write(&#123;&#x27;comment&#x27;: &#x27;Hello!&#x27;&#125;)</span><br><span class="line">True</span><br></pre></td></tr></table></figure>

<p>与对象形式的分配不同，使用write() 方法时我们不能直接为关联字段分配记录集对象。取而代之的是，我们需要使用所需的记录ID来从记录集中进行提取。在写入many-to-one字段时，写入的值必须是关联记录的ID。例如，我们不用self.write({‘user_id’: self.env.user})，而应使用self.write({‘user_id’: self.env.user.id})。</p>
<p>在写入to-many字段时，写入的值必须使用和 XML 数据文件相同的特殊语法，这在第五章 <a target="_blank" rel="noopener" href="https://alanhou.org/odoo12-import-export-data/">Odoo 12开发之导入、导出以及模块数据</a>中有介绍。比如，我们设置图书作者列表为author1和author2，这是两条 Partner 记录。| 管道运算符可拼接记录来创建一个记录集，因此使用对象形式的分配可以这么写：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">publisher.child_ids = author1 | author2</span><br></pre></td></tr></table></figure>

<p>使用write()方法，同样的操作如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">book.write( &#123; &#x27;child_ids&#x27;: [(6, 0, [author1.id, author2.id])] &#125; )</span><br></pre></td></tr></table></figure>

<p>回顾第五章 <a target="_blank" rel="noopener" href="https://alanhou.org/odoo12-import-export-data/">Odoo 12开发之导入、导出以及模块数据</a>的写入语法，最常用的命令如下：</p>
<ul>
<li>(4, id, _)添加一条记录</li>
<li>(6, _, [ids])替换关联记录列表为所传入的列表</li>
</ul>
<h3 id="写入日期和时间值"><a href="#写入日期和时间值" class="headerlink" title="写入日期和时间值"></a>写入日期和时间值</h3><p>从 Odoo 12开始，不论是直接分配还是使用 write()方法，日期和时间字段都可以 Python 原生数据类型写入。我们仍可以使用文本形式值写入日期和时间：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; demo = self.search([(&#x27;login&#x27;, &#x27;=&#x27;, &#x27;demo&#x27;)])</span><br><span class="line">&gt;&gt;&gt; demo.login_date</span><br><span class="line">False</span><br><span class="line">&gt;&gt;&gt; demo.login_date = &#x27;2019-01-01 09:00:00&#x27;</span><br><span class="line">&gt;&gt;&gt; demo.login_date</span><br><span class="line">datetime.datetime(2019, 1, 1, 9, 0)</span><br></pre></td></tr></table></figure>

<h3 id="创建和删除记录"><a href="#创建和删除记录" class="headerlink" title="创建和删除记录"></a>创建和删除记录</h3><p>write()方法用于向已有记录写入日期，但我们还需要创建和删除记录。这通过create()和unlink()模型方法实现。create()接收所需创建记录字段和值组成的字典，语法与 write()一致。没错，默认值会被自动应用，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; Partner = self.env[&#x27;res.partner&#x27;]</span><br><span class="line">&gt;&gt;&gt; new = Partner.create(&#123;&#x27;name&#x27;: &#x27;ACME&#x27;, &#x27;is_company&#x27;: True&#125;)</span><br><span class="line">&gt;&gt;&gt; print(new)</span><br><span class="line">res.partner(64,)</span><br><span class="line">&gt;&gt;&gt; print(new.customer) # customer标记默认为 True</span><br><span class="line">True</span><br></pre></td></tr></table></figure>

<p>unlink()方法会删除记录集中的记录，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; rec = Partner.search([(&#x27;name&#x27;, &#x27;=&#x27;, &#x27;ACME&#x27;)])</span><br><span class="line">&gt;&gt;&gt; rec.unlink()</span><br><span class="line">2019-01-12 06:32:48,601 2612 INFO dev12 odoo.models.unlink: User #1 deleted mail.message records with IDs: [28]</span><br><span class="line">2019-01-12 06:32:48,651 2612 INFO dev12 odoo.models.unlink: User #1 deleted ir.attachment records with IDs: [416, 415, 414]</span><br><span class="line">2019-01-12 06:32:48,655 2612 INFO dev12 odoo.models.unlink: User #1 deleted res.partner records with IDs: [64]</span><br><span class="line">2019-01-12 06:32:48,666 2612 INFO dev12 odoo.models.unlink: User #1 deleted mail.followers records with IDs: [7]</span><br><span class="line">True</span><br></pre></td></tr></table></figure>

<p>以上我们看到日志中几条其它记录被删除的消息，这些是所删除 partner 关联字段的串联删除。</p>
<p>还有copy()模型方法可用于复制已有记录，它接收一个可选参数来在新记录中修改值，如复制demo 用户创建一个新用户：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; demo = self.env.ref(&#x27;base.user_demo&#x27;)</span><br><span class="line">&gt;&gt;&gt; new = demo.copy(&#123;&#x27;name&#x27;: &#x27;Daniel&#x27;, &#x27;login&#x27;: &#x27;daniel&#x27;, &#x27;email&#x27;: &#x27;&#x27;&#125;)</span><br></pre></td></tr></table></figure>

<p>带有copy&#x3D;False属性的字段不会被自动拷贝。to-many关联字段带有该标记时默认被禁用，因此也不可拷贝。</p>
<h2 id="重构记录集"><a href="#重构记录集" class="headerlink" title="重构记录集"></a>重构记录集</h2><p>记录集还支持一些其它运算。我们可查看一条记录是否在记录集中。如果x是一个单例，并且my_recordset是一个包含多条记录的记录集，可使用如下代码：</p>
<ul>
<li>x in my_recordset</li>
<li>x not in my_recordset</li>
</ul>
<p>还能使用如下运算：</p>
<ul>
<li>recordset.ids 返回记录集元素的ID列表</li>
<li>recordset.ensure_one()检查是否为单条记录（单例）；若不是，则抛出ValueError异常</li>
<li>recordset.filtered(func)返回一个过滤了的记录集，func可以是一个函数或一个点号分隔的表达式来表示字段路径，可参见下面的示例。</li>
<li>recordset.mapped(func)返回一个映射值列表。除函数外，还可使用文本字符串作为映射的字段名。</li>
<li>recordset.sorted(func)返回一个排好序的记录值。除函数外，文本字符串可用作排序的字段名。reverse&#x3D;True是其可选参数。</li>
</ul>
<p>以下是这些函数的使用示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; rs0 = self.env[&#x27;res.partner&#x27;].search([])</span><br><span class="line">&gt;&gt;&gt; len(rs0)</span><br><span class="line">48</span><br><span class="line">&gt;&gt;&gt; starts_A = lambda r: r.name.startswith(&#x27;A&#x27;)</span><br><span class="line">&gt;&gt;&gt; rs1 = rs0.filtered(starts_A)</span><br><span class="line">&gt;&gt;&gt; print(rs1)</span><br><span class="line">res.partner(63, 59, 14, 35)</span><br><span class="line">&gt;&gt;&gt; rs1.sorted(key=lambda r: r.id, reverse=True)</span><br><span class="line">res.partner(63, 59, 35, 14)</span><br><span class="line">&gt;&gt;&gt; rs2 = rs1.filtered(&#x27;is_company&#x27;)</span><br><span class="line">&gt;&gt;&gt; print(rs2)</span><br><span class="line">res.partner(14,)</span><br><span class="line">&gt;&gt;&gt; rs2.mapped(&#x27;name&#x27;)</span><br><span class="line">[&#x27;Azure Interior&#x27;]</span><br><span class="line">&gt;&gt;&gt; rs2.mapped(lambda r: (r.id, r.name))</span><br><span class="line">[(14, &#x27;Azure Interior&#x27;)]</span><br></pre></td></tr></table></figure>

<p>我们势必会对这些关联字段中的元素进行添加、删除或替换的操作，那么就带来了一个问题：如何操作这些记录集呢？</p>
<p>记录集是不可变的，也就是说不能直接修改其值。那么修改记录集就意味着在原有的基础上创建一个新的记录集。一种方式是使用所支持的集合运算：</p>
<ul>
<li>rs1 | rs2是一个集合的并运算，会生成一个包含两个记录集所有元素的记录集</li>
<li>rs1 + rs2是集合加法运算，会将两个记录集拼接为一个记录集，这可能会带来集合中有重复记录</li>
<li>rs1 &amp; rs2是集合的交集运算，会生成一个仅在两个记录集中同时出现元素组成的数据集</li>
<li>rs1 - rs2是集合的差集运算，会生成在rs1中有但rs2中没有的元素组成的数据集</li>
</ul>
<p>还可以使用分片标记，例如：</p>
<ul>
<li>rs[0]和rs[-1]分别返回第一个和最后一个元素</li>
<li>rs[1:]返回除第一元素外的记录集拷贝。其结果和rs - rs[0]相同，但保留了排序</li>
</ul>
<blockquote>
<p>ℹ️<strong>Odoo 10中的修改</strong><br>从Odoo 10开始，记录集操作保留了排序。此前的 Odoo 版本中，记录集操作不一定会保留排序，虽然加运算和切片已知是保留排序的。</p>
</blockquote>
<p>我们可以用如下运算通过删除或添加元素来修改记录集：</p>
<ul>
<li>self.author_ids |&#x3D; author1：如果不存在author1，它会将author1加入记录集</li>
<li>self.author_ids -&#x3D; author1：如果author1存在于记录集中，会进行删除</li>
<li>self.author_ids &#x3D; self.author_ids[:-1]删除最后一条记录</li>
</ul>
<p>关联字段包含记录集值。many-to-one 可包含单例记录集，to-many字段包含任意数量记录的记录集。</p>
<h2 id="使用底层-SQL-和数据库事务"><a href="#使用底层-SQL-和数据库事务" class="headerlink" title="使用底层 SQL 和数据库事务"></a>使用底层 SQL 和数据库事务</h2><p>数据库引入运算在一个数据库事务上下文中执行。通常我们无需担心这点，因为服务器在运行模型方法时会进行处理。但有些情况下，可能需要对事务进行更精细控制。这可通过数据库游标self.env.cr来实现，如下所示：</p>
<ul>
<li>self.env.cr.commit()执行事务缓冲的写运算</li>
<li>self.env.cr.rollback()取消上次 commit之后的写运算，如果尚未 commit，则回滚所有操作</li>
</ul>
<blockquote>
<p><strong>小贴士：</strong> 在shell会话中，直到执行self.env.cr.commit()时数据操作才会在数据库中生效</p>
</blockquote>
<p>通过游标execute() 方法，我们可以直接在数据库中运行 SQL 语句。它接收一个要运行的SQL 语句，以及第二个可选参数：一个用作 SQL 参数值的元组或列表。这些值会用在%s占位符之处。</p>
<ul>
<li>ℹ️<strong>注意：</strong><br>在cr.execute() 中我们不应直接编写拼接参数的SQL查询。众所周知这样做会带来SQL注入攻击的安全风险。保持使用%s占位符并通过第二个参数来传值。</li>
</ul>
<p>如果使用SELECT查询，会获取到记录。fetchall() 函数以元组列表的形式获取所有行，dictfetchall()则以字典列表的形式获取，示例如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; self.env.cr.execute(&quot;SELECT id, login FROM res_users WHERE login=%s OR id=%s&quot;, (&#x27;demo&#x27;,1))</span><br><span class="line">&gt;&gt;&gt; self.env.cr.fetchall()</span><br><span class="line">[(1, &#x27;__system__&#x27;), (6, &#x27;demo&#x27;)]</span><br><span class="line">&gt;&gt;&gt; self.env.cr.execute(&quot;SELECT id, login FROM res_users WHERE login=%s OR id=%s&quot;, (&#x27;demo&#x27;,1))</span><br><span class="line">&gt;&gt;&gt; self.env.cr.dictfetchall()</span><br><span class="line">[&#123;&#x27;id&#x27;: 1, &#x27;login&#x27;: &#x27;__system__&#x27;&#125;, &#123;&#x27;id&#x27;: 6, &#x27;login&#x27;: &#x27;demo&#x27;&#125;]</span><br></pre></td></tr></table></figure>

<p>还可以使用数据操纵语言(DML) 来运行指令，如UPDATE和INSERT。因为服务器保留数据缓存，这可能导致与数据库中实际数据的不一致。出于这个原因，在使用原生DML后，应使用self.env.cache.invalidate()清除缓存。</p>
<blockquote>
<p>ℹ️<strong>注意：</strong><br>直接在数据库中执行SQL语句可能会导致数据不一致，请仅在确定时进行该操作。</p>
</blockquote>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在本文中，我们学习了如何操作模型数据以及执行 CRUD 运算：创建、读取、更新和删除数据。这是实现我们的业务逻辑和自动化的基石。</p>
<p>对于ORM API的测试，我们使用了Odoo交互式 shell 命令行。我们通过self.env环境运行了命令，该环境可访问模型注册表并提供命令运行相关信息的上下文，如当前语言 lang 和时区 tz。</p>
<p>记录集使用search(<domain>)或browse([<ids>])ORM 方法创建。之后可对其进行遍历访问每个单例(一条独立的记录)。我们还可以使用对象样式的点号标记在单例中获取和设置记录值。</p>
<p>除直接为单例分配值外，我们还可以使用write(<dict>)来通过单条命令更新记录集中的所有元素。create(), copy()和unlink()命令用于创建、拷贝和删除记录。</p>
<p>记录集可被检查和操作，检查运算符包含in和not in。重构运算符包含并集的|，交集的&amp;以及切片:。可用的转换包含提取 ID 列表的.ids、.mapped(<field>)、.filtered(<func>) 或.sorted(<func>)。</p>
<p>最后，通过self.env.cr中暴露的游标对象可控制底层 SQL 运行和事务控制。</p>
<p>在下一篇文章中，我们将为模型添加业务逻辑层，实现通过ORM API来自动化操作的模型方法。</p>
<p> </p>
<p>☞☞☞第八章 <a target="_blank" rel="noopener" href="https://alanhou.org/odoo12-business-logic/">Odoo 12开发之业务逻辑 - 业务流程的支持</a></p>
<p>本文首发地址：<a target="_blank" rel="noopener" href="https://alanhou.org/developer-mode-odoo12/">Alan Hou 的个人博客</a></p>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Odoo12/" rel="tag"># Odoo12</a>
              <a href="/tags/Odoo/" rel="tag"># Odoo</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2019/01/11/odoo-essentials-12-chapter6/" rel="prev" title="第六章 Odoo 12开发之模型 – 结构化应用数据">
                  <i class="fa fa-chevron-left"></i> 第六章 Odoo 12开发之模型 – 结构化应用数据
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2019/01/14/odoo-essentials-12-chapter8/" rel="next" title="第八章 Odoo 12开发之业务逻辑 – 业务流程的支持">
                  第八章 Odoo 12开发之业务逻辑 – 业务流程的支持 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Alan Hou</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a>
  </div>

    </div>
  </footer>

  
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  




  





</body>
</html>
